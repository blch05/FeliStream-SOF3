import {
  BitField,
  Peer,
  __commonJS,
  __export,
  __publicField,
  __reExport,
  __toESM,
  arr2base,
  arr2hex,
  arr2text,
  bencode_default,
  bin2hex,
  bittorrent_protocol_default,
  concat,
  hash,
  hex2arr,
  hex2bin,
  randomBytes,
  require_browser,
  require_crypto,
  require_events,
  require_streamx,
  require_throughput,
  require_unordered_array_remove,
  text2arr
} from "./chunk-YE6UDQJG.js";

// browser-external:path
var require_path = __commonJS({
  "browser-external:path"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "path" has been externalized for browser compatibility. Cannot access "path.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/block-iterator/index.js
var require_block_iterator = __commonJS({
  "node_modules/block-iterator/index.js"(exports, module) {
    function concat2(chunks, size) {
      if (typeof chunks[0] === "string") return chunks.join("");
      if (typeof chunks[0] === "number") return new Uint8Array(chunks);
      const b = new Uint8Array(size);
      let offset = 0;
      for (let i = 0, l = chunks.length; i < l; i++) {
        const chunk = chunks[i];
        b.set(chunk, offset);
        offset += chunk.byteLength || chunk.length;
      }
      return b;
    }
    module.exports = async function* (iterator, size = 512, opts = {}) {
      if (typeof size === "object") {
        opts = size;
        size = opts.size;
      }
      let { nopad, zeroPadding = true } = opts;
      if (nopad) zeroPadding = false;
      let buffered = [];
      let bufferedBytes = 0;
      for await (const value of iterator) {
        bufferedBytes += value.byteLength || value.length || 1;
        buffered.push(value);
        if (bufferedBytes >= size) {
          const b = concat2(buffered, bufferedBytes);
          let offset = 0;
          while (bufferedBytes >= size) {
            yield b.slice(offset, offset + size);
            bufferedBytes -= size;
            offset += size;
          }
          buffered = [b.slice(offset, b.length)];
        }
      }
      if (bufferedBytes) yield concat2(buffered, zeroPadding ? size : bufferedBytes);
    };
  }
});

// node_modules/piece-length/index.js
var require_piece_length = __commonJS({
  "node_modules/piece-length/index.js"(exports, module) {
    module.exports = length;
    function length(bytes) {
      return Math.max(16384, 1 << Math.log2(bytes < 1024 ? 1 : bytes / 1024) + 0.5 | 0);
    }
  }
});

// browser-external:is-file
var require_is_file = __commonJS({
  "browser-external:is-file"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "is-file" has been externalized for browser compatibility. Cannot access "is-file.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/join-async-iterator/index.js
var require_join_async_iterator = __commonJS({
  "node_modules/join-async-iterator/index.js"(exports, module) {
    module.exports = async function* (iterators) {
      for (let iterator of iterators) {
        if (typeof iterator === "function") iterator = iterator();
        yield* iterator;
      }
    };
  }
});

// node_modules/queue-microtask/index.js
var require_queue_microtask = __commonJS({
  "node_modules/queue-microtask/index.js"(exports, module) {
    var promise;
    module.exports = typeof queueMicrotask === "function" ? queueMicrotask.bind(typeof window !== "undefined" ? window : global) : (cb) => (promise || (promise = Promise.resolve())).then(cb).catch((err2) => setTimeout(() => {
      throw err2;
    }, 0));
  }
});

// node_modules/run-parallel/index.js
var require_run_parallel = __commonJS({
  "node_modules/run-parallel/index.js"(exports, module) {
    module.exports = runParallel;
    var queueMicrotask9 = require_queue_microtask();
    function runParallel(tasks, cb) {
      let results, pending, keys;
      let isSync = true;
      if (Array.isArray(tasks)) {
        results = [];
        pending = tasks.length;
      } else {
        keys = Object.keys(tasks);
        results = {};
        pending = keys.length;
      }
      function done(err2) {
        function end() {
          if (cb) cb(err2, results);
          cb = null;
        }
        if (isSync) queueMicrotask9(end);
        else end();
      }
      function each(i, err2, result) {
        results[i] = result;
        if (--pending === 0 || err2) {
          done(err2);
        }
      }
      if (!pending) {
        done(null);
      } else if (keys) {
        keys.forEach(function(key) {
          tasks[key](function(err2, result) {
            each(key, err2, result);
          });
        });
      } else {
        tasks.forEach(function(task, i) {
          task(function(err2, result) {
            each(i, err2, result);
          });
        });
      }
      isSync = false;
    }
  }
});

// (disabled):node_modules/create-torrent/get-files.js
var require_get_files = __commonJS({
  "(disabled):node_modules/create-torrent/get-files.js"() {
  }
});

// browser-external:bittorrent-dht
var require_bittorrent_dht = __commonJS({
  "browser-external:bittorrent-dht"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "bittorrent-dht" has been externalized for browser compatibility. Cannot access "bittorrent-dht.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:load-ip-set
var require_load_ip_set = __commonJS({
  "browser-external:load-ip-set"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "load-ip-set" has been externalized for browser compatibility. Cannot access "load-ip-set.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:fs
var require_fs = __commonJS({
  "browser-external:fs"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "fs" has been externalized for browser compatibility. Cannot access "fs.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/err-code/index.js
var require_err_code = __commonJS({
  "node_modules/err-code/index.js"(exports, module) {
    "use strict";
    function assign(obj, props) {
      for (const key in props) {
        Object.defineProperty(obj, key, {
          value: props[key],
          enumerable: true,
          configurable: true
        });
      }
      return obj;
    }
    function createError(err2, code, props) {
      if (!err2 || typeof err2 === "string") {
        throw new TypeError("Please pass an Error to err-code");
      }
      if (!props) {
        props = {};
      }
      if (typeof code === "object") {
        props = code;
        code = "";
      }
      if (code) {
        props.code = code;
      }
      try {
        return assign(err2, props);
      } catch (_) {
        props.message = err2.message;
        props.stack = err2.stack;
        const ErrClass = function() {
        };
        ErrClass.prototype = Object.create(Object.getPrototypeOf(err2));
        const output = assign(new ErrClass(), props);
        return output;
      }
    }
    module.exports = createError;
  }
});

// node_modules/speed-limiter/lib/utils.js
var require_utils = __commonJS({
  "node_modules/speed-limiter/lib/utils.js"(exports, module) {
    function wait(time) {
      return new Promise((resolve) => setTimeout(resolve, time));
    }
    module.exports = {
      wait
    };
  }
});

// node_modules/limiter/lib/tokenBucket.js
var require_tokenBucket = __commonJS({
  "node_modules/limiter/lib/tokenBucket.js"(exports, module) {
    var TokenBucket = function(bucketSize, tokensPerInterval, interval, parentBucket) {
      this.bucketSize = bucketSize;
      this.tokensPerInterval = tokensPerInterval;
      if (typeof interval === "string") {
        switch (interval) {
          case "sec":
          case "second":
            this.interval = 1e3;
            break;
          case "min":
          case "minute":
            this.interval = 1e3 * 60;
            break;
          case "hr":
          case "hour":
            this.interval = 1e3 * 60 * 60;
            break;
          case "day":
            this.interval = 1e3 * 60 * 60 * 24;
            break;
          default:
            throw new Error("Invaid interval " + interval);
        }
      } else {
        this.interval = interval;
      }
      this.parentBucket = parentBucket;
      this.content = 0;
      this.lastDrip = +/* @__PURE__ */ new Date();
    };
    TokenBucket.prototype = {
      bucketSize: 1,
      tokensPerInterval: 1,
      interval: 1e3,
      parentBucket: null,
      content: 0,
      lastDrip: 0,
      /**
       * Remove the requested number of tokens and fire the given callback. If the
       * bucket (and any parent buckets) contains enough tokens this will happen
       * immediately. Otherwise, the removal and callback will happen when enough
       * tokens become available.
       * @param {Number} count The number of tokens to remove.
       * @param {Function} callback(err, remainingTokens)
       * @returns {Boolean} True if the callback was fired immediately, otherwise
       *  false.
       */
      removeTokens: function(count, callback) {
        var self2 = this;
        if (!this.bucketSize) {
          process.nextTick(callback.bind(null, null, count, Number.POSITIVE_INFINITY));
          return true;
        }
        if (count > this.bucketSize) {
          process.nextTick(callback.bind(null, "Requested tokens " + count + " exceeds bucket size " + this.bucketSize, null));
          return false;
        }
        this.drip();
        if (count > this.content)
          return comeBackLater();
        if (this.parentBucket) {
          return this.parentBucket.removeTokens(count, function(err2, remainingTokens) {
            if (err2) return callback(err2, null);
            if (count > self2.content)
              return comeBackLater();
            self2.content -= count;
            callback(null, Math.min(remainingTokens, self2.content));
          });
        } else {
          this.content -= count;
          process.nextTick(callback.bind(null, null, this.content));
          return true;
        }
        function comeBackLater() {
          var waitInterval = Math.ceil(
            (count - self2.content) * (self2.interval / self2.tokensPerInterval)
          );
          setTimeout(function() {
            self2.removeTokens(count, callback);
          }, waitInterval);
          return false;
        }
      },
      /**
       * Attempt to remove the requested number of tokens and return immediately.
       * If the bucket (and any parent buckets) contains enough tokens this will
       * return true, otherwise false is returned.
       * @param {Number} count The number of tokens to remove.
       * @param {Boolean} True if the tokens were successfully removed, otherwise
       *  false.
       */
      tryRemoveTokens: function(count) {
        if (!this.bucketSize)
          return true;
        if (count > this.bucketSize)
          return false;
        this.drip();
        if (count > this.content)
          return false;
        if (this.parentBucket && !this.parentBucket.tryRemoveTokens(count))
          return false;
        this.content -= count;
        return true;
      },
      /**
       * Add any new tokens to the bucket since the last drip.
       * @returns {Boolean} True if new tokens were added, otherwise false.
       */
      drip: function() {
        if (!this.tokensPerInterval) {
          this.content = this.bucketSize;
          return;
        }
        var now = +/* @__PURE__ */ new Date();
        var deltaMS = Math.max(now - this.lastDrip, 0);
        this.lastDrip = now;
        var dripAmount = deltaMS * (this.tokensPerInterval / this.interval);
        this.content = Math.min(this.content + dripAmount, this.bucketSize);
      }
    };
    module.exports = TokenBucket;
  }
});

// node_modules/limiter/lib/clock.js
var require_clock = __commonJS({
  "node_modules/limiter/lib/clock.js"(exports, module) {
    var getMilliseconds = function() {
      if (typeof process !== "undefined" && process.hrtime) {
        var hrtime = process.hrtime();
        var seconds = hrtime[0];
        var nanoseconds = hrtime[1];
        return seconds * 1e3 + Math.floor(nanoseconds / 1e6);
      }
      return (/* @__PURE__ */ new Date()).getTime();
    };
    module.exports = getMilliseconds;
  }
});

// node_modules/limiter/lib/rateLimiter.js
var require_rateLimiter = __commonJS({
  "node_modules/limiter/lib/rateLimiter.js"(exports, module) {
    var TokenBucket = require_tokenBucket();
    var getMilliseconds = require_clock();
    var RateLimiter = function(tokensPerInterval, interval, fireImmediately) {
      this.tokenBucket = new TokenBucket(
        tokensPerInterval,
        tokensPerInterval,
        interval,
        null
      );
      this.tokenBucket.content = tokensPerInterval;
      this.curIntervalStart = getMilliseconds();
      this.tokensThisInterval = 0;
      this.fireImmediately = fireImmediately;
    };
    RateLimiter.prototype = {
      tokenBucket: null,
      curIntervalStart: 0,
      tokensThisInterval: 0,
      fireImmediately: false,
      /**
       * Remove the requested number of tokens and fire the given callback. If the
       * rate limiter contains enough tokens and we haven't spent too many tokens
       * in this interval already, this will happen immediately. Otherwise, the
       * removal and callback will happen when enough tokens become available.
       * @param {Number} count The number of tokens to remove.
       * @param {Function} callback(err, remainingTokens)
       * @returns {Boolean} True if the callback was fired immediately, otherwise
       *  false.
       */
      removeTokens: function(count, callback) {
        if (count > this.tokenBucket.bucketSize) {
          process.nextTick(callback.bind(
            null,
            "Requested tokens " + count + " exceeds maximum tokens per interval " + this.tokenBucket.bucketSize,
            null
          ));
          return false;
        }
        var self2 = this;
        var now = getMilliseconds();
        if (now < this.curIntervalStart || now - this.curIntervalStart >= this.tokenBucket.interval) {
          this.curIntervalStart = now;
          this.tokensThisInterval = 0;
        }
        if (count > this.tokenBucket.tokensPerInterval - this.tokensThisInterval) {
          if (this.fireImmediately) {
            process.nextTick(callback.bind(null, null, -1));
          } else {
            var waitInterval = Math.ceil(
              this.curIntervalStart + this.tokenBucket.interval - now
            );
            setTimeout(function() {
              self2.tokenBucket.removeTokens(count, afterTokensRemoved);
            }, waitInterval);
          }
          return false;
        }
        return this.tokenBucket.removeTokens(count, afterTokensRemoved);
        function afterTokensRemoved(err2, tokensRemaining) {
          if (err2) return callback(err2, null);
          self2.tokensThisInterval += count;
          callback(null, tokensRemaining);
        }
      },
      /**
       * Attempt to remove the requested number of tokens and return immediately.
       * If the bucket (and any parent buckets) contains enough tokens and we
       * haven't spent too many tokens in this interval already, this will return
       * true. Otherwise, false is returned.
       * @param {Number} count The number of tokens to remove.
       * @param {Boolean} True if the tokens were successfully removed, otherwise
       *  false.
       */
      tryRemoveTokens: function(count) {
        if (count > this.tokenBucket.bucketSize)
          return false;
        var now = getMilliseconds();
        if (now < this.curIntervalStart || now - this.curIntervalStart >= this.tokenBucket.interval) {
          this.curIntervalStart = now;
          this.tokensThisInterval = 0;
        }
        if (count > this.tokenBucket.tokensPerInterval - this.tokensThisInterval)
          return false;
        var removed = this.tokenBucket.tryRemoveTokens(count);
        if (removed) {
          this.tokensThisInterval += count;
        }
        return removed;
      },
      /**
       * Returns the number of tokens remaining in the TokenBucket.
       * @returns {Number} The number of tokens remaining.
       */
      getTokensRemaining: function() {
        this.tokenBucket.drip();
        return this.tokenBucket.content;
      }
    };
    module.exports = RateLimiter;
  }
});

// node_modules/limiter/index.js
var require_limiter = __commonJS({
  "node_modules/limiter/index.js"(exports) {
    exports.RateLimiter = require_rateLimiter();
    exports.TokenBucket = require_tokenBucket();
  }
});

// node_modules/speed-limiter/lib/throttle-group.js
var require_throttle_group = __commonJS({
  "node_modules/speed-limiter/lib/throttle-group.js"(exports, module) {
    var { TokenBucket } = require_limiter();
    var Throttle = require_throttle();
    var ThrottleGroup2 = class {
      constructor(opts = {}) {
        if (typeof opts !== "object") throw new Error("Options must be an object");
        this.throttles = [];
        this.setEnabled(opts.enabled);
        this.setRate(opts.rate, opts.chunksize);
      }
      getEnabled() {
        return this._enabled;
      }
      getRate() {
        return this.bucket.tokensPerInterval;
      }
      getChunksize() {
        return this.chunksize;
      }
      setEnabled(val = true) {
        if (typeof val !== "boolean") throw new Error("Enabled must be a boolean");
        this._enabled = val;
        for (const throttle of this.throttles) {
          throttle.setEnabled(val);
        }
      }
      setRate(rate, chunksize = null) {
        if (!Number.isInteger(rate) || rate < 0) throw new Error("Rate must be an integer bigger than zero");
        rate = parseInt(rate);
        if (chunksize && (typeof chunksize !== "number" || chunksize <= 0)) throw new Error("Chunksize must be bigger than zero");
        chunksize = chunksize || Math.max(parseInt(rate / 10), 1);
        chunksize = parseInt(chunksize);
        if (rate > 0 && chunksize > rate) throw new Error("Chunk size must be smaller than rate");
        if (!this.bucket) this.bucket = new TokenBucket(rate, rate, "second", null);
        this.bucket.bucketSize = rate;
        this.bucket.tokensPerInterval = rate;
        this.chunksize = chunksize;
      }
      setChunksize(chunksize) {
        if (!Number.isInteger(chunksize) || chunksize <= 0) throw new Error("Chunk size must be an integer bigger than zero");
        const rate = this.getRate();
        chunksize = parseInt(chunksize);
        if (rate > 0 && chunksize > rate) throw new Error("Chunk size must be smaller than rate");
        this.chunksize = chunksize;
      }
      throttle(opts = {}) {
        if (typeof opts !== "object") throw new Error("Options must be an object");
        const newThrottle = new Throttle({
          ...opts,
          group: this
        });
        return newThrottle;
      }
      destroy() {
        for (const throttle of this.throttles) {
          throttle.destroy();
        }
        this.throttles = [];
      }
      _addThrottle(throttle) {
        if (!(throttle instanceof Throttle)) throw new Error("Throttle must be an instance of Throttle");
        this.throttles.push(throttle);
      }
      _removeThrottle(throttle) {
        const index = this.throttles.indexOf(throttle);
        if (index > -1) this.throttles.splice(index, 1);
      }
    };
    module.exports = ThrottleGroup2;
  }
});

// node_modules/speed-limiter/lib/throttle.js
var require_throttle = __commonJS({
  "node_modules/speed-limiter/lib/throttle.js"(exports, module) {
    var { EventEmitter: EventEmitter11 } = require_events();
    var { Transform } = require_streamx();
    var { wait } = require_utils();
    var Throttle = class extends Transform {
      constructor(opts = {}) {
        super();
        if (typeof opts !== "object") throw new Error("Options must be an object");
        const params = Object.assign({}, opts);
        if (params.group && !(params.group instanceof ThrottleGroup2)) throw new Error("Group must be an instanece of ThrottleGroup");
        else if (!params.group) params.group = new ThrottleGroup2(params);
        this._setEnabled(params.enabled || params.group.enabled);
        this._group = params.group;
        this._emitter = new EventEmitter11();
        this._destroyed = false;
        this._group._addThrottle(this);
      }
      getEnabled() {
        return this._enabled;
      }
      getGroup() {
        return this._group;
      }
      _setEnabled(val = true) {
        if (typeof val !== "boolean") throw new Error("Enabled must be a boolean");
        this._enabled = val;
      }
      setEnabled(val) {
        this._setEnabled(val);
        if (this._enabled) this._emitter.emit("enabled");
        else this._emitter.emit("disabled");
      }
      _transform(chunk, done) {
        this._processChunk(chunk, done);
      }
      /* async _waitForPositiveRate () {
        // Stop pushing chunks if rate is zero
        while (this._group.getRate() === 0 && !this._destroyed && this._areBothEnabled()) {
          await wait(1 * 1000) // wait 1 second
        }
      } */
      async _waitForTokens(amount) {
        return new Promise((resolve, reject) => {
          let done = false;
          const self2 = this;
          function isDone(err2) {
            self2._emitter.removeListener("disabled", isDone);
            self2._emitter.removeListener("destroyed", isDone);
            if (done) return;
            done = true;
            if (err2) return reject(err2);
            resolve();
          }
          this._emitter.once("disabled", isDone);
          this._emitter.once("destroyed", isDone);
          this._group.bucket.removeTokens(amount, isDone);
        });
      }
      _areBothEnabled() {
        return this._enabled && this._group.getEnabled();
      }
      /* async _throttleChunk (size) {
          // Stop pushing chunks if rate is zero
          await this._waitForPositiveRate()
          if (this._destroyed) return
          if (!this._areBothEnabled()) return
      
          // Get tokens from bucket
          await this._waitForTokens(size)
        } */
      async _processChunk(chunk, done) {
        if (!this._areBothEnabled()) return done(null, chunk);
        let pos = 0;
        let chunksize = this._group.getChunksize();
        let slice = chunk.slice(pos, pos + chunksize);
        while (slice.length > 0) {
          if (this._areBothEnabled()) {
            try {
              while (this._group.getRate() === 0 && !this._destroyed && this._areBothEnabled()) {
                await wait(1e3);
                if (this._destroyed) return;
              }
              if (this._areBothEnabled() && !this._group.bucket.tryRemoveTokens(slice.length)) {
                await this._waitForTokens(slice.length);
                if (this._destroyed) return;
              }
            } catch (err2) {
              return done(err2);
            }
          }
          this.push(slice);
          pos += chunksize;
          chunksize = this._areBothEnabled() ? this._group.getChunksize() : chunk.length - pos;
          slice = chunk.slice(pos, pos + chunksize);
        }
        return done();
      }
      destroy(...args) {
        this._group._removeThrottle(this);
        this._destroyed = true;
        this._emitter.emit("destroyed");
        super.destroy(...args);
      }
    };
    module.exports = Throttle;
    var ThrottleGroup2 = require_throttle_group();
  }
});

// node_modules/speed-limiter/index.js
var require_speed_limiter = __commonJS({
  "node_modules/speed-limiter/index.js"(exports, module) {
    var Throttle = require_throttle();
    var ThrottleGroup2 = require_throttle_group();
    module.exports = {
      Throttle,
      ThrottleGroup: ThrottleGroup2
    };
  }
});

// browser-external:@silentbot1/nat-api
var require_nat_api = __commonJS({
  "browser-external:@silentbot1/nat-api"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "@silentbot1/nat-api" has been externalized for browser compatibility. Cannot access "@silentbot1/nat-api.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// (disabled):node_modules/webtorrent/lib/conn-pool.js
var require_conn_pool = __commonJS({
  "(disabled):node_modules/webtorrent/lib/conn-pool.js"() {
  }
});

// browser-external:net
var require_net = __commonJS({
  "browser-external:net"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "net" has been externalized for browser compatibility. Cannot access "net.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:os
var require_os = __commonJS({
  "browser-external:os"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "os" has been externalized for browser compatibility. Cannot access "os.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "node_modules/inherits/inherits_browser.js"(exports, module) {
    if (typeof Object.create === "function") {
      module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// node_modules/lru/index.js
var require_lru = __commonJS({
  "node_modules/lru/index.js"(exports, module) {
    var events = require_events();
    var inherits = require_inherits_browser();
    module.exports = LRU2;
    function LRU2(opts) {
      if (!(this instanceof LRU2)) return new LRU2(opts);
      if (typeof opts === "number") opts = { max: opts };
      if (!opts) opts = {};
      events.EventEmitter.call(this);
      this.cache = {};
      this.head = this.tail = null;
      this.length = 0;
      this.max = opts.max || 1e3;
      this.maxAge = opts.maxAge || 0;
    }
    inherits(LRU2, events.EventEmitter);
    Object.defineProperty(LRU2.prototype, "keys", {
      get: function() {
        return Object.keys(this.cache);
      }
    });
    LRU2.prototype.clear = function() {
      this.cache = {};
      this.head = this.tail = null;
      this.length = 0;
    };
    LRU2.prototype.remove = function(key) {
      if (typeof key !== "string") key = "" + key;
      if (!this.cache.hasOwnProperty(key)) return;
      var element = this.cache[key];
      delete this.cache[key];
      this._unlink(key, element.prev, element.next);
      return element.value;
    };
    LRU2.prototype._unlink = function(key, prev, next) {
      this.length--;
      if (this.length === 0) {
        this.head = this.tail = null;
      } else {
        if (this.head === key) {
          this.head = prev;
          this.cache[this.head].next = null;
        } else if (this.tail === key) {
          this.tail = next;
          this.cache[this.tail].prev = null;
        } else {
          this.cache[prev].next = next;
          this.cache[next].prev = prev;
        }
      }
    };
    LRU2.prototype.peek = function(key) {
      if (!this.cache.hasOwnProperty(key)) return;
      var element = this.cache[key];
      if (!this._checkAge(key, element)) return;
      return element.value;
    };
    LRU2.prototype.set = function(key, value) {
      if (typeof key !== "string") key = "" + key;
      var element;
      if (this.cache.hasOwnProperty(key)) {
        element = this.cache[key];
        element.value = value;
        if (this.maxAge) element.modified = Date.now();
        if (key === this.head) return value;
        this._unlink(key, element.prev, element.next);
      } else {
        element = { value, modified: 0, next: null, prev: null };
        if (this.maxAge) element.modified = Date.now();
        this.cache[key] = element;
        if (this.length === this.max) this.evict();
      }
      this.length++;
      element.next = null;
      element.prev = this.head;
      if (this.head) this.cache[this.head].next = key;
      this.head = key;
      if (!this.tail) this.tail = key;
      return value;
    };
    LRU2.prototype._checkAge = function(key, element) {
      if (this.maxAge && Date.now() - element.modified > this.maxAge) {
        this.remove(key);
        this.emit("evict", { key, value: element.value });
        return false;
      }
      return true;
    };
    LRU2.prototype.get = function(key) {
      if (typeof key !== "string") key = "" + key;
      if (!this.cache.hasOwnProperty(key)) return;
      var element = this.cache[key];
      if (!this._checkAge(key, element)) return;
      if (this.head !== key) {
        if (key === this.tail) {
          this.tail = element.next;
          this.cache[this.tail].prev = null;
        } else {
          this.cache[element.prev].next = element.next;
        }
        this.cache[element.next].prev = element.prev;
        this.cache[this.head].next = key;
        element.prev = this.head;
        element.next = null;
        this.head = key;
      }
      return element.value;
    };
    LRU2.prototype.evict = function() {
      if (!this.tail) return;
      var key = this.tail;
      var value = this.remove(this.tail);
      this.emit("evict", { key, value });
    };
  }
});

// node_modules/cache-chunk-store/index.js
var require_cache_chunk_store = __commonJS({
  "node_modules/cache-chunk-store/index.js"(exports, module) {
    var LRU2 = require_lru();
    var queueMicrotask9 = require_queue_microtask();
    var CacheStore = class {
      constructor(store, opts) {
        this.store = store;
        this.chunkLength = store.chunkLength;
        this.inProgressGets = /* @__PURE__ */ new Map();
        if (!this.store || !this.store.get || !this.store.put) {
          throw new Error("First argument must be abstract-chunk-store compliant");
        }
        this.cache = new LRU2(opts);
      }
      put(index, buf, cb = () => {
      }) {
        if (!this.cache) {
          return queueMicrotask9(() => cb(new Error("CacheStore closed")));
        }
        this.cache.remove(index);
        this.store.put(index, buf, cb);
      }
      get(index, opts, cb = () => {
      }) {
        if (typeof opts === "function") return this.get(index, null, opts);
        if (!this.cache) {
          return queueMicrotask9(() => cb(new Error("CacheStore closed")));
        }
        if (!opts) opts = {};
        let buf = this.cache.get(index);
        if (buf) {
          const offset = opts.offset || 0;
          const len = opts.length || buf.length - offset;
          if (offset !== 0 || len !== buf.length) {
            buf = buf.slice(offset, len + offset);
          }
          return queueMicrotask9(() => cb(null, buf));
        }
        let waiters = this.inProgressGets.get(index);
        const getAlreadyStarted = !!waiters;
        if (!waiters) {
          waiters = [];
          this.inProgressGets.set(index, waiters);
        }
        waiters.push({
          opts,
          cb
        });
        if (!getAlreadyStarted) {
          this.store.get(index, (err2, buf2) => {
            if (!err2 && this.cache != null) this.cache.set(index, buf2);
            const inProgressEntry = this.inProgressGets.get(index);
            this.inProgressGets.delete(index);
            for (const { opts: opts2, cb: cb2 } of inProgressEntry) {
              if (err2) {
                cb2(err2);
              } else {
                const offset = opts2.offset || 0;
                const len = opts2.length || buf2.length - offset;
                let slicedBuf = buf2;
                if (offset !== 0 || len !== buf2.length) {
                  slicedBuf = buf2.slice(offset, len + offset);
                }
                cb2(null, slicedBuf);
              }
            }
          });
        }
      }
      close(cb = () => {
      }) {
        if (!this.cache) {
          return queueMicrotask9(() => cb(new Error("CacheStore closed")));
        }
        this.cache = null;
        this.store.close(cb);
      }
      destroy(cb = () => {
      }) {
        if (!this.cache) {
          return queueMicrotask9(() => cb(new Error("CacheStore closed")));
        }
        this.cache = null;
        this.store.destroy(cb);
      }
    };
    module.exports = CacheStore;
  }
});

// node_modules/cpus/browser.js
var require_browser2 = __commonJS({
  "node_modules/cpus/browser.js"(exports, module) {
    module.exports = function cpus2() {
      var num = navigator.hardwareConcurrency || 1;
      var cpus3 = [];
      for (var i = 0; i < num; i++) {
        cpus3.push({
          model: "",
          speed: 0,
          times: { user: 0, nice: 0, sys: 0, idle: 0, irq: 0 }
        });
      }
      return cpus3;
    };
  }
});

// node_modules/base64-js/index.js
var require_base64_js = __commonJS({
  "node_modules/base64-js/index.js"(exports) {
    "use strict";
    exports.byteLength = byteLength;
    exports.toByteArray = toByteArray;
    exports.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i];
      revLookup[code.charCodeAt(i)] = i;
    }
    var i;
    var len;
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1) validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i2;
      for (i2 = 0; i2 < len2; i2 += 4) {
        tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i2 = start; i2 < end; i2 += 3) {
        tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
  }
});

// node_modules/ieee754/index.js
var require_ieee754 = __commonJS({
  "node_modules/ieee754/index.js"(exports) {
    exports.read = function(buffer, offset, isLE, mLen, nBytes) {
      var e, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i = isLE ? nBytes - 1 : 0;
      var d = isLE ? -1 : 1;
      var s = buffer[offset + i];
      i += d;
      e = s & (1 << -nBits) - 1;
      s >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
      }
      m = e & (1 << -nBits) - 1;
      e >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
      }
      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : (s ? -1 : 1) * Infinity;
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    };
    exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
      var e, m, c;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i = isLE ? 0 : nBytes - 1;
      var d = isLE ? 1 : -1;
      var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }
        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }
      for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
      }
      e = e << mLen | m;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
      }
      buffer[offset + i - d] |= s * 128;
    };
  }
});

// node_modules/buffer/index.js
var require_buffer = __commonJS({
  "node_modules/buffer/index.js"(exports) {
    "use strict";
    var base64 = require_base64_js();
    var ieee754 = require_ieee754();
    var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports.Buffer = Buffer2;
    exports.SlowBuffer = SlowBuffer;
    exports.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 2147483647;
    exports.kMaxLength = K_MAX_LENGTH;
    Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
    }
    function typedArraySupport() {
      try {
        var arr = new Uint8Array(1);
        var proto = { foo: function() {
          return 42;
        } };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e) {
        return false;
      }
    }
    Object.defineProperty(Buffer2.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this)) return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer2.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this)) return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
      }
      var buf = new Uint8Array(length);
      Object.setPrototypeOf(buf, Buffer2.prototype);
      return buf;
    }
    function Buffer2(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        }
        return allocUnsafe(arg);
      }
      return from(arg, encodingOrOffset, length);
    }
    Buffer2.poolSize = 8192;
    function from(value, encodingOrOffset, length) {
      if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof value === "number") {
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      }
      var valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer2.from(valueOf, encodingOrOffset, length);
      }
      var b = fromObject(value);
      if (b) return b;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer2.from(
          value[Symbol.toPrimitive]("string"),
          encodingOrOffset,
          length
        );
      }
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    Buffer2.from = function(value, encodingOrOffset, length) {
      return from(value, encodingOrOffset, length);
    };
    Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer2, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer2.alloc = function(size, fill, encoding) {
      return alloc(size, fill, encoding);
    };
    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer2.allocUnsafe = function(size) {
      return allocUnsafe(size);
    };
    Buffer2.allocUnsafeSlow = function(size) {
      return allocUnsafe(size);
    };
    function fromString(string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer2.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      var length = byteLength(string, encoding) | 0;
      var buf = createBuffer(length);
      var actual = buf.write(string, encoding);
      if (actual !== length) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike(array) {
      var length = array.length < 0 ? 0 : checked(array.length) | 0;
      var buf = createBuffer(length);
      for (var i = 0; i < length; i += 1) {
        buf[i] = array[i] & 255;
      }
      return buf;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        var copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array, byteOffset, length) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      var buf;
      if (byteOffset === void 0 && length === void 0) {
        buf = new Uint8Array(array);
      } else if (length === void 0) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length);
      }
      Object.setPrototypeOf(buf, Buffer2.prototype);
      return buf;
    }
    function fromObject(obj) {
      if (Buffer2.isBuffer(obj)) {
        var len = checked(obj.length) | 0;
        var buf = createBuffer(len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length | 0;
    }
    function SlowBuffer(length) {
      if (+length != length) {
        length = 0;
      }
      return Buffer2.alloc(+length);
    }
    Buffer2.isBuffer = function isBuffer(b) {
      return b != null && b._isBuffer === true && b !== Buffer2.prototype;
    };
    Buffer2.compare = function compare(a, b) {
      if (isInstance(a, Uint8Array)) a = Buffer2.from(a, a.offset, a.byteLength);
      if (isInstance(b, Uint8Array)) b = Buffer2.from(b, b.offset, b.byteLength);
      if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      }
      if (a === b) return 0;
      var x = a.length;
      var y = b.length;
      for (var i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break;
        }
      }
      if (x < y) return -1;
      if (y < x) return 1;
      return 0;
    };
    Buffer2.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer2.concat = function concat2(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer2.alloc(0);
      }
      var i;
      if (length === void 0) {
        length = 0;
        for (i = 0; i < list.length; ++i) {
          length += list[i].length;
        }
      }
      var buffer = Buffer2.allocUnsafe(length);
      var pos = 0;
      for (i = 0; i < list.length; ++i) {
        var buf = list[i];
        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer.length) {
            Buffer2.from(buf).copy(buffer, pos);
          } else {
            Uint8Array.prototype.set.call(
              buffer,
              buf,
              pos
            );
          }
        } else if (!Buffer2.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer, pos);
        }
        pos += buf.length;
      }
      return buffer;
    };
    function byteLength(string, encoding) {
      if (Buffer2.isBuffer(string)) {
        return string.length;
      }
      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength;
      }
      if (typeof string !== "string") {
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
        );
      }
      var len = string.length;
      var mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0) return 0;
      var loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes(string).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      var loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding) encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.prototype._isBuffer = true;
    function swap(b, n, m) {
      var i = b[n];
      b[n] = b[m];
      b[m] = i;
    }
    Buffer2.prototype.swap16 = function swap16() {
      var len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (var i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }
      return this;
    };
    Buffer2.prototype.swap32 = function swap32() {
      var len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (var i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }
      return this;
    };
    Buffer2.prototype.swap64 = function swap64() {
      var len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (var i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }
      return this;
    };
    Buffer2.prototype.toString = function toString() {
      var length = this.length;
      if (length === 0) return "";
      if (arguments.length === 0) return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
    Buffer2.prototype.equals = function equals(b) {
      if (!Buffer2.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
      if (this === b) return true;
      return Buffer2.compare(this, b) === 0;
    };
    Buffer2.prototype.inspect = function inspect() {
      var str = "";
      var max = exports.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max) str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
    }
    Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer2.from(target, target.offset, target.byteLength);
      }
      if (!Buffer2.isBuffer(target)) {
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
        );
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target) return 0;
      var x = thisEnd - thisStart;
      var y = end - start;
      var len = Math.min(x, y);
      var thisCopy = this.slice(thisStart, thisEnd);
      var targetCopy = target.slice(start, end);
      for (var i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break;
        }
      }
      if (x < y) return -1;
      if (y < x) return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
      if (buffer.length === 0) return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer.length - 1;
      }
      if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
      if (byteOffset >= buffer.length) {
        if (dir) return -1;
        else byteOffset = buffer.length - 1;
      } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1;
      }
      if (typeof val === "string") {
        val = Buffer2.from(val, encoding);
      }
      if (Buffer2.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      var indexSize = 1;
      var arrLength = arr.length;
      var valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read(buf, i2) {
        if (indexSize === 1) {
          return buf[i2];
        } else {
          return buf.readUInt16BE(i2 * indexSize);
        }
      }
      var i;
      if (dir) {
        var foundIndex = -1;
        for (i = byteOffset; i < arrLength; i++) {
          if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1) foundIndex = i;
            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1) i -= i - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for (i = byteOffset; i >= 0; i--) {
          var found = true;
          for (var j = 0; j < valLength; j++) {
            if (read(arr, i + j) !== read(val, j)) {
              found = false;
              break;
            }
          }
          if (found) return i;
        }
      }
      return -1;
    }
    Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf, string, offset, length) {
      offset = Number(offset) || 0;
      var remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }
      var strLen = string.length;
      if (length > strLen / 2) {
        length = strLen / 2;
      }
      for (var i = 0; i < length; ++i) {
        var parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed)) return i;
        buf[offset + i] = parsed;
      }
      return i;
    }
    function utf8Write(buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
    }
    function asciiWrite(buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length);
    }
    function base64Write(buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length);
    }
    function ucs2Write(buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
    }
    Buffer2.prototype.write = function write(string, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding === void 0) encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      var remaining = this.length - offset;
      if (length === void 0 || length > remaining) length = remaining;
      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding) encoding = "utf8";
      var loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset, length);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string, offset, length);
          case "base64":
            return base64Write(this, string, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset, length);
          default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer2.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
      } else {
        return base64.fromByteArray(buf.slice(start, end));
      }
    }
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      var res = [];
      var i = start;
      while (i < end) {
        var firstByte = buf[i];
        var codePoint = null;
        var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i + bytesPerSequence <= end) {
          var secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              fourthByte = buf[i + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    var MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      var len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      var res = "";
      var i = 0;
      while (i < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
        );
      }
      return res;
    }
    function asciiSlice(buf, start, end) {
      var ret = "";
      end = Math.min(buf.length, end);
      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i] & 127);
      }
      return ret;
    }
    function latin1Slice(buf, start, end) {
      var ret = "";
      end = Math.min(buf.length, end);
      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i]);
      }
      return ret;
    }
    function hexSlice(buf, start, end) {
      var len = buf.length;
      if (!start || start < 0) start = 0;
      if (!end || end < 0 || end > len) end = len;
      var out = "";
      for (var i = start; i < end; ++i) {
        out += hexSliceLookupTable[buf[i]];
      }
      return out;
    }
    function utf16leSlice(buf, start, end) {
      var bytes = buf.slice(start, end);
      var res = "";
      for (var i = 0; i < bytes.length - 1; i += 2) {
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
      }
      return res;
    }
    Buffer2.prototype.slice = function slice(start, end) {
      var len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0) start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0) end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start) end = start;
      var newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer2.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length) {
      if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
      if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      var val = this[offset + --byteLength2];
      var mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength2] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      mul *= 128;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      var i = byteLength2;
      var mul = 1;
      var val = this[offset + --i];
      while (i > 0 && (mul *= 256)) {
        val += this[offset + --i] * mul;
      }
      mul *= 128;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128)) return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      var val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      var val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, true, 23, 4);
    };
    Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, false, 23, 4);
    };
    Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, true, 52, 8);
    };
    Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, false, 52, 8);
    };
    function checkInt(buf, value, offset, ext, max, min) {
      if (!Buffer2.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length) throw new RangeError("Index out of range");
    }
    Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      var mul = 1;
      var i = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      var i = byteLength2 - 1;
      var mul = 1;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
      return offset + 4;
    };
    Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      var i = 0;
      var mul = 1;
      var sub = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      var i = byteLength2 - 1;
      var mul = 1;
      var sub = 0;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
      if (value < 0) value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    };
    Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0) value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    function checkIEEE754(buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length) throw new RangeError("Index out of range");
      if (offset < 0) throw new RangeError("Index out of range");
    }
    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
      }
      ieee754.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
      }
      ieee754.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
      if (!Buffer2.isBuffer(target)) throw new TypeError("argument should be a Buffer");
      if (!start) start = 0;
      if (!end && end !== 0) end = this.length;
      if (targetStart >= target.length) targetStart = target.length;
      if (!targetStart) targetStart = 0;
      if (end > 0 && end < start) end = start;
      if (end === start) return 0;
      if (target.length === 0 || this.length === 0) return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
      if (end < 0) throw new RangeError("sourceEnd out of bounds");
      if (end > this.length) end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      var len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, end),
          targetStart
        );
      }
      return len;
    };
    Buffer2.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          var code = val.charCodeAt(0);
          if (encoding === "utf8" && code < 128 || encoding === "latin1") {
            val = code;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val) val = 0;
      var i;
      if (typeof val === "number") {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        var bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
        var len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }
      return this;
    };
    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2) return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes(string, units) {
      units = units || Infinity;
      var codePoint;
      var length = string.length;
      var leadSurrogate = null;
      var bytes = [];
      for (var i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              continue;
            } else if (i + 1 === length) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1) bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0) break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0) break;
          bytes.push(
            codePoint >> 6 | 192,
            codePoint & 63 | 128
          );
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0) break;
          bytes.push(
            codePoint >> 12 | 224,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0) break;
          bytes.push(
            codePoint >> 18 | 240,
            codePoint >> 12 & 63 | 128,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str) {
      var byteArray = [];
      for (var i = 0; i < str.length; ++i) {
        byteArray.push(str.charCodeAt(i) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      var c, hi, lo;
      var byteArray = [];
      for (var i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0) break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base64.toByteArray(base64clean(str));
    }
    function blitBuffer(src, dst, offset, length) {
      for (var i = 0; i < length; ++i) {
        if (i + offset >= dst.length || i >= src.length) break;
        dst[i + offset] = src[i];
      }
      return i;
    }
    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    var hexSliceLookupTable = function() {
      var alphabet = "0123456789abcdef";
      var table = new Array(256);
      for (var i = 0; i < 16; ++i) {
        var i16 = i * 16;
        for (var j = 0; j < 16; ++j) {
          table[i16 + j] = alphabet[i] + alphabet[j];
        }
      }
      return table;
    }();
  }
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "node_modules/safe-buffer/index.js"(exports, module) {
    var buffer = require_buffer();
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module.exports = buffer;
    } else {
      copyProps(buffer, exports);
      exports.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer2.prototype);
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// node_modules/randombytes/browser.js
var require_browser3 = __commonJS({
  "node_modules/randombytes/browser.js"(exports, module) {
    "use strict";
    var MAX_BYTES = 65536;
    var MAX_UINT32 = 4294967295;
    function oldBrowser() {
      throw new Error("Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11");
    }
    var Buffer2 = require_safe_buffer().Buffer;
    var crypto3 = global.crypto || global.msCrypto;
    if (crypto3 && crypto3.getRandomValues) {
      module.exports = randomBytes2;
    } else {
      module.exports = oldBrowser;
    }
    function randomBytes2(size, cb) {
      if (size > MAX_UINT32) throw new RangeError("requested too many random bytes");
      var bytes = Buffer2.allocUnsafe(size);
      if (size > 0) {
        if (size > MAX_BYTES) {
          for (var generated = 0; generated < size; generated += MAX_BYTES) {
            crypto3.getRandomValues(bytes.slice(generated, generated + MAX_BYTES));
          }
        } else {
          crypto3.getRandomValues(bytes);
        }
      }
      if (typeof cb === "function") {
        return process.nextTick(function() {
          cb(null, bytes);
        });
      }
      return bytes;
    }
  }
});

// node_modules/k-bucket/index.js
var require_k_bucket = __commonJS({
  "node_modules/k-bucket/index.js"(exports, module) {
    "use strict";
    var randomBytes2 = require_browser3();
    var { EventEmitter: EventEmitter11 } = require_events();
    function arrayEquals(array1, array2) {
      if (array1 === array2) {
        return true;
      }
      if (array1.length !== array2.length) {
        return false;
      }
      for (let i = 0, length = array1.length; i < length; ++i) {
        if (array1[i] !== array2[i]) {
          return false;
        }
      }
      return true;
    }
    function createNode() {
      return { contacts: [], dontSplit: false, left: null, right: null };
    }
    function ensureInt8(name, val) {
      if (!(val instanceof Uint8Array)) {
        throw new TypeError(name + " is not a Uint8Array");
      }
    }
    var KBucket2 = class _KBucket extends EventEmitter11 {
      /**
       * `options`:
       *   `distance`: _Function_
       *     `function (firstId, secondId) { return distance }` An optional
       *     `distance` function that gets two `id` Uint8Arrays
       *     and return distance (as number) between them.
       *   `arbiter`: _Function_ _(Default: vectorClock arbiter)_
       *     `function (incumbent, candidate) { return contact; }` An optional
       *     `arbiter` function that givent two `contact` objects with the same `id`
       *     returns the desired object to be used for updating the k-bucket. For
       *     more details, see [arbiter function](#arbiter-function).
       *   `localNodeId`: _Uint8Array_ An optional Uint8Array representing the local node id.
       *     If not provided, a local node id will be created via `randomBytes(20)`.
       *     `metadata`: _Object_ _(Default: {})_ Optional satellite data to include
       *     with the k-bucket. `metadata` property is guaranteed not be altered by,
       *     it is provided as an explicit container for users of k-bucket to store
       *     implementation-specific data.
       *   `numberOfNodesPerKBucket`: _Integer_ _(Default: 20)_ The number of nodes
       *     that a k-bucket can contain before being full or split.
       *     `numberOfNodesToPing`: _Integer_ _(Default: 3)_ The number of nodes to
       *     ping when a bucket that should not be split becomes full. KBucket will
       *     emit a `ping` event that contains `numberOfNodesToPing` nodes that have
       *     not been contacted the longest.
       *
       * @param {Object=} options optional
       */
      constructor(options = {}) {
        super();
        this.localNodeId = options.localNodeId || randomBytes2(20);
        this.numberOfNodesPerKBucket = options.numberOfNodesPerKBucket || 20;
        this.numberOfNodesToPing = options.numberOfNodesToPing || 3;
        this.distance = options.distance || _KBucket.distance;
        this.arbiter = options.arbiter || _KBucket.arbiter;
        this.metadata = Object.assign({}, options.metadata);
        ensureInt8("option.localNodeId as parameter 1", this.localNodeId);
        this.root = createNode();
      }
      /**
       * Default arbiter function for contacts with the same id. Uses
       * contact.vectorClock to select which contact to update the k-bucket with.
       * Contact with larger vectorClock field will be selected. If vectorClock is
       * the same, candidat will be selected.
       *
       * @param  {Object} incumbent Contact currently stored in the k-bucket.
       * @param  {Object} candidate Contact being added to the k-bucket.
       * @return {Object}           Contact to updated the k-bucket with.
       */
      static arbiter(incumbent, candidate) {
        return incumbent.vectorClock > candidate.vectorClock ? incumbent : candidate;
      }
      /**
       * Default distance function. Finds the XOR
       * distance between firstId and secondId.
       *
       * @param  {Uint8Array} firstId  Uint8Array containing first id.
       * @param  {Uint8Array} secondId Uint8Array containing second id.
       * @return {Number}              Integer The XOR distance between firstId
       *                               and secondId.
       */
      static distance(firstId, secondId) {
        let distance = 0;
        let i = 0;
        const min = Math.min(firstId.length, secondId.length);
        const max = Math.max(firstId.length, secondId.length);
        for (; i < min; ++i) {
          distance = distance * 256 + (firstId[i] ^ secondId[i]);
        }
        for (; i < max; ++i) distance = distance * 256 + 255;
        return distance;
      }
      /**
       * Adds a contact to the k-bucket.
       *
       * @param {Object} contact the contact object to add
       */
      add(contact) {
        ensureInt8("contact.id", (contact || {}).id);
        let bitIndex = 0;
        let node = this.root;
        while (node.contacts === null) {
          node = this._determineNode(node, contact.id, bitIndex++);
        }
        const index = this._indexOf(node, contact.id);
        if (index >= 0) {
          this._update(node, index, contact);
          return this;
        }
        if (node.contacts.length < this.numberOfNodesPerKBucket) {
          node.contacts.push(contact);
          this.emit("added", contact);
          return this;
        }
        if (node.dontSplit) {
          this.emit("ping", node.contacts.slice(0, this.numberOfNodesToPing), contact);
          return this;
        }
        this._split(node, bitIndex);
        return this.add(contact);
      }
      /**
       * Get the n closest contacts to the provided node id. "Closest" here means:
       * closest according to the XOR metric of the contact node id.
       *
       * @param  {Uint8Array} id  Contact node id
       * @param  {Number=} n      Integer (Default: Infinity) The maximum number of
       *                          closest contacts to return
       * @return {Array}          Array Maximum of n closest contacts to the node id
       */
      closest(id, n = Infinity) {
        ensureInt8("id", id);
        if (!Number.isInteger(n) && n !== Infinity || n <= 0) {
          throw new TypeError("n is not positive number");
        }
        let contacts = [];
        for (let nodes = [this.root], bitIndex = 0; nodes.length > 0 && contacts.length < n; ) {
          const node = nodes.pop();
          if (node.contacts === null) {
            const detNode = this._determineNode(node, id, bitIndex++);
            nodes.push(node.left === detNode ? node.right : node.left);
            nodes.push(detNode);
          } else {
            contacts = contacts.concat(node.contacts);
          }
        }
        return contacts.map((a) => [this.distance(a.id, id), a]).sort((a, b) => a[0] - b[0]).slice(0, n).map((a) => a[1]);
      }
      /**
       * Counts the total number of contacts in the tree.
       *
       * @return {Number} The number of contacts held in the tree
       */
      count() {
        let count = 0;
        for (const nodes = [this.root]; nodes.length > 0; ) {
          const node = nodes.pop();
          if (node.contacts === null) nodes.push(node.right, node.left);
          else count += node.contacts.length;
        }
        return count;
      }
      /**
       * Determines whether the id at the bitIndex is 0 or 1.
       * Return left leaf if `id` at `bitIndex` is 0, right leaf otherwise
       *
       * @param  {Object} node     internal object that has 2 leafs: left and right
       * @param  {Uint8Array} id   Id to compare localNodeId with.
       * @param  {Number} bitIndex Integer (Default: 0) The bit index to which bit
       *                           to check in the id Uint8Array.
       * @return {Object}          left leaf if id at bitIndex is 0, right leaf otherwise.
       */
      _determineNode(node, id, bitIndex) {
        const bytesDescribedByBitIndex = bitIndex >> 3;
        const bitIndexWithinByte = bitIndex % 8;
        if (id.length <= bytesDescribedByBitIndex && bitIndexWithinByte !== 0) {
          return node.left;
        }
        const byteUnderConsideration = id[bytesDescribedByBitIndex];
        if (byteUnderConsideration & 1 << 7 - bitIndexWithinByte) {
          return node.right;
        }
        return node.left;
      }
      /**
       * Get a contact by its exact ID.
       * If this is a leaf, loop through the bucket contents and return the correct
       * contact if we have it or null if not. If this is an inner node, determine
       * which branch of the tree to traverse and repeat.
       *
       * @param  {Uint8Array} id The ID of the contact to fetch.
       * @return {Object|Null}   The contact if available, otherwise null
       */
      get(id) {
        ensureInt8("id", id);
        let bitIndex = 0;
        let node = this.root;
        while (node.contacts === null) {
          node = this._determineNode(node, id, bitIndex++);
        }
        const index = this._indexOf(node, id);
        return index >= 0 ? node.contacts[index] : null;
      }
      /**
       * Returns the index of the contact with provided
       * id if it exists, returns -1 otherwise.
       *
       * @param  {Object} node    internal object that has 2 leafs: left and right
       * @param  {Uint8Array} id  Contact node id.
       * @return {Number}         Integer Index of contact with provided id if it
       *                          exists, -1 otherwise.
       */
      _indexOf(node, id) {
        for (let i = 0; i < node.contacts.length; ++i) {
          if (arrayEquals(node.contacts[i].id, id)) return i;
        }
        return -1;
      }
      /**
       * Removes contact with the provided id.
       *
       * @param  {Uint8Array} id The ID of the contact to remove.
       * @return {Object}        The k-bucket itself.
       */
      remove(id) {
        ensureInt8("the id as parameter 1", id);
        let bitIndex = 0;
        let node = this.root;
        while (node.contacts === null) {
          node = this._determineNode(node, id, bitIndex++);
        }
        const index = this._indexOf(node, id);
        if (index >= 0) {
          const contact = node.contacts.splice(index, 1)[0];
          this.emit("removed", contact);
        }
        return this;
      }
      /**
       * Splits the node, redistributes contacts to the new nodes, and marks the
       * node that was split as an inner node of the binary tree of nodes by
       * setting this.root.contacts = null
       *
       * @param  {Object} node     node for splitting
       * @param  {Number} bitIndex the bitIndex to which byte to check in the
       *                           Uint8Array for navigating the binary tree
       */
      _split(node, bitIndex) {
        node.left = createNode();
        node.right = createNode();
        for (const contact of node.contacts) {
          this._determineNode(node, contact.id, bitIndex).contacts.push(contact);
        }
        node.contacts = null;
        const detNode = this._determineNode(node, this.localNodeId, bitIndex);
        const otherNode = node.left === detNode ? node.right : node.left;
        otherNode.dontSplit = true;
      }
      /**
       * Returns all the contacts contained in the tree as an array.
       * If this is a leaf, return a copy of the bucket. If this is not a leaf,
       * return the union of the low and high branches (themselves also as arrays).
       *
       * @return {Array} All of the contacts in the tree, as an array
       */
      toArray() {
        let result = [];
        for (const nodes = [this.root]; nodes.length > 0; ) {
          const node = nodes.pop();
          if (node.contacts === null) nodes.push(node.right, node.left);
          else result = result.concat(node.contacts);
        }
        return result;
      }
      /**
       * Similar to `toArray()` but instead of buffering everything up into an
       * array before returning it, yields contacts as they are encountered while
       * walking the tree.
       *
       * @return {Iterable} All of the contacts in the tree, as an iterable
       */
      *toIterable() {
        for (const nodes = [this.root]; nodes.length > 0; ) {
          const node = nodes.pop();
          if (node.contacts === null) {
            nodes.push(node.right, node.left);
          } else {
            yield* node.contacts;
          }
        }
      }
      /**
       * Updates the contact selected by the arbiter.
       * If the selection is our old contact and the candidate is some new contact
       * then the new contact is abandoned (not added).
       * If the selection is our old contact and the candidate is our old contact
       * then we are refreshing the contact and it is marked as most recently
       * contacted (by being moved to the right/end of the bucket array).
       * If the selection is our new contact, the old contact is removed and the new
       * contact is marked as most recently contacted.
       *
       * @param  {Object} node    internal object that has 2 leafs: left and right
       * @param  {Number} index   the index in the bucket where contact exists
       *                          (index has already been computed in a previous
       *                          calculation)
       * @param  {Object} contact The contact object to update.
       */
      _update(node, index, contact) {
        if (!arrayEquals(node.contacts[index].id, contact.id)) {
          throw new Error("wrong index for _update");
        }
        const incumbent = node.contacts[index];
        const selection = this.arbiter(incumbent, contact);
        if (selection === incumbent && incumbent !== contact) return;
        node.contacts.splice(index, 1);
        node.contacts.push(selection);
        this.emit("updated", incumbent, selection);
      }
    };
    module.exports = KBucket2;
  }
});

// browser-external:dgram
var require_dgram = __commonJS({
  "browser-external:dgram"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "dgram" has been externalized for browser compatibility. Cannot access "dgram.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/k-rpc-socket/node_modules/bencode/lib/util.js
var require_util = __commonJS({
  "node_modules/k-rpc-socket/node_modules/bencode/lib/util.js"(exports, module) {
    var util = module.exports;
    util.digitCount = function digitCount(value) {
      const sign = value < 0 ? 1 : 0;
      value = Math.abs(Number(value || 1));
      return Math.floor(Math.log10(value)) + 1 + sign;
    };
    util.getType = function getType(value) {
      if (Buffer.isBuffer(value)) return "buffer";
      if (ArrayBuffer.isView(value)) return "arraybufferview";
      if (Array.isArray(value)) return "array";
      if (value instanceof Number) return "number";
      if (value instanceof Boolean) return "boolean";
      if (value instanceof Set) return "set";
      if (value instanceof Map) return "map";
      if (value instanceof String) return "string";
      if (value instanceof ArrayBuffer) return "arraybuffer";
      return typeof value;
    };
  }
});

// node_modules/k-rpc-socket/node_modules/bencode/lib/encode.js
var require_encode = __commonJS({
  "node_modules/k-rpc-socket/node_modules/bencode/lib/encode.js"(exports, module) {
    var { getType } = require_util();
    function encode(data, buffer, offset) {
      const buffers = [];
      let result = null;
      encode._encode(buffers, data);
      result = Buffer.concat(buffers);
      encode.bytes = result.length;
      if (Buffer.isBuffer(buffer)) {
        result.copy(buffer, offset);
        return buffer;
      }
      return result;
    }
    encode.bytes = -1;
    encode._floatConversionDetected = false;
    encode._encode = function(buffers, data) {
      if (data == null) {
        return;
      }
      switch (getType(data)) {
        case "buffer":
          encode.buffer(buffers, data);
          break;
        case "object":
          encode.dict(buffers, data);
          break;
        case "map":
          encode.dictMap(buffers, data);
          break;
        case "array":
          encode.list(buffers, data);
          break;
        case "set":
          encode.listSet(buffers, data);
          break;
        case "string":
          encode.string(buffers, data);
          break;
        case "number":
          encode.number(buffers, data);
          break;
        case "boolean":
          encode.number(buffers, data);
          break;
        case "arraybufferview":
          encode.buffer(buffers, Buffer.from(data.buffer, data.byteOffset, data.byteLength));
          break;
        case "arraybuffer":
          encode.buffer(buffers, Buffer.from(data));
          break;
      }
    };
    var buffE = Buffer.from("e");
    var buffD = Buffer.from("d");
    var buffL = Buffer.from("l");
    encode.buffer = function(buffers, data) {
      buffers.push(Buffer.from(data.length + ":"), data);
    };
    encode.string = function(buffers, data) {
      buffers.push(Buffer.from(Buffer.byteLength(data) + ":" + data));
    };
    encode.number = function(buffers, data) {
      const maxLo = 2147483648;
      const hi = data / maxLo << 0;
      const lo = data % maxLo << 0;
      const val = hi * maxLo + lo;
      buffers.push(Buffer.from("i" + val + "e"));
      if (val !== data && !encode._floatConversionDetected) {
        encode._floatConversionDetected = true;
        console.warn(
          'WARNING: Possible data corruption detected with value "' + data + '":',
          'Bencoding only defines support for integers, value was converted to "' + val + '"'
        );
        console.trace();
      }
    };
    encode.dict = function(buffers, data) {
      buffers.push(buffD);
      let j = 0;
      let k;
      const keys = Object.keys(data).sort();
      const kl = keys.length;
      for (; j < kl; j++) {
        k = keys[j];
        if (data[k] == null) continue;
        encode.string(buffers, k);
        encode._encode(buffers, data[k]);
      }
      buffers.push(buffE);
    };
    encode.dictMap = function(buffers, data) {
      buffers.push(buffD);
      const keys = Array.from(data.keys()).sort();
      for (const key of keys) {
        if (data.get(key) == null) continue;
        Buffer.isBuffer(key) ? encode._encode(buffers, key) : encode.string(buffers, String(key));
        encode._encode(buffers, data.get(key));
      }
      buffers.push(buffE);
    };
    encode.list = function(buffers, data) {
      let i = 0;
      const c = data.length;
      buffers.push(buffL);
      for (; i < c; i++) {
        if (data[i] == null) continue;
        encode._encode(buffers, data[i]);
      }
      buffers.push(buffE);
    };
    encode.listSet = function(buffers, data) {
      buffers.push(buffL);
      for (const item of data) {
        if (item == null) continue;
        encode._encode(buffers, item);
      }
      buffers.push(buffE);
    };
    module.exports = encode;
  }
});

// node_modules/k-rpc-socket/node_modules/bencode/lib/decode.js
var require_decode = __commonJS({
  "node_modules/k-rpc-socket/node_modules/bencode/lib/decode.js"(exports, module) {
    var INTEGER_START = 105;
    var STRING_DELIM = 58;
    var DICTIONARY_START = 100;
    var LIST_START = 108;
    var END_OF_TYPE = 101;
    function getIntFromBuffer(buffer, start, end) {
      let sum = 0;
      let sign = 1;
      for (let i = start; i < end; i++) {
        const num = buffer[i];
        if (num < 58 && num >= 48) {
          sum = sum * 10 + (num - 48);
          continue;
        }
        if (i === start && num === 43) {
          continue;
        }
        if (i === start && num === 45) {
          sign = -1;
          continue;
        }
        if (num === 46) {
          break;
        }
        throw new Error("not a number: buffer[" + i + "] = " + num);
      }
      return sum * sign;
    }
    function decode2(data, start, end, encoding) {
      if (data == null || data.length === 0) {
        return null;
      }
      if (typeof start !== "number" && encoding == null) {
        encoding = start;
        start = void 0;
      }
      if (typeof end !== "number" && encoding == null) {
        encoding = end;
        end = void 0;
      }
      decode2.position = 0;
      decode2.encoding = encoding || null;
      decode2.data = !Buffer.isBuffer(data) ? Buffer.from(data) : data.slice(start, end);
      decode2.bytes = decode2.data.length;
      return decode2.next();
    }
    decode2.bytes = 0;
    decode2.position = 0;
    decode2.data = null;
    decode2.encoding = null;
    decode2.next = function() {
      switch (decode2.data[decode2.position]) {
        case DICTIONARY_START:
          return decode2.dictionary();
        case LIST_START:
          return decode2.list();
        case INTEGER_START:
          return decode2.integer();
        default:
          return decode2.buffer();
      }
    };
    decode2.find = function(chr) {
      let i = decode2.position;
      const c = decode2.data.length;
      const d = decode2.data;
      while (i < c) {
        if (d[i] === chr) return i;
        i++;
      }
      throw new Error(
        'Invalid data: Missing delimiter "' + String.fromCharCode(chr) + '" [0x' + chr.toString(16) + "]"
      );
    };
    decode2.dictionary = function() {
      decode2.position++;
      const dict = {};
      while (decode2.data[decode2.position] !== END_OF_TYPE) {
        dict[decode2.buffer()] = decode2.next();
      }
      decode2.position++;
      return dict;
    };
    decode2.list = function() {
      decode2.position++;
      const lst = [];
      while (decode2.data[decode2.position] !== END_OF_TYPE) {
        lst.push(decode2.next());
      }
      decode2.position++;
      return lst;
    };
    decode2.integer = function() {
      const end = decode2.find(END_OF_TYPE);
      const number = getIntFromBuffer(decode2.data, decode2.position + 1, end);
      decode2.position += end + 1 - decode2.position;
      return number;
    };
    decode2.buffer = function() {
      let sep = decode2.find(STRING_DELIM);
      const length = getIntFromBuffer(decode2.data, decode2.position, sep);
      const end = ++sep + length;
      decode2.position = end;
      return decode2.encoding ? decode2.data.toString(decode2.encoding, sep, end) : decode2.data.slice(sep, end);
    };
    module.exports = decode2;
  }
});

// node_modules/k-rpc-socket/node_modules/bencode/lib/encoding-length.js
var require_encoding_length = __commonJS({
  "node_modules/k-rpc-socket/node_modules/bencode/lib/encoding-length.js"(exports, module) {
    var { digitCount, getType } = require_util();
    function listLength(list) {
      let length = 1 + 1;
      for (const value of list) {
        length += encodingLength(value);
      }
      return length;
    }
    function mapLength(map) {
      let length = 1 + 1;
      for (const [key, value] of map) {
        const keyLength = Buffer.byteLength(key);
        length += digitCount(keyLength) + 1 + keyLength;
        length += encodingLength(value);
      }
      return length;
    }
    function objectLength(value) {
      let length = 1 + 1;
      const keys = Object.keys(value);
      for (let i = 0; i < keys.length; i++) {
        const keyLength = Buffer.byteLength(keys[i]);
        length += digitCount(keyLength) + 1 + keyLength;
        length += encodingLength(value[keys[i]]);
      }
      return length;
    }
    function stringLength(value) {
      const length = Buffer.byteLength(value);
      return digitCount(length) + 1 + length;
    }
    function arrayBufferLength(value) {
      const length = value.byteLength - value.byteOffset;
      return digitCount(length) + 1 + length;
    }
    function encodingLength(value) {
      const length = 0;
      if (value == null) return length;
      const type = getType(value);
      switch (type) {
        case "buffer":
          return digitCount(value.length) + 1 + value.length;
        case "arraybufferview":
          return arrayBufferLength(value);
        case "string":
          return stringLength(value);
        case "array":
        case "set":
          return listLength(value);
        case "number":
          return 1 + digitCount(Math.floor(value)) + 1;
        case "bigint":
          return 1 + value.toString().length + 1;
        case "object":
          return objectLength(value);
        case "map":
          return mapLength(value);
        default:
          throw new TypeError(`Unsupported value of type "${type}"`);
      }
    }
    module.exports = encodingLength;
  }
});

// node_modules/k-rpc-socket/node_modules/bencode/lib/index.js
var require_lib = __commonJS({
  "node_modules/k-rpc-socket/node_modules/bencode/lib/index.js"(exports, module) {
    var bencode = module.exports;
    bencode.encode = require_encode();
    bencode.decode = require_decode();
    bencode.byteLength = bencode.encodingLength = require_encoding_length();
  }
});

// browser-external:dns
var require_dns = __commonJS({
  "browser-external:dns"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "dns" has been externalized for browser compatibility. Cannot access "dns.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:util
var require_util2 = __commonJS({
  "browser-external:util"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "util" has been externalized for browser compatibility. Cannot access "util.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/k-rpc-socket/index.js
var require_k_rpc_socket = __commonJS({
  "node_modules/k-rpc-socket/index.js"(exports, module) {
    var dgram = require_dgram();
    var bencode = require_lib();
    var isIP = require_net().isIP;
    var dns = require_dns();
    var util = require_util2();
    var events = require_events();
    var ETIMEDOUT = new Error("Query timed out");
    ETIMEDOUT.code = "ETIMEDOUT";
    var EUNEXPECTEDNODE = new Error("Unexpected node id");
    EUNEXPECTEDNODE.code = "EUNEXPECTEDNODE";
    module.exports = RPC;
    function RPC(opts) {
      if (!(this instanceof RPC)) return new RPC(opts);
      if (!opts) opts = {};
      var self2 = this;
      this.timeout = opts.timeout || 2e3;
      this.inflight = 0;
      this.destroyed = false;
      this.isIP = opts.isIP || isIP;
      this.socket = opts.socket || dgram.createSocket("udp4");
      this.socket.on("message", onmessage2);
      this.socket.on("error", onerror);
      this.socket.on("listening", onlistening);
      this._tick = 0;
      this._ids = [];
      this._reqs = [];
      this._timer = setInterval(check, Math.floor(this.timeout / 4));
      events.EventEmitter.call(this);
      function check() {
        var missing = self2.inflight;
        if (!missing) return;
        for (var i = 0; i < self2._reqs.length; i++) {
          var req = self2._reqs[i];
          if (!req) continue;
          if (req.ttl) req.ttl--;
          else self2._cancel(i, ETIMEDOUT);
          if (!--missing) return;
        }
      }
      function onlistening() {
        self2.emit("listening");
      }
      function onerror(err2) {
        if (err2.code === "EACCES" || err2.code === "EADDRINUSE") self2.emit("error", err2);
        else self2.emit("warning", err2);
      }
      function onmessage2(buf, rinfo) {
        if (self2.destroyed) return;
        if (!rinfo.port) return;
        try {
          var message = bencode.decode(buf);
        } catch (e) {
          return self2.emit("warning", e);
        }
        var type = message && message.y && message.y.toString();
        if (type === "r" || type === "e") {
          if (!Buffer.isBuffer(message.t)) return;
          try {
            var tid = message.t.readUInt16BE(0);
          } catch (err3) {
            return self2.emit("warning", err3);
          }
          var index = self2._ids.indexOf(tid);
          if (index === -1 || tid === 0) {
            self2.emit("response", message, rinfo);
            self2.emit("warning", new Error("Unexpected transaction id: " + tid));
            return;
          }
          var req = self2._reqs[index];
          if (req.peer.host !== rinfo.address) {
            self2.emit("response", message, rinfo);
            self2.emit("warning", new Error("Out of order response"));
            return;
          }
          self2._ids[index] = 0;
          self2._reqs[index] = null;
          self2.inflight--;
          if (type === "e") {
            var isArray = Array.isArray(message.e);
            var err2 = new Error(isArray ? message.e.join(" ") : "Unknown error");
            err2.code = isArray && message.e.length && typeof message.e[0] === "number" ? message.e[0] : 0;
            req.callback(err2, message, rinfo, req.message);
            self2.emit("update");
            self2.emit("postupdate");
            return;
          }
          var rid = message.r && message.r.id;
          if (req.peer && req.peer.id && rid && !req.peer.id.equals(rid)) {
            req.callback(EUNEXPECTEDNODE, null, rinfo);
            self2.emit("update");
            self2.emit("postupdate");
            return;
          }
          req.callback(null, message, rinfo, req.message);
          self2.emit("update");
          self2.emit("postupdate");
          self2.emit("response", message, rinfo);
        } else if (type === "q") {
          self2.emit("query", message, rinfo);
        } else {
          self2.emit("warning", new Error("Unknown type: " + type));
        }
      }
    }
    util.inherits(RPC, events.EventEmitter);
    RPC.prototype.address = function() {
      return this.socket.address();
    };
    RPC.prototype.response = function(peer, req, res, cb) {
      this.send(peer, { t: req.t, y: "r", r: res }, cb);
    };
    RPC.prototype.error = function(peer, req, error, cb) {
      this.send(peer, { t: req.t, y: "e", e: [].concat(error.message || error) }, cb);
    };
    RPC.prototype.send = function(peer, message, cb) {
      var buf = bencode.encode(message);
      this.socket.send(buf, 0, buf.length, peer.port, peer.address || peer.host, cb || noop5);
    };
    RPC.prototype.bind = function() {
      this.socket.bind.apply(this.socket, arguments);
    };
    RPC.prototype.destroy = function(cb) {
      this.destroyed = true;
      clearInterval(this._timer);
      if (cb) this.socket.on("close", cb);
      for (var i = 0; i < this._ids.length; i++) this._cancel(i);
      this.socket.close();
    };
    RPC.prototype.query = function(peer, query, cb) {
      if (!cb) cb = noop5;
      if (!this.isIP(peer.host)) return this._resolveAndQuery(peer, query, cb);
      var message = {
        t: Buffer.allocUnsafe(2),
        y: "q",
        q: query.q,
        a: query.a
      };
      var req = {
        ttl: 4,
        peer,
        message,
        callback: cb
      };
      if (this._tick === 65535) this._tick = 0;
      var tid = ++this._tick;
      var free = this._ids.indexOf(0);
      if (free === -1) free = this._ids.push(0) - 1;
      this._ids[free] = tid;
      while (this._reqs.length < free) this._reqs.push(null);
      this._reqs[free] = req;
      this.inflight++;
      message.t.writeUInt16BE(tid, 0);
      this.send(peer, message);
      return tid;
    };
    RPC.prototype.cancel = function(tid, err2) {
      var index = this._ids.indexOf(tid);
      if (index > -1) this._cancel(index, err2);
    };
    RPC.prototype._cancel = function(index, err2) {
      var req = this._reqs[index];
      this._ids[index] = 0;
      this._reqs[index] = null;
      if (req) {
        this.inflight--;
        req.callback(err2 || new Error("Query was cancelled"), null, req.peer);
        this.emit("update");
        this.emit("postupdate");
      }
    };
    RPC.prototype._resolveAndQuery = function(peer, query, cb) {
      var self2 = this;
      dns.lookup(peer.host, function(err2, ip) {
        if (err2) return cb(err2);
        if (self2.destroyed) return cb(new Error("k-rpc-socket is destroyed"));
        self2.query({ host: ip, port: peer.port }, query, cb);
      });
    };
    function noop5() {
    }
  }
});

// node_modules/k-rpc/index.js
var require_k_rpc = __commonJS({
  "node_modules/k-rpc/index.js"(exports, module) {
    var socket = require_k_rpc_socket();
    var KBucket2 = require_k_bucket();
    var events = require_events();
    var randombytes2 = require_browser3();
    var util = require_util2();
    var K = 20;
    var MAX_CONCURRENCY = 16;
    var BOOTSTRAP_NODES = [
      { host: "router.bittorrent.com", port: 6881 },
      { host: "router.utorrent.com", port: 6881 },
      { host: "dht.transmissionbt.com", port: 6881 }
    ];
    module.exports = RPC;
    function RPC(opts) {
      if (!(this instanceof RPC)) return new RPC(opts);
      if (!opts) opts = {};
      var self2 = this;
      this._idLength = opts.idLength || 20;
      this.id = toBuffer2(opts.id || opts.nodeId || randombytes2(this._idLength));
      this.socket = opts.krpcSocket || socket(opts);
      this.bootstrap = toBootstrapArray(opts.nodes || opts.bootstrap);
      this.concurrency = opts.concurrency || MAX_CONCURRENCY;
      this.backgroundConcurrency = opts.backgroundConcurrency || this.concurrency / 4 | 0;
      this.k = opts.k || K;
      this.destroyed = false;
      this.pending = [];
      this.nodes = null;
      this.socket.setMaxListeners(0);
      this.socket.on("query", onquery);
      this.socket.on("response", onresponse);
      this.socket.on("warning", onwarning);
      this.socket.on("error", onerror);
      this.socket.on("update", onupdate);
      this.socket.on("listening", onlistening);
      events.EventEmitter.call(this);
      this.clear();
      function onupdate() {
        while (self2.pending.length && self2.socket.inflight < self2.concurrency) {
          var next = self2.pending.shift();
          self2.query(next[0], next[1], next[2]);
        }
      }
      function onerror(err2) {
        self2.emit("error", err2);
      }
      function onlistening() {
        self2.emit("listening");
      }
      function onwarning(err2) {
        self2.emit("warning", err2);
      }
      function onquery(query, peer) {
        addNode(query.a, peer);
        self2.emit("query", query, peer);
      }
      function onresponse(reply, peer) {
        addNode(reply.r, peer);
      }
      function addNode(data, peer) {
        if (data && isNodeId(data.id, self2._idLength) && !data.id.equals(self2.id)) {
          var old = self2.nodes.get(data.id);
          if (old) {
            old.seen = Date.now();
            return;
          }
          self2._addNode({
            id: data.id,
            host: peer.address || peer.host,
            port: peer.port,
            distance: 0,
            seen: Date.now()
          });
        }
      }
    }
    util.inherits(RPC, events.EventEmitter);
    RPC.prototype.response = function(node, query, response, nodes, cb) {
      if (typeof nodes === "function") {
        cb = nodes;
        nodes = null;
      }
      if (!response.id) response.id = this.id;
      if (nodes) response.nodes = encodeNodes(nodes, this._idLength);
      this.socket.response(node, query, response, cb);
    };
    RPC.prototype.error = function(node, query, error, cb) {
      this.socket.error(node, query, error, cb);
    };
    RPC.prototype.bind = function() {
      this.socket.bind.apply(this.socket, arguments);
    };
    RPC.prototype.address = function() {
      return this.socket.address();
    };
    RPC.prototype.queryAll = function(nodes, message, visit, cb) {
      if (!message.a) message.a = {};
      if (!message.a.id) message.a.id = this.id;
      var stop = false;
      var missing = nodes.length;
      var hits = 0;
      var error = null;
      if (!missing) return cb(new Error("No nodes to query"), 0);
      for (var i = 0; i < nodes.length; i++) {
        this.query(nodes[i], message, done);
      }
      function done(err2, res, peer) {
        if (!err2) hits++;
        else if (err2.code >= 300 && err2.code < 400) error = err2;
        if (!err2 && !stop) {
          if (visit && visit(res, peer) === false) stop = true;
        }
        if (!--missing) cb(hits ? null : error || new Error("All queries failed"), hits);
      }
    };
    RPC.prototype.query = function(node, message, cb) {
      if (this.socket.inflight >= this.concurrency) {
        this.pending.push([node, message, cb]);
      } else {
        if (!message.a) message.a = {};
        if (!message.a.id) message.a.id = this.id;
        if (node.token) message.a.token = node.token;
        this.socket.query(node, message, cb);
      }
    };
    RPC.prototype.destroy = function(cb) {
      this.destroyed = true;
      this.socket.destroy(cb);
    };
    RPC.prototype.clear = function() {
      var self2 = this;
      this.nodes = new KBucket2({
        localNodeId: this.id,
        numberOfNodesPerKBucket: this.k,
        numberOfNodesToPing: this.concurrency
      });
      this.nodes.on("ping", onping);
      function onping(older, newer) {
        self2.emit("ping", older, function swap(deadNode) {
          if (!deadNode) return;
          if (deadNode.id) self2.nodes.remove(deadNode.id);
          self2._addNode(newer);
        });
      }
    };
    RPC.prototype.populate = function(target, message, cb) {
      this._closest(target, message, true, null, cb);
    };
    RPC.prototype.closest = function(target, message, visit, cb) {
      this._closest(target, message, false, visit, cb);
    };
    RPC.prototype._addNode = function(node) {
      var old = this.nodes.get(node.id);
      this.nodes.add(node);
      if (!old) this.emit("node", node);
    };
    RPC.prototype._closest = function(target, message, background, visit, cb) {
      if (!cb) cb = noop5;
      var self2 = this;
      var count = 0;
      var queried = {};
      var pending = 0;
      var once3 = true;
      var stop = false;
      if (!message.a) message.a = {};
      if (!message.a.id) message.a.id = this.id;
      var table = new KBucket2({
        localNodeId: target,
        numberOfNodesPerKBucket: this.k,
        numberOfNodesToPing: this.concurrency
      });
      var evt = background ? "postupdate" : "update";
      this.socket.on(evt, kick);
      kick();
      function kick() {
        if (self2.destroyed || self2.socket.inflight >= self2.concurrency) return;
        var otherInflight = self2.pending.length + self2.socket.inflight - pending;
        if (background && self2.socket.inflight >= self2.backgroundConcurrency && otherInflight) return;
        var closest = table.closest(target, self2.k);
        if (!closest.length || closest.length < self2.bootstrap.length) {
          closest = self2.nodes.closest(target, self2.k);
          if (!closest.length || closest.length < self2.bootstrap.length) bootstrap();
        }
        for (var i = 0; i < closest.length; i++) {
          if (stop) break;
          if (self2.socket.inflight >= self2.concurrency) return;
          var peer = closest[i];
          var id = peer.host + ":" + peer.port;
          if (queried[id]) continue;
          queried[id] = true;
          pending++;
          self2.socket.query(peer, message, afterQuery);
        }
        if (!pending) {
          self2.socket.removeListener(evt, kick);
          process.nextTick(done);
        }
      }
      function done() {
        cb(null, count);
      }
      function bootstrap() {
        if (!once3) return;
        once3 = false;
        self2.bootstrap.forEach(function(peer) {
          pending++;
          self2.socket.query(peer, message, afterQuery);
        });
      }
      function afterQuery(err2, res, peer) {
        pending--;
        if (peer) queried[(peer.address || peer.host) + ":" + peer.port] = true;
        if (peer && peer.id && self2.nodes.get(peer.id)) {
          if (err2 && (err2.code === "EUNEXPECTEDNODE" || err2.code === "ETIMEDOUT")) {
            self2.nodes.remove(peer.id);
          }
        }
        var r = res && res.r;
        if (!r) return kick();
        if (!err2 && isNodeId(r.id, self2._idLength)) {
          count++;
          add({
            id: r.id,
            port: peer.port,
            host: peer.host || peer.address,
            distance: 0
          });
        }
        var nodes = r.nodes ? parseNodes(r.nodes, self2._idLength) : [];
        for (var i = 0; i < nodes.length; i++) add(nodes[i]);
        if (visit && visit(res, peer) === false) stop = true;
        kick();
      }
      function add(node) {
        if (node.id.equals(self2.id)) return;
        table.add(node);
      }
    };
    function toBootstrapArray(val) {
      if (val === false) return [];
      if (val === true) return BOOTSTRAP_NODES;
      return [].concat(val || BOOTSTRAP_NODES).map(parsePeer);
    }
    function isNodeId(id, idLength) {
      return id && Buffer.isBuffer(id) && id.length === idLength;
    }
    function encodeNodes(nodes, idLength) {
      var buf = Buffer.allocUnsafe(nodes.length * (idLength + 6));
      var ptr = 0;
      for (var i = 0; i < nodes.length; i++) {
        var node = nodes[i];
        if (!isNodeId(node.id, idLength)) continue;
        node.id.copy(buf, ptr);
        ptr += idLength;
        var ip = (node.host || node.address).split(".");
        for (var j = 0; j < 4; j++) buf[ptr++] = parseInt(ip[j] || 0, 10);
        buf.writeUInt16BE(node.port, ptr);
        ptr += 2;
      }
      if (ptr === buf.length) return buf;
      return buf.slice(0, ptr);
    }
    function parseNodes(buf, idLength) {
      var contacts = [];
      try {
        for (var i = 0; i < buf.length; i += idLength + 6) {
          var port = buf.readUInt16BE(i + (idLength + 4));
          if (!port) continue;
          contacts.push({
            id: buf.slice(i, i + idLength),
            host: parseIp2(buf, i + idLength),
            port,
            distance: 0,
            token: null
          });
        }
      } catch (err2) {
      }
      return contacts;
    }
    function parseIp2(buf, offset) {
      return buf[offset++] + "." + buf[offset++] + "." + buf[offset++] + "." + buf[offset++];
    }
    function parsePeer(peer) {
      if (typeof peer === "string") return { host: peer.split(":")[0], port: Number(peer.split(":")[1]) };
      return peer;
    }
    function noop5() {
    }
    function toBuffer2(str) {
      if (Buffer.isBuffer(str)) return str;
      if (ArrayBuffer.isView(str)) return Buffer.from(str.buffer, str.byteOffset, str.byteLength);
      if (typeof str === "string") return Buffer.from(str, "hex");
      throw new Error("Pass a buffer or a string");
    }
  }
});

// node_modules/last-one-wins/index.js
var require_last_one_wins = __commonJS({
  "node_modules/last-one-wins/index.js"(exports, module) {
    module.exports = function(work) {
      var pending = null;
      var callback = null;
      var callbacks = null;
      var next = null;
      return function(val, cb) {
        next = val;
        update(cb || noop5);
      };
      function update(cb) {
        if (callback) {
          if (!pending) pending = [];
          pending.push(cb);
          return;
        }
        var val = next;
        next = null;
        callback = cb;
        work(val, done);
      }
      function done(err2) {
        var cb = callback;
        var cbs = callbacks;
        callbacks = null;
        callback = null;
        if (pending) {
          callbacks = pending;
          pending = null;
          update(noop5);
        }
        if (cbs) {
          for (var i = 0; i < cbs.length; i++) cbs[i](err2);
        }
        cb(err2);
      }
    };
    function noop5(_) {
    }
  }
});

// node_modules/b4a/lib/ascii.js
var require_ascii = __commonJS({
  "node_modules/b4a/lib/ascii.js"(exports, module) {
    function byteLength(string) {
      return string.length;
    }
    function toString(buffer) {
      const len = buffer.byteLength;
      let result = "";
      for (let i = 0; i < len; i++) {
        result += String.fromCharCode(buffer[i]);
      }
      return result;
    }
    function write(buffer, string, offset = 0, length = byteLength(string)) {
      const len = Math.min(length, buffer.byteLength - offset);
      for (let i = 0; i < len; i++) {
        buffer[offset + i] = string.charCodeAt(i);
      }
      return len;
    }
    module.exports = {
      byteLength,
      toString,
      write
    };
  }
});

// node_modules/b4a/lib/base64.js
var require_base64 = __commonJS({
  "node_modules/b4a/lib/base64.js"(exports, module) {
    var alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    var codes = new Uint8Array(256);
    for (let i = 0; i < alphabet.length; i++) {
      codes[alphabet.charCodeAt(i)] = i;
    }
    codes[
      /* - */
      45
    ] = 62;
    codes[
      /* _ */
      95
    ] = 63;
    function byteLength(string) {
      let len = string.length;
      if (string.charCodeAt(len - 1) === 61) len--;
      if (len > 1 && string.charCodeAt(len - 1) === 61) len--;
      return len * 3 >>> 2;
    }
    function toString(buffer) {
      const len = buffer.byteLength;
      let result = "";
      for (let i = 0; i < len; i += 3) {
        result += alphabet[buffer[i] >> 2] + alphabet[(buffer[i] & 3) << 4 | buffer[i + 1] >> 4] + alphabet[(buffer[i + 1] & 15) << 2 | buffer[i + 2] >> 6] + alphabet[buffer[i + 2] & 63];
      }
      if (len % 3 === 2) {
        result = result.substring(0, result.length - 1) + "=";
      } else if (len % 3 === 1) {
        result = result.substring(0, result.length - 2) + "==";
      }
      return result;
    }
    function write(buffer, string, offset = 0, length = byteLength(string)) {
      const len = Math.min(length, buffer.byteLength - offset);
      for (let i = 0, j = 0; j < len; i += 4) {
        const a = codes[string.charCodeAt(i)];
        const b = codes[string.charCodeAt(i + 1)];
        const c = codes[string.charCodeAt(i + 2)];
        const d = codes[string.charCodeAt(i + 3)];
        buffer[j++] = a << 2 | b >> 4;
        buffer[j++] = (b & 15) << 4 | c >> 2;
        buffer[j++] = (c & 3) << 6 | d & 63;
      }
      return len;
    }
    module.exports = {
      byteLength,
      toString,
      write
    };
  }
});

// node_modules/b4a/lib/hex.js
var require_hex = __commonJS({
  "node_modules/b4a/lib/hex.js"(exports, module) {
    function byteLength(string) {
      return string.length >>> 1;
    }
    function toString(buffer) {
      const len = buffer.byteLength;
      buffer = new DataView(buffer.buffer, buffer.byteOffset, len);
      let result = "";
      let i = 0;
      for (let n = len - len % 4; i < n; i += 4) {
        result += buffer.getUint32(i).toString(16).padStart(8, "0");
      }
      for (; i < len; i++) {
        result += buffer.getUint8(i).toString(16).padStart(2, "0");
      }
      return result;
    }
    function write(buffer, string, offset = 0, length = byteLength(string)) {
      const len = Math.min(length, buffer.byteLength - offset);
      for (let i = 0; i < len; i++) {
        const a = hexValue(string.charCodeAt(i * 2));
        const b = hexValue(string.charCodeAt(i * 2 + 1));
        if (a === void 0 || b === void 0) {
          return buffer.subarray(0, i);
        }
        buffer[offset + i] = a << 4 | b;
      }
      return len;
    }
    module.exports = {
      byteLength,
      toString,
      write
    };
    function hexValue(char) {
      if (char >= 48 && char <= 57) return char - 48;
      if (char >= 65 && char <= 70) return char - 65 + 10;
      if (char >= 97 && char <= 102) return char - 97 + 10;
    }
  }
});

// node_modules/b4a/lib/utf8.js
var require_utf8 = __commonJS({
  "node_modules/b4a/lib/utf8.js"(exports, module) {
    function byteLength(string) {
      let length = 0;
      for (let i = 0, n = string.length; i < n; i++) {
        const code = string.charCodeAt(i);
        if (code >= 55296 && code <= 56319 && i + 1 < n) {
          const code2 = string.charCodeAt(i + 1);
          if (code2 >= 56320 && code2 <= 57343) {
            length += 4;
            i++;
            continue;
          }
        }
        if (code <= 127) length += 1;
        else if (code <= 2047) length += 2;
        else length += 3;
      }
      return length;
    }
    var toString;
    if (typeof TextDecoder !== "undefined") {
      const decoder = new TextDecoder();
      toString = function toString2(buffer) {
        return decoder.decode(buffer);
      };
    } else {
      toString = function toString2(buffer) {
        const len = buffer.byteLength;
        let output = "";
        let i = 0;
        while (i < len) {
          let byte = buffer[i];
          if (byte <= 127) {
            output += String.fromCharCode(byte);
            i++;
            continue;
          }
          let bytesNeeded = 0;
          let codePoint = 0;
          if (byte <= 223) {
            bytesNeeded = 1;
            codePoint = byte & 31;
          } else if (byte <= 239) {
            bytesNeeded = 2;
            codePoint = byte & 15;
          } else if (byte <= 244) {
            bytesNeeded = 3;
            codePoint = byte & 7;
          }
          if (len - i - bytesNeeded > 0) {
            let k = 0;
            while (k < bytesNeeded) {
              byte = buffer[i + k + 1];
              codePoint = codePoint << 6 | byte & 63;
              k += 1;
            }
          } else {
            codePoint = 65533;
            bytesNeeded = len - i;
          }
          output += String.fromCodePoint(codePoint);
          i += bytesNeeded + 1;
        }
        return output;
      };
    }
    var write;
    if (typeof TextEncoder !== "undefined") {
      const encoder = new TextEncoder();
      write = function write2(buffer, string, offset = 0, length = byteLength(string)) {
        const len = Math.min(length, buffer.byteLength - offset);
        encoder.encodeInto(string, buffer.subarray(offset, offset + len));
        return len;
      };
    } else {
      write = function write2(buffer, string, offset = 0, length = byteLength(string)) {
        const len = Math.min(length, buffer.byteLength - offset);
        buffer = buffer.subarray(offset, offset + len);
        let i = 0;
        let j = 0;
        while (i < string.length) {
          const code = string.codePointAt(i);
          if (code <= 127) {
            buffer[j++] = code;
            i++;
            continue;
          }
          let count = 0;
          let bits = 0;
          if (code <= 2047) {
            count = 6;
            bits = 192;
          } else if (code <= 65535) {
            count = 12;
            bits = 224;
          } else if (code <= 2097151) {
            count = 18;
            bits = 240;
          }
          buffer[j++] = bits | code >> count;
          count -= 6;
          while (count >= 0) {
            buffer[j++] = 128 | code >> count & 63;
            count -= 6;
          }
          i += code >= 65536 ? 2 : 1;
        }
        return len;
      };
    }
    module.exports = {
      byteLength,
      toString,
      write
    };
  }
});

// node_modules/b4a/lib/utf16le.js
var require_utf16le = __commonJS({
  "node_modules/b4a/lib/utf16le.js"(exports, module) {
    function byteLength(string) {
      return string.length * 2;
    }
    function toString(buffer) {
      const len = buffer.byteLength;
      let result = "";
      for (let i = 0; i < len - 1; i += 2) {
        result += String.fromCharCode(buffer[i] + buffer[i + 1] * 256);
      }
      return result;
    }
    function write(buffer, string, offset = 0, length = byteLength(string)) {
      const len = Math.min(length, buffer.byteLength - offset);
      let units = len;
      for (let i = 0; i < string.length; ++i) {
        if ((units -= 2) < 0) break;
        const c = string.charCodeAt(i);
        const hi = c >> 8;
        const lo = c % 256;
        buffer[offset + i * 2] = lo;
        buffer[offset + i * 2 + 1] = hi;
      }
      return len;
    }
    module.exports = {
      byteLength,
      toString,
      write
    };
  }
});

// node_modules/b4a/browser.js
var require_browser4 = __commonJS({
  "node_modules/b4a/browser.js"(exports, module) {
    var ascii = require_ascii();
    var base64 = require_base64();
    var hex = require_hex();
    var utf8 = require_utf8();
    var utf16le = require_utf16le();
    var LE = new Uint8Array(Uint16Array.of(255).buffer)[0] === 255;
    function codecFor(encoding) {
      switch (encoding) {
        case "ascii":
          return ascii;
        case "base64":
          return base64;
        case "hex":
          return hex;
        case "utf8":
        case "utf-8":
        case void 0:
        case null:
          return utf8;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return utf16le;
        default:
          throw new Error(`Unknown encoding: ${encoding}`);
      }
    }
    function isBuffer(value) {
      return value instanceof Uint8Array;
    }
    function isEncoding(encoding) {
      try {
        codecFor(encoding);
        return true;
      } catch {
        return false;
      }
    }
    function alloc(size, fill2, encoding) {
      const buffer = new Uint8Array(size);
      if (fill2 !== void 0) exports.fill(buffer, fill2, 0, buffer.byteLength, encoding);
      return buffer;
    }
    function allocUnsafe(size) {
      return new Uint8Array(size);
    }
    function allocUnsafeSlow(size) {
      return new Uint8Array(size);
    }
    function byteLength(string, encoding) {
      return codecFor(encoding).byteLength(string);
    }
    function compare(a, b) {
      if (a === b) return 0;
      const len = Math.min(a.byteLength, b.byteLength);
      a = new DataView(a.buffer, a.byteOffset, a.byteLength);
      b = new DataView(b.buffer, b.byteOffset, b.byteLength);
      let i = 0;
      for (let n = len - len % 4; i < n; i += 4) {
        const x = a.getUint32(i, LE);
        const y = b.getUint32(i, LE);
        if (x !== y) break;
      }
      for (; i < len; i++) {
        const x = a.getUint8(i);
        const y = b.getUint8(i);
        if (x < y) return -1;
        if (x > y) return 1;
      }
      return a.byteLength > b.byteLength ? 1 : a.byteLength < b.byteLength ? -1 : 0;
    }
    function concat2(buffers, totalLength) {
      if (totalLength === void 0) {
        totalLength = buffers.reduce((len, buffer) => len + buffer.byteLength, 0);
      }
      const result = new Uint8Array(totalLength);
      let offset = 0;
      for (const buffer of buffers) {
        if (offset + buffer.byteLength > result.byteLength) {
          const sub = buffer.subarray(0, result.byteLength - offset);
          result.set(sub, offset);
          return result;
        }
        result.set(buffer, offset);
        offset += buffer.byteLength;
      }
      return result;
    }
    function copy(source, target, targetStart = 0, start = 0, end = source.byteLength) {
      if (end > 0 && end < start) return 0;
      if (end === start) return 0;
      if (source.byteLength === 0 || target.byteLength === 0) return 0;
      if (targetStart < 0) throw new RangeError("targetStart is out of range");
      if (start < 0 || start >= source.byteLength) throw new RangeError("sourceStart is out of range");
      if (end < 0) throw new RangeError("sourceEnd is out of range");
      if (targetStart >= target.byteLength) targetStart = target.byteLength;
      if (end > source.byteLength) end = source.byteLength;
      if (target.byteLength - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      const len = end - start;
      if (source === target) {
        target.copyWithin(targetStart, start, end);
      } else {
        target.set(source.subarray(start, end), targetStart);
      }
      return len;
    }
    function equals(a, b) {
      if (a === b) return true;
      if (a.byteLength !== b.byteLength) return false;
      const len = a.byteLength;
      a = new DataView(a.buffer, a.byteOffset, a.byteLength);
      b = new DataView(b.buffer, b.byteOffset, b.byteLength);
      let i = 0;
      for (let n = len - len % 4; i < n; i += 4) {
        if (a.getUint32(i, LE) !== b.getUint32(i, LE)) return false;
      }
      for (; i < len; i++) {
        if (a.getUint8(i) !== b.getUint8(i)) return false;
      }
      return true;
    }
    function fill(buffer, value, offset, end, encoding) {
      if (typeof value === "string") {
        if (typeof offset === "string") {
          encoding = offset;
          offset = 0;
          end = buffer.byteLength;
        } else if (typeof end === "string") {
          encoding = end;
          end = buffer.byteLength;
        }
      } else if (typeof value === "number") {
        value = value & 255;
      } else if (typeof value === "boolean") {
        value = +value;
      }
      if (offset < 0 || buffer.byteLength < offset || buffer.byteLength < end) {
        throw new RangeError("Out of range index");
      }
      if (offset === void 0) offset = 0;
      if (end === void 0) end = buffer.byteLength;
      if (end <= offset) return buffer;
      if (!value) value = 0;
      if (typeof value === "number") {
        for (let i = offset; i < end; ++i) {
          buffer[i] = value;
        }
      } else {
        value = isBuffer(value) ? value : from(value, encoding);
        const len = value.byteLength;
        for (let i = 0; i < end - offset; ++i) {
          buffer[i + offset] = value[i % len];
        }
      }
      return buffer;
    }
    function from(value, encodingOrOffset, length) {
      if (typeof value === "string") return fromString(value, encodingOrOffset);
      if (Array.isArray(value)) return fromArray(value);
      if (ArrayBuffer.isView(value)) return fromBuffer(value);
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    function fromString(string, encoding) {
      const codec = codecFor(encoding);
      const buffer = new Uint8Array(codec.byteLength(string));
      codec.write(buffer, string, 0, buffer.byteLength);
      return buffer;
    }
    function fromArray(array) {
      const buffer = new Uint8Array(array.length);
      buffer.set(array);
      return buffer;
    }
    function fromBuffer(buffer) {
      const copy2 = new Uint8Array(buffer.byteLength);
      copy2.set(buffer);
      return copy2;
    }
    function fromArrayBuffer(arrayBuffer, byteOffset, length) {
      return new Uint8Array(arrayBuffer, byteOffset, length);
    }
    function includes(buffer, value, byteOffset, encoding) {
      return indexOf(buffer, value, byteOffset, encoding) !== -1;
    }
    function bidirectionalIndexOf(buffer, value, byteOffset, encoding, first) {
      if (buffer.byteLength === 0) return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset === void 0) {
        byteOffset = first ? 0 : buffer.length - 1;
      } else if (byteOffset < 0) {
        byteOffset += buffer.byteLength;
      }
      if (byteOffset >= buffer.byteLength) {
        if (first) return -1;
        else byteOffset = buffer.byteLength - 1;
      } else if (byteOffset < 0) {
        if (first) byteOffset = 0;
        else return -1;
      }
      if (typeof value === "string") {
        value = from(value, encoding);
      } else if (typeof value === "number") {
        value = value & 255;
        if (first) {
          return buffer.indexOf(value, byteOffset);
        } else {
          return buffer.lastIndexOf(value, byteOffset);
        }
      }
      if (value.byteLength === 0) return -1;
      if (first) {
        let foundIndex = -1;
        for (let i = byteOffset; i < buffer.byteLength; i++) {
          if (buffer[i] === value[foundIndex === -1 ? 0 : i - foundIndex]) {
            if (foundIndex === -1) foundIndex = i;
            if (i - foundIndex + 1 === value.byteLength) return foundIndex;
          } else {
            if (foundIndex !== -1) i -= i - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + value.byteLength > buffer.byteLength) {
          byteOffset = buffer.byteLength - value.byteLength;
        }
        for (let i = byteOffset; i >= 0; i--) {
          let found = true;
          for (let j = 0; j < value.byteLength; j++) {
            if (buffer[i + j] !== value[j]) {
              found = false;
              break;
            }
          }
          if (found) return i;
        }
      }
      return -1;
    }
    function indexOf(buffer, value, byteOffset, encoding) {
      return bidirectionalIndexOf(
        buffer,
        value,
        byteOffset,
        encoding,
        true
        /* first */
      );
    }
    function lastIndexOf(buffer, value, byteOffset, encoding) {
      return bidirectionalIndexOf(
        buffer,
        value,
        byteOffset,
        encoding,
        false
        /* last */
      );
    }
    function swap(buffer, n, m) {
      const i = buffer[n];
      buffer[n] = buffer[m];
      buffer[m] = i;
    }
    function swap16(buffer) {
      const len = buffer.byteLength;
      if (len % 2 !== 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
      for (let i = 0; i < len; i += 2) swap(buffer, i, i + 1);
      return buffer;
    }
    function swap32(buffer) {
      const len = buffer.byteLength;
      if (len % 4 !== 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
      for (let i = 0; i < len; i += 4) {
        swap(buffer, i, i + 3);
        swap(buffer, i + 1, i + 2);
      }
      return buffer;
    }
    function swap64(buffer) {
      const len = buffer.byteLength;
      if (len % 8 !== 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
      for (let i = 0; i < len; i += 8) {
        swap(buffer, i, i + 7);
        swap(buffer, i + 1, i + 6);
        swap(buffer, i + 2, i + 5);
        swap(buffer, i + 3, i + 4);
      }
      return buffer;
    }
    function toBuffer2(buffer) {
      return buffer;
    }
    function toString(buffer, encoding, start = 0, end = buffer.byteLength) {
      const len = buffer.byteLength;
      if (start >= len) return "";
      if (end <= start) return "";
      if (start < 0) start = 0;
      if (end > len) end = len;
      if (start !== 0 || end < len) buffer = buffer.subarray(start, end);
      return codecFor(encoding).toString(buffer);
    }
    function write(buffer, string, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        offset = void 0;
      } else if (encoding === void 0 && typeof length === "string") {
        encoding = length;
        length = void 0;
      }
      return codecFor(encoding).write(buffer, string, offset, length);
    }
    function writeDoubleLE(buffer, value, offset) {
      if (offset === void 0) offset = 0;
      const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
      view.setFloat64(offset, value, true);
      return offset + 8;
    }
    function writeFloatLE(buffer, value, offset) {
      if (offset === void 0) offset = 0;
      const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
      view.setFloat32(offset, value, true);
      return offset + 4;
    }
    function writeUInt32LE(buffer, value, offset) {
      if (offset === void 0) offset = 0;
      const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
      view.setUint32(offset, value, true);
      return offset + 4;
    }
    function writeInt32LE(buffer, value, offset) {
      if (offset === void 0) offset = 0;
      const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
      view.setInt32(offset, value, true);
      return offset + 4;
    }
    function readDoubleLE(buffer, offset) {
      if (offset === void 0) offset = 0;
      const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
      return view.getFloat64(offset, true);
    }
    function readFloatLE(buffer, offset) {
      if (offset === void 0) offset = 0;
      const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
      return view.getFloat32(offset, true);
    }
    function readUInt32LE(buffer, offset) {
      if (offset === void 0) offset = 0;
      const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
      return view.getUint32(offset, true);
    }
    function readInt32LE(buffer, offset) {
      if (offset === void 0) offset = 0;
      const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
      return view.getInt32(offset, true);
    }
    function writeDoubleBE(buffer, value, offset) {
      if (offset === void 0) offset = 0;
      const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
      view.setFloat64(offset, value, false);
      return offset + 8;
    }
    function writeFloatBE(buffer, value, offset) {
      if (offset === void 0) offset = 0;
      const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
      view.setFloat32(offset, value, false);
      return offset + 4;
    }
    function writeUInt32BE(buffer, value, offset) {
      if (offset === void 0) offset = 0;
      const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
      view.setUint32(offset, value, false);
      return offset + 4;
    }
    function writeInt32BE(buffer, value, offset) {
      if (offset === void 0) offset = 0;
      const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
      view.setInt32(offset, value, false);
      return offset + 4;
    }
    function readDoubleBE(buffer, offset) {
      if (offset === void 0) offset = 0;
      const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
      return view.getFloat64(offset, false);
    }
    function readFloatBE(buffer, offset) {
      if (offset === void 0) offset = 0;
      const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
      return view.getFloat32(offset, false);
    }
    function readUInt32BE(buffer, offset) {
      if (offset === void 0) offset = 0;
      const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
      return view.getUint32(offset, false);
    }
    function readInt32BE(buffer, offset) {
      if (offset === void 0) offset = 0;
      const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
      return view.getInt32(offset, false);
    }
    module.exports = exports = {
      isBuffer,
      isEncoding,
      alloc,
      allocUnsafe,
      allocUnsafeSlow,
      byteLength,
      compare,
      concat: concat2,
      copy,
      equals,
      fill,
      from,
      includes,
      indexOf,
      lastIndexOf,
      swap16,
      swap32,
      swap64,
      toBuffer: toBuffer2,
      toString,
      write,
      writeDoubleLE,
      writeFloatLE,
      writeUInt32LE,
      writeInt32LE,
      readDoubleLE,
      readFloatLE,
      readUInt32LE,
      readInt32LE,
      writeDoubleBE,
      writeFloatBE,
      writeUInt32BE,
      writeInt32BE,
      readDoubleBE,
      readFloatBE,
      readUInt32BE,
      readInt32BE
    };
  }
});

// node_modules/record-cache/index.js
var require_record_cache = __commonJS({
  "node_modules/record-cache/index.js"(exports, module) {
    var b4a = require_browser4();
    var EMPTY = [];
    module.exports = RecordCache;
    function RecordSet() {
      this.list = [];
      this.map = /* @__PURE__ */ new Map();
    }
    RecordSet.prototype.add = function(record, value) {
      var k = toString(record);
      var r = this.map.get(k);
      if (r) return false;
      r = { index: this.list.length, record: value || record };
      this.list.push(r);
      this.map.set(k, r);
      return true;
    };
    RecordSet.prototype.remove = function(record) {
      var k = toString(record);
      var r = this.map.get(k);
      if (!r) return false;
      swap(this.list, r.index, this.list.length - 1);
      this.list.pop();
      this.map.delete(k);
      return true;
    };
    function RecordStore() {
      this.records = /* @__PURE__ */ new Map();
      this.size = 0;
    }
    RecordStore.prototype.add = function(name, record, value) {
      var r = this.records.get(name);
      if (!r) {
        r = new RecordSet();
        this.records.set(name, r);
      }
      if (r.add(record, value)) {
        this.size++;
        return true;
      }
      return false;
    };
    RecordStore.prototype.remove = function(name, record, value) {
      var r = this.records.get(name);
      if (!r) return false;
      if (r.remove(record, value)) {
        this.size--;
        if (!r.map.size) this.records.delete(name);
        return true;
      }
      return false;
    };
    RecordStore.prototype.get = function(name) {
      var r = this.records.get(name);
      return r ? r.list : EMPTY;
    };
    function RecordCache(opts) {
      if (!(this instanceof RecordCache)) return new RecordCache(opts);
      if (!opts) opts = {};
      this.maxSize = opts.maxSize || Infinity;
      this.maxAge = opts.maxAge || 0;
      this._onstale = opts.onStale || opts.onstale || null;
      this._fresh = new RecordStore();
      this._stale = new RecordStore();
      this._interval = null;
      this._gced = false;
      if (this.maxAge && this.maxAge < Infinity) {
        var tick = Math.ceil(2 / 3 * this.maxAge);
        this._interval = setInterval(this._gcAuto.bind(this), tick);
        if (this._interval.unref) this._interval.unref();
      }
    }
    Object.defineProperty(RecordCache.prototype, "size", {
      get: function() {
        return this._fresh.size + this._stale.size;
      }
    });
    RecordCache.prototype.add = function(name, record, value) {
      this._stale.remove(name, record, value);
      if (this._fresh.add(name, record, value) && this._fresh.size > this.maxSize) {
        this._gc();
      }
    };
    RecordCache.prototype.remove = function(name, record, value) {
      this._fresh.remove(name, record, value);
      this._stale.remove(name, record, value);
    };
    RecordCache.prototype.get = function(name, n) {
      var a = this._fresh.get(name);
      var b = this._stale.get(name);
      var aLen = a.length;
      var bLen = b.length;
      var len = aLen + bLen;
      if (n > len || !n) n = len;
      var result = new Array(n);
      for (var i = 0; i < n; i++) {
        var j = Math.floor(Math.random() * (aLen + bLen));
        if (j < aLen) {
          result[i] = a[j].record;
          swap(a, j, --aLen);
        } else {
          j -= aLen;
          result[i] = b[j].record;
          swap(b, j, --bLen);
        }
      }
      return result;
    };
    RecordCache.prototype._gcAuto = function() {
      if (!this._gced) this._gc();
      this._gced = false;
    };
    RecordCache.prototype._gc = function() {
      if (this._onstale && this._stale.size > 0) this._onstale(this._stale);
      this._stale = this._fresh;
      this._fresh = new RecordStore();
      this._gced = true;
    };
    RecordCache.prototype.clear = function() {
      this._gc();
      this._gc();
    };
    RecordCache.prototype.destroy = function() {
      this.clear();
      clearInterval(this._interval);
      this._interval = null;
    };
    function toString(record) {
      return b4a.isBuffer(record) ? b4a.toString(record, "hex") : record;
    }
    function swap(list, a, b) {
      var tmp = list[a];
      tmp.index = b;
      list[b].index = a;
      list[a] = list[b];
      list[b] = tmp;
    }
  }
});

// node_modules/wrappy/wrappy.js
var require_wrappy = __commonJS({
  "node_modules/wrappy/wrappy.js"(exports, module) {
    module.exports = wrappy;
    function wrappy(fn, cb) {
      if (fn && cb) return wrappy(fn)(cb);
      if (typeof fn !== "function")
        throw new TypeError("need wrapper function");
      Object.keys(fn).forEach(function(k) {
        wrapper[k] = fn[k];
      });
      return wrapper;
      function wrapper() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        var ret = fn.apply(this, args);
        var cb2 = args[args.length - 1];
        if (typeof ret === "function" && ret !== cb2) {
          Object.keys(cb2).forEach(function(k) {
            ret[k] = cb2[k];
          });
        }
        return ret;
      }
    }
  }
});

// node_modules/once/once.js
var require_once = __commonJS({
  "node_modules/once/once.js"(exports, module) {
    var wrappy = require_wrappy();
    module.exports = wrappy(once3);
    module.exports.strict = wrappy(onceStrict);
    once3.proto = once3(function() {
      Object.defineProperty(Function.prototype, "once", {
        value: function() {
          return once3(this);
        },
        configurable: true
      });
      Object.defineProperty(Function.prototype, "onceStrict", {
        value: function() {
          return onceStrict(this);
        },
        configurable: true
      });
    });
    function once3(fn) {
      var f = function() {
        if (f.called) return f.value;
        f.called = true;
        return f.value = fn.apply(this, arguments);
      };
      f.called = false;
      return f;
    }
    function onceStrict(fn) {
      var f = function() {
        if (f.called)
          throw new Error(f.onceError);
        f.called = true;
        return f.value = fn.apply(this, arguments);
      };
      var name = fn.name || "Function wrapped with `once`";
      f.onceError = name + " shouldn't be called more than once";
      f.called = false;
      return f;
    }
  }
});

// (disabled):node_modules/bittorrent-tracker/lib/common-node.js
var require_common_node = __commonJS({
  "(disabled):node_modules/bittorrent-tracker/lib/common-node.js"() {
  }
});

// (disabled):node_modules/bittorrent-tracker/lib/client/http-tracker.js
var require_http_tracker = __commonJS({
  "(disabled):node_modules/bittorrent-tracker/lib/client/http-tracker.js"() {
  }
});

// (disabled):node_modules/bittorrent-tracker/lib/client/udp-tracker.js
var require_udp_tracker = __commonJS({
  "(disabled):node_modules/bittorrent-tracker/lib/client/udp-tracker.js"() {
  }
});

// browser-external:ws
var require_ws = __commonJS({
  "browser-external:ws"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "ws" has been externalized for browser compatibility. Cannot access "ws.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// (disabled):node_modules/bittorrent-tracker/server.js
var require_server = __commonJS({
  "(disabled):node_modules/bittorrent-tracker/server.js"() {
  }
});

// browser-external:bittorrent-lsd
var require_bittorrent_lsd = __commonJS({
  "browser-external:bittorrent-lsd"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "bittorrent-lsd" has been externalized for browser compatibility. Cannot access "bittorrent-lsd.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/immediate-chunk-store/index.js
var require_immediate_chunk_store = __commonJS({
  "node_modules/immediate-chunk-store/index.js"(exports, module) {
    var queueMicrotask9 = require_queue_microtask();
    var ImmediateStore = class {
      constructor(store) {
        this.store = store;
        this.chunkLength = store.chunkLength;
        if (!this.store || !this.store.get || !this.store.put) {
          throw new Error("First argument must be abstract-chunk-store compliant");
        }
        this.mem = [];
      }
      put(index, buf, cb = () => {
      }) {
        this.mem[index] = buf;
        this.store.put(index, buf, (err2) => {
          this.mem[index] = null;
          cb(err2);
        });
      }
      get(index, opts, cb = () => {
      }) {
        if (typeof opts === "function") return this.get(index, null, opts);
        let buf = this.mem[index];
        if (!buf) {
          return this.store.get(index, opts, cb);
        }
        if (!opts) opts = {};
        const offset = opts.offset || 0;
        const len = opts.length || buf.length - offset;
        if (offset !== 0 || len !== buf.length) {
          buf = buf.slice(offset, len + offset);
        }
        queueMicrotask9(() => cb(null, buf));
      }
      close(cb = () => {
      }) {
        this.store.close(cb);
      }
      destroy(cb = () => {
      }) {
        this.store.destroy(cb);
      }
    };
    module.exports = ImmediateStore;
  }
});

// node_modules/memory-chunk-store/index.js
var require_memory_chunk_store = __commonJS({
  "node_modules/memory-chunk-store/index.js"(exports, module) {
    module.exports = Storage;
    var queueMicrotask9 = require_queue_microtask();
    function Storage(chunkLength, opts) {
      if (!(this instanceof Storage)) return new Storage(chunkLength, opts);
      if (!opts) opts = {};
      this.chunkLength = Number(chunkLength);
      if (!this.chunkLength) throw new Error("First argument must be a chunk length");
      this.chunks = [];
      this.closed = false;
      this.length = Number(opts.length) || Infinity;
      if (this.length !== Infinity) {
        this.lastChunkLength = this.length % this.chunkLength || this.chunkLength;
        this.lastChunkIndex = Math.ceil(this.length / this.chunkLength) - 1;
      }
    }
    Storage.prototype.put = function(index, buf, cb = () => {
    }) {
      if (this.closed) return queueMicrotask9(() => cb(new Error("Storage is closed")));
      const isLastChunk = index === this.lastChunkIndex;
      if (isLastChunk && buf.length !== this.lastChunkLength) {
        return queueMicrotask9(() => cb(new Error("Last chunk length must be " + this.lastChunkLength)));
      }
      if (!isLastChunk && buf.length !== this.chunkLength) {
        return queueMicrotask9(() => cb(new Error("Chunk length must be " + this.chunkLength)));
      }
      this.chunks[index] = buf;
      queueMicrotask9(() => cb(null));
    };
    Storage.prototype.get = function(index, opts, cb = () => {
    }) {
      if (typeof opts === "function") return this.get(index, null, opts);
      if (this.closed) return queueMicrotask9(() => cb(new Error("Storage is closed")));
      let buf = this.chunks[index];
      if (!buf) {
        const err2 = new Error("Chunk not found");
        err2.notFound = true;
        return queueMicrotask9(() => cb(err2));
      }
      if (!opts) opts = {};
      const offset = opts.offset || 0;
      const len = opts.length || buf.length - offset;
      if (offset !== 0 || len !== buf.length) {
        buf = buf.slice(offset, len + offset);
      }
      queueMicrotask9(() => cb(null, buf));
    };
    Storage.prototype.close = Storage.prototype.destroy = function(cb = () => {
    }) {
      if (this.closed) return queueMicrotask9(() => cb(new Error("Storage is closed")));
      this.closed = true;
      this.chunks = null;
      queueMicrotask9(() => cb(null));
    };
  }
});

// node_modules/run-parallel-limit/index.js
var require_run_parallel_limit = __commonJS({
  "node_modules/run-parallel-limit/index.js"(exports, module) {
    module.exports = runParallelLimit;
    var queueMicrotask9 = require_queue_microtask();
    function runParallelLimit(tasks, limit, cb) {
      if (typeof limit !== "number") throw new Error("second argument must be a Number");
      let results, len, pending, keys, isErrored;
      let isSync = true;
      let next;
      if (Array.isArray(tasks)) {
        results = [];
        pending = len = tasks.length;
      } else {
        keys = Object.keys(tasks);
        results = {};
        pending = len = keys.length;
      }
      function done(err2) {
        function end() {
          if (cb) cb(err2, results);
          cb = null;
        }
        if (isSync) queueMicrotask9(end);
        else end();
      }
      function each(i, err2, result) {
        results[i] = result;
        if (err2) isErrored = true;
        if (--pending === 0 || err2) {
          done(err2);
        } else if (!isErrored && next < len) {
          let key;
          if (keys) {
            key = keys[next];
            next += 1;
            tasks[key](function(err3, result2) {
              each(key, err3, result2);
            });
          } else {
            key = next;
            next += 1;
            tasks[key](function(err3, result2) {
              each(key, err3, result2);
            });
          }
        }
      }
      next = limit;
      if (!pending) {
        done(null);
      } else if (keys) {
        keys.some(function(key, i) {
          tasks[key](function(err2, result) {
            each(key, err2, result);
          });
          if (i === limit - 1) return true;
          return false;
        });
      } else {
        tasks.some(function(task, i) {
          task(function(err2, result) {
            each(i, err2, result);
          });
          if (i === limit - 1) return true;
          return false;
        });
      }
      isSync = false;
    }
  }
});

// node_modules/random-iterate/index.js
var require_random_iterate = __commonJS({
  "node_modules/random-iterate/index.js"(exports, module) {
    var iterate = function(list) {
      var offset = 0;
      return function() {
        if (offset === list.length) return null;
        var len = list.length - offset;
        var i = Math.random() * len | 0;
        var el = list[offset + i];
        var tmp = list[offset];
        list[offset] = el;
        list[offset + i] = tmp;
        offset++;
        return el;
      };
    };
    module.exports = iterate;
  }
});

// browser-external:ut_pex
var require_ut_pex = __commonJS({
  "browser-external:ut_pex"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "ut_pex" has been externalized for browser compatibility. Cannot access "ut_pex.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/mime/Mime.js
var require_Mime = __commonJS({
  "node_modules/mime/Mime.js"(exports, module) {
    "use strict";
    function Mime() {
      this._types = /* @__PURE__ */ Object.create(null);
      this._extensions = /* @__PURE__ */ Object.create(null);
      for (let i = 0; i < arguments.length; i++) {
        this.define(arguments[i]);
      }
      this.define = this.define.bind(this);
      this.getType = this.getType.bind(this);
      this.getExtension = this.getExtension.bind(this);
    }
    Mime.prototype.define = function(typeMap, force) {
      for (let type in typeMap) {
        let extensions = typeMap[type].map(function(t) {
          return t.toLowerCase();
        });
        type = type.toLowerCase();
        for (let i = 0; i < extensions.length; i++) {
          const ext = extensions[i];
          if (ext[0] === "*") {
            continue;
          }
          if (!force && ext in this._types) {
            throw new Error(
              'Attempt to change mapping for "' + ext + '" extension from "' + this._types[ext] + '" to "' + type + '". Pass `force=true` to allow this, otherwise remove "' + ext + '" from the list of extensions for "' + type + '".'
            );
          }
          this._types[ext] = type;
        }
        if (force || !this._extensions[type]) {
          const ext = extensions[0];
          this._extensions[type] = ext[0] !== "*" ? ext : ext.substr(1);
        }
      }
    };
    Mime.prototype.getType = function(path4) {
      path4 = String(path4);
      let last = path4.replace(/^.*[/\\]/, "").toLowerCase();
      let ext = last.replace(/^.*\./, "").toLowerCase();
      let hasPath = last.length < path4.length;
      let hasDot = ext.length < last.length - 1;
      return (hasDot || !hasPath) && this._types[ext] || null;
    };
    Mime.prototype.getExtension = function(type) {
      type = /^\s*([^;\s]*)/.test(type) && RegExp.$1;
      return type && this._extensions[type.toLowerCase()] || null;
    };
    module.exports = Mime;
  }
});

// node_modules/mime/types/standard.js
var require_standard = __commonJS({
  "node_modules/mime/types/standard.js"(exports, module) {
    module.exports = { "application/andrew-inset": ["ez"], "application/applixware": ["aw"], "application/atom+xml": ["atom"], "application/atomcat+xml": ["atomcat"], "application/atomdeleted+xml": ["atomdeleted"], "application/atomsvc+xml": ["atomsvc"], "application/atsc-dwd+xml": ["dwd"], "application/atsc-held+xml": ["held"], "application/atsc-rsat+xml": ["rsat"], "application/bdoc": ["bdoc"], "application/calendar+xml": ["xcs"], "application/ccxml+xml": ["ccxml"], "application/cdfx+xml": ["cdfx"], "application/cdmi-capability": ["cdmia"], "application/cdmi-container": ["cdmic"], "application/cdmi-domain": ["cdmid"], "application/cdmi-object": ["cdmio"], "application/cdmi-queue": ["cdmiq"], "application/cu-seeme": ["cu"], "application/dash+xml": ["mpd"], "application/davmount+xml": ["davmount"], "application/docbook+xml": ["dbk"], "application/dssc+der": ["dssc"], "application/dssc+xml": ["xdssc"], "application/ecmascript": ["es", "ecma"], "application/emma+xml": ["emma"], "application/emotionml+xml": ["emotionml"], "application/epub+zip": ["epub"], "application/exi": ["exi"], "application/express": ["exp"], "application/fdt+xml": ["fdt"], "application/font-tdpfr": ["pfr"], "application/geo+json": ["geojson"], "application/gml+xml": ["gml"], "application/gpx+xml": ["gpx"], "application/gxf": ["gxf"], "application/gzip": ["gz"], "application/hjson": ["hjson"], "application/hyperstudio": ["stk"], "application/inkml+xml": ["ink", "inkml"], "application/ipfix": ["ipfix"], "application/its+xml": ["its"], "application/java-archive": ["jar", "war", "ear"], "application/java-serialized-object": ["ser"], "application/java-vm": ["class"], "application/javascript": ["js", "mjs"], "application/json": ["json", "map"], "application/json5": ["json5"], "application/jsonml+json": ["jsonml"], "application/ld+json": ["jsonld"], "application/lgr+xml": ["lgr"], "application/lost+xml": ["lostxml"], "application/mac-binhex40": ["hqx"], "application/mac-compactpro": ["cpt"], "application/mads+xml": ["mads"], "application/manifest+json": ["webmanifest"], "application/marc": ["mrc"], "application/marcxml+xml": ["mrcx"], "application/mathematica": ["ma", "nb", "mb"], "application/mathml+xml": ["mathml"], "application/mbox": ["mbox"], "application/mediaservercontrol+xml": ["mscml"], "application/metalink+xml": ["metalink"], "application/metalink4+xml": ["meta4"], "application/mets+xml": ["mets"], "application/mmt-aei+xml": ["maei"], "application/mmt-usd+xml": ["musd"], "application/mods+xml": ["mods"], "application/mp21": ["m21", "mp21"], "application/mp4": ["mp4s", "m4p"], "application/msword": ["doc", "dot"], "application/mxf": ["mxf"], "application/n-quads": ["nq"], "application/n-triples": ["nt"], "application/node": ["cjs"], "application/octet-stream": ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"], "application/oda": ["oda"], "application/oebps-package+xml": ["opf"], "application/ogg": ["ogx"], "application/omdoc+xml": ["omdoc"], "application/onenote": ["onetoc", "onetoc2", "onetmp", "onepkg"], "application/oxps": ["oxps"], "application/p2p-overlay+xml": ["relo"], "application/patch-ops-error+xml": ["xer"], "application/pdf": ["pdf"], "application/pgp-encrypted": ["pgp"], "application/pgp-signature": ["asc", "sig"], "application/pics-rules": ["prf"], "application/pkcs10": ["p10"], "application/pkcs7-mime": ["p7m", "p7c"], "application/pkcs7-signature": ["p7s"], "application/pkcs8": ["p8"], "application/pkix-attr-cert": ["ac"], "application/pkix-cert": ["cer"], "application/pkix-crl": ["crl"], "application/pkix-pkipath": ["pkipath"], "application/pkixcmp": ["pki"], "application/pls+xml": ["pls"], "application/postscript": ["ai", "eps", "ps"], "application/provenance+xml": ["provx"], "application/pskc+xml": ["pskcxml"], "application/raml+yaml": ["raml"], "application/rdf+xml": ["rdf", "owl"], "application/reginfo+xml": ["rif"], "application/relax-ng-compact-syntax": ["rnc"], "application/resource-lists+xml": ["rl"], "application/resource-lists-diff+xml": ["rld"], "application/rls-services+xml": ["rs"], "application/route-apd+xml": ["rapd"], "application/route-s-tsid+xml": ["sls"], "application/route-usd+xml": ["rusd"], "application/rpki-ghostbusters": ["gbr"], "application/rpki-manifest": ["mft"], "application/rpki-roa": ["roa"], "application/rsd+xml": ["rsd"], "application/rss+xml": ["rss"], "application/rtf": ["rtf"], "application/sbml+xml": ["sbml"], "application/scvp-cv-request": ["scq"], "application/scvp-cv-response": ["scs"], "application/scvp-vp-request": ["spq"], "application/scvp-vp-response": ["spp"], "application/sdp": ["sdp"], "application/senml+xml": ["senmlx"], "application/sensml+xml": ["sensmlx"], "application/set-payment-initiation": ["setpay"], "application/set-registration-initiation": ["setreg"], "application/shf+xml": ["shf"], "application/sieve": ["siv", "sieve"], "application/smil+xml": ["smi", "smil"], "application/sparql-query": ["rq"], "application/sparql-results+xml": ["srx"], "application/srgs": ["gram"], "application/srgs+xml": ["grxml"], "application/sru+xml": ["sru"], "application/ssdl+xml": ["ssdl"], "application/ssml+xml": ["ssml"], "application/swid+xml": ["swidtag"], "application/tei+xml": ["tei", "teicorpus"], "application/thraud+xml": ["tfi"], "application/timestamped-data": ["tsd"], "application/toml": ["toml"], "application/trig": ["trig"], "application/ttml+xml": ["ttml"], "application/ubjson": ["ubj"], "application/urc-ressheet+xml": ["rsheet"], "application/urc-targetdesc+xml": ["td"], "application/voicexml+xml": ["vxml"], "application/wasm": ["wasm"], "application/widget": ["wgt"], "application/winhlp": ["hlp"], "application/wsdl+xml": ["wsdl"], "application/wspolicy+xml": ["wspolicy"], "application/xaml+xml": ["xaml"], "application/xcap-att+xml": ["xav"], "application/xcap-caps+xml": ["xca"], "application/xcap-diff+xml": ["xdf"], "application/xcap-el+xml": ["xel"], "application/xcap-ns+xml": ["xns"], "application/xenc+xml": ["xenc"], "application/xhtml+xml": ["xhtml", "xht"], "application/xliff+xml": ["xlf"], "application/xml": ["xml", "xsl", "xsd", "rng"], "application/xml-dtd": ["dtd"], "application/xop+xml": ["xop"], "application/xproc+xml": ["xpl"], "application/xslt+xml": ["*xsl", "xslt"], "application/xspf+xml": ["xspf"], "application/xv+xml": ["mxml", "xhvml", "xvml", "xvm"], "application/yang": ["yang"], "application/yin+xml": ["yin"], "application/zip": ["zip"], "audio/3gpp": ["*3gpp"], "audio/adpcm": ["adp"], "audio/amr": ["amr"], "audio/basic": ["au", "snd"], "audio/midi": ["mid", "midi", "kar", "rmi"], "audio/mobile-xmf": ["mxmf"], "audio/mp3": ["*mp3"], "audio/mp4": ["m4a", "mp4a"], "audio/mpeg": ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"], "audio/ogg": ["oga", "ogg", "spx", "opus"], "audio/s3m": ["s3m"], "audio/silk": ["sil"], "audio/wav": ["wav"], "audio/wave": ["*wav"], "audio/webm": ["weba"], "audio/xm": ["xm"], "font/collection": ["ttc"], "font/otf": ["otf"], "font/ttf": ["ttf"], "font/woff": ["woff"], "font/woff2": ["woff2"], "image/aces": ["exr"], "image/apng": ["apng"], "image/avif": ["avif"], "image/bmp": ["bmp"], "image/cgm": ["cgm"], "image/dicom-rle": ["drle"], "image/emf": ["emf"], "image/fits": ["fits"], "image/g3fax": ["g3"], "image/gif": ["gif"], "image/heic": ["heic"], "image/heic-sequence": ["heics"], "image/heif": ["heif"], "image/heif-sequence": ["heifs"], "image/hej2k": ["hej2"], "image/hsj2": ["hsj2"], "image/ief": ["ief"], "image/jls": ["jls"], "image/jp2": ["jp2", "jpg2"], "image/jpeg": ["jpeg", "jpg", "jpe"], "image/jph": ["jph"], "image/jphc": ["jhc"], "image/jpm": ["jpm"], "image/jpx": ["jpx", "jpf"], "image/jxr": ["jxr"], "image/jxra": ["jxra"], "image/jxrs": ["jxrs"], "image/jxs": ["jxs"], "image/jxsc": ["jxsc"], "image/jxsi": ["jxsi"], "image/jxss": ["jxss"], "image/ktx": ["ktx"], "image/ktx2": ["ktx2"], "image/png": ["png"], "image/sgi": ["sgi"], "image/svg+xml": ["svg", "svgz"], "image/t38": ["t38"], "image/tiff": ["tif", "tiff"], "image/tiff-fx": ["tfx"], "image/webp": ["webp"], "image/wmf": ["wmf"], "message/disposition-notification": ["disposition-notification"], "message/global": ["u8msg"], "message/global-delivery-status": ["u8dsn"], "message/global-disposition-notification": ["u8mdn"], "message/global-headers": ["u8hdr"], "message/rfc822": ["eml", "mime"], "model/3mf": ["3mf"], "model/gltf+json": ["gltf"], "model/gltf-binary": ["glb"], "model/iges": ["igs", "iges"], "model/mesh": ["msh", "mesh", "silo"], "model/mtl": ["mtl"], "model/obj": ["obj"], "model/step+xml": ["stpx"], "model/step+zip": ["stpz"], "model/step-xml+zip": ["stpxz"], "model/stl": ["stl"], "model/vrml": ["wrl", "vrml"], "model/x3d+binary": ["*x3db", "x3dbz"], "model/x3d+fastinfoset": ["x3db"], "model/x3d+vrml": ["*x3dv", "x3dvz"], "model/x3d+xml": ["x3d", "x3dz"], "model/x3d-vrml": ["x3dv"], "text/cache-manifest": ["appcache", "manifest"], "text/calendar": ["ics", "ifb"], "text/coffeescript": ["coffee", "litcoffee"], "text/css": ["css"], "text/csv": ["csv"], "text/html": ["html", "htm", "shtml"], "text/jade": ["jade"], "text/jsx": ["jsx"], "text/less": ["less"], "text/markdown": ["markdown", "md"], "text/mathml": ["mml"], "text/mdx": ["mdx"], "text/n3": ["n3"], "text/plain": ["txt", "text", "conf", "def", "list", "log", "in", "ini"], "text/richtext": ["rtx"], "text/rtf": ["*rtf"], "text/sgml": ["sgml", "sgm"], "text/shex": ["shex"], "text/slim": ["slim", "slm"], "text/spdx": ["spdx"], "text/stylus": ["stylus", "styl"], "text/tab-separated-values": ["tsv"], "text/troff": ["t", "tr", "roff", "man", "me", "ms"], "text/turtle": ["ttl"], "text/uri-list": ["uri", "uris", "urls"], "text/vcard": ["vcard"], "text/vtt": ["vtt"], "text/xml": ["*xml"], "text/yaml": ["yaml", "yml"], "video/3gpp": ["3gp", "3gpp"], "video/3gpp2": ["3g2"], "video/h261": ["h261"], "video/h263": ["h263"], "video/h264": ["h264"], "video/iso.segment": ["m4s"], "video/jpeg": ["jpgv"], "video/jpm": ["*jpm", "jpgm"], "video/mj2": ["mj2", "mjp2"], "video/mp2t": ["ts"], "video/mp4": ["mp4", "mp4v", "mpg4"], "video/mpeg": ["mpeg", "mpg", "mpe", "m1v", "m2v"], "video/ogg": ["ogv"], "video/quicktime": ["qt", "mov"], "video/webm": ["webm"] };
  }
});

// node_modules/mime/lite.js
var require_lite = __commonJS({
  "node_modules/mime/lite.js"(exports, module) {
    "use strict";
    var Mime = require_Mime();
    module.exports = new Mime(require_standard());
  }
});

// (disabled):node_modules/webtorrent/lib/utp.cjs
var require_utp = __commonJS({
  "(disabled):node_modules/webtorrent/lib/utp.cjs"() {
  }
});

// node_modules/webtorrent/package.json
var require_package = __commonJS({
  "node_modules/webtorrent/package.json"(exports, module) {
    module.exports = {
      name: "webtorrent",
      description: "Streaming torrent client",
      version: "2.5.6",
      author: {
        name: "WebTorrent LLC",
        email: "feross@webtorrent.io",
        url: "https://webtorrent.io"
      },
      type: "module",
      browser: {
        "./lib/conn-pool.js": false,
        "./lib/utp.cjs": false,
        "@silentbot1/nat-api": false,
        "bittorrent-dht": false,
        crypto: false,
        fs: false,
        "fs-chunk-store": "fsa-chunk-store",
        http: false,
        "load-ip-set": false,
        net: false,
        os: false,
        ut_pex: false
      },
      bugs: {
        url: "https://github.com/webtorrent/webtorrent/issues"
      },
      chromeapp: {
        "./lib/utp.cjs": false,
        "@silentbot1/nat-api": false,
        fs: false,
        "fs-chunk-store": "memory-chunk-store",
        http: "@webtorrent/http-node",
        https: "@webtorrent/http-node",
        "load-ip-set": false,
        net: "chrome-net",
        os: false
      },
      dependencies: {
        "@silentbot1/nat-api": "^0.4.7",
        "@thaunknown/simple-peer": "^10.0.11",
        "@webtorrent/http-node": "^1.3.0",
        "addr-to-ip-port": "^2.0.0",
        bitfield: "^4.2.0",
        "bittorrent-dht": "^11.0.8",
        "bittorrent-protocol": "^4.1.15",
        "cache-chunk-store": "^3.2.2",
        "chunk-store-iterator": "^1.0.3",
        cpus: "^1.0.3",
        "create-torrent": "^6.0.18",
        "cross-fetch-ponyfill": "^1.0.3",
        debug: "^4.3.7",
        "escape-html": "^1.0.3",
        "fs-chunk-store": "^4.1.0",
        "fsa-chunk-store": "^1.3.0",
        "immediate-chunk-store": "^2.2.0",
        "join-async-iterator": "^1.1.1",
        "load-ip-set": "^3.0.1",
        lt_donthave: "^2.0.3",
        "memory-chunk-store": "^1.3.5",
        mime: "^3.0.0",
        once: "^1.4.0",
        "parse-torrent": "^11.0.17",
        pump: "^3.0.2",
        "queue-microtask": "^1.2.3",
        "random-iterate": "^1.0.1",
        "range-parser": "^1.2.1",
        "run-parallel": "^1.2.0",
        "run-parallel-limit": "^1.1.0",
        "speed-limiter": "^1.0.2",
        streamx: "2.20.1",
        throughput: "^1.0.1",
        "torrent-discovery": "^11.0.11",
        "torrent-piece": "^3.0.0",
        "uint8-util": "^2.2.5",
        "unordered-array-remove": "^1.0.2",
        ut_metadata: "^4.0.3",
        ut_pex: "^4.0.4"
      },
      devDependencies: {
        "@babel/core": "7.26.0",
        "@babel/eslint-parser": "^7.25.9",
        "@babel/plugin-syntax-import-assertions": "7.26.0",
        "@babel/preset-env": "7.26.0",
        "@webtorrent/semantic-release-config": "1.0.10",
        airtap: "4.0.4",
        "airtap-manual": "1.0.0",
        "airtap-sauce": "1.1.2",
        "airtap-system": "^0.1.0",
        babelify: "10.0.0",
        "bittorrent-tracker": "11.1.2",
        buffer: "^6.0.3",
        "chrome-net": "^3.3.4",
        "crypto-browserify": "^3.12.1",
        disc: "1.3.3",
        eslint: "^8.57.1",
        "eslint-config-standard": "^17.1.0",
        "eslint-plugin-import": "^2.31.0",
        "eslint-plugin-n": "^16.6.2",
        "eslint-plugin-promise": "^6.6.0",
        finalhandler: "1.3.1",
        "network-address": "1.1.2",
        pako: "^2.1.0",
        "path-esm": "^1.0.0",
        querystring: "^0.2.1",
        "run-series": "1.1.9",
        "semantic-release": "22.0.12",
        "serve-static": "1.16.2",
        "stream-browserify": "^3.0.0",
        "tap-parser": "^16.0.1",
        "tap-spec": "^5.0.0",
        tape: "^5.9.0",
        "terser-webpack-plugin": "^5.3.10",
        "timers-browserify": "^2.0.12",
        webpack: "^5.96.1",
        "webpack-cli": "^5.1.4",
        "webtorrent-fixtures": "1.7.5"
      },
      optionalDependencies: {
        "utp-native": "^2.5.3"
      },
      engines: {
        node: ">=16"
      },
      funding: [
        {
          type: "github",
          url: "https://github.com/sponsors/feross"
        },
        {
          type: "patreon",
          url: "https://www.patreon.com/feross"
        },
        {
          type: "consulting",
          url: "https://feross.org/support"
        }
      ],
      homepage: "https://webtorrent.io",
      keywords: [
        "bittorrent",
        "bittorrent client",
        "download",
        "mad science",
        "p2p",
        "peer-to-peer",
        "peers",
        "streaming",
        "swarm",
        "torrent",
        "web torrent",
        "webrtc",
        "webrtc data",
        "webtorrent"
      ],
      license: "MIT",
      main: "index.js",
      repository: {
        type: "git",
        url: "git://github.com/webtorrent/webtorrent.git"
      },
      scripts: {
        build: "npm run build-js && npm run build-js-worker && npm run build-chromeapp",
        "build-chromeapp": "webpack --config ./scripts/chromeapp.webpack.js",
        "build-js": "webpack --config ./scripts/browser.webpack.js",
        "build-js-worker": "webpack --config ./scripts/worker.webpack.js",
        prepublishOnly: "npm run build && npm run update-authors",
        preversion: "npm run build && npm run update-authors",
        size: "npm run size-js && npm run size-disc",
        "size-disc": "npm run build-js && cat ./dist/webtorrent.min.js | discify --open",
        "size-js": "npm run build-js && cat ./dist/webtorrent.min.js | gzip | wc -c",
        test: "eslint . && npm run test-node && npm run test-browser",
        "test-browser": "airtap --concurrency 1 --all -- test/*.js test/browser/*.js | tap-spec",
        "test-browser-local": "airtap --preset local -- test/*.js test/browser/*.js | tap-spec",
        "test-node": "tape test/*.js test/node/*.js | tap-spec",
        "update-authors": "./scripts/update-authors.sh"
      },
      renovate: {
        extends: [
          "github>webtorrent/renovate-config"
        ],
        rangeStrategy: "bump"
      },
      release: {
        extends: "@webtorrent/semantic-release-config"
      }
    };
  }
});

// node_modules/webtorrent/version.cjs
var require_version = __commonJS({
  "node_modules/webtorrent/version.cjs"(exports, module) {
    module.exports = require_package().version;
  }
});

// browser-external:http
var require_http = __commonJS({
  "browser-external:http"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "http" has been externalized for browser compatibility. Cannot access "http.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/escape-html/index.js
var require_escape_html = __commonJS({
  "node_modules/escape-html/index.js"(exports, module) {
    "use strict";
    var matchHtmlRegExp = /["'&<>]/;
    module.exports = escapeHtml2;
    function escapeHtml2(string) {
      var str = "" + string;
      var match = matchHtmlRegExp.exec(str);
      if (!match) {
        return str;
      }
      var escape2;
      var html = "";
      var index = 0;
      var lastIndex = 0;
      for (index = match.index; index < str.length; index++) {
        switch (str.charCodeAt(index)) {
          case 34:
            escape2 = "&quot;";
            break;
          case 38:
            escape2 = "&amp;";
            break;
          case 39:
            escape2 = "&#39;";
            break;
          case 60:
            escape2 = "&lt;";
            break;
          case 62:
            escape2 = "&gt;";
            break;
          default:
            continue;
        }
        if (lastIndex !== index) {
          html += str.substring(lastIndex, index);
        }
        lastIndex = index + 1;
        html += escape2;
      }
      return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
    }
  }
});

// node_modules/end-of-stream/index.js
var require_end_of_stream = __commonJS({
  "node_modules/end-of-stream/index.js"(exports, module) {
    var once3 = require_once();
    var noop5 = function() {
    };
    var isRequest = function(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    };
    var isChildProcess = function(stream) {
      return stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3;
    };
    var eos = function(stream, opts, callback) {
      if (typeof opts === "function") return eos(stream, null, opts);
      if (!opts) opts = {};
      callback = once3(callback || noop5);
      var ws2 = stream._writableState;
      var rs = stream._readableState;
      var readable = opts.readable || opts.readable !== false && stream.readable;
      var writable = opts.writable || opts.writable !== false && stream.writable;
      var cancelled = false;
      var onlegacyfinish = function() {
        if (!stream.writable) onfinish();
      };
      var onfinish = function() {
        writable = false;
        if (!readable) callback.call(stream);
      };
      var onend = function() {
        readable = false;
        if (!writable) callback.call(stream);
      };
      var onexit = function(exitCode) {
        callback.call(stream, exitCode ? new Error("exited with error code: " + exitCode) : null);
      };
      var onerror = function(err2) {
        callback.call(stream, err2);
      };
      var onclose = function() {
        process.nextTick(onclosenexttick);
      };
      var onclosenexttick = function() {
        if (cancelled) return;
        if (readable && !(rs && (rs.ended && !rs.destroyed))) return callback.call(stream, new Error("premature close"));
        if (writable && !(ws2 && (ws2.ended && !ws2.destroyed))) return callback.call(stream, new Error("premature close"));
      };
      var onrequest = function() {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        stream.on("abort", onclose);
        if (stream.req) onrequest();
        else stream.on("request", onrequest);
      } else if (writable && !ws2) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      if (isChildProcess(stream)) stream.on("exit", onexit);
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (opts.error !== false) stream.on("error", onerror);
      stream.on("close", onclose);
      return function() {
        cancelled = true;
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req) stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("exit", onexit);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
    };
    module.exports = eos;
  }
});

// node_modules/pump/index.js
var require_pump = __commonJS({
  "node_modules/pump/index.js"(exports, module) {
    var once3 = require_once();
    var eos = require_end_of_stream();
    var fs3;
    try {
      fs3 = require_fs();
    } catch (e) {
    }
    var noop5 = function() {
    };
    var ancient = /^v?\.0/.test(process.version);
    var isFn = function(fn) {
      return typeof fn === "function";
    };
    var isFS = function(stream) {
      if (!ancient) return false;
      if (!fs3) return false;
      return (stream instanceof (fs3.ReadStream || noop5) || stream instanceof (fs3.WriteStream || noop5)) && isFn(stream.close);
    };
    var isRequest = function(stream) {
      return stream.setHeader && isFn(stream.abort);
    };
    var destroyer = function(stream, reading, writing, callback) {
      callback = once3(callback);
      var closed = false;
      stream.on("close", function() {
        closed = true;
      });
      eos(stream, { readable: reading, writable: writing }, function(err2) {
        if (err2) return callback(err2);
        closed = true;
        callback();
      });
      var destroyed = false;
      return function(err2) {
        if (closed) return;
        if (destroyed) return;
        destroyed = true;
        if (isFS(stream)) return stream.close(noop5);
        if (isRequest(stream)) return stream.abort();
        if (isFn(stream.destroy)) return stream.destroy();
        callback(err2 || new Error("stream was destroyed"));
      };
    };
    var call = function(fn) {
      fn();
    };
    var pipe = function(from, to) {
      return from.pipe(to);
    };
    var pump2 = function() {
      var streams = Array.prototype.slice.call(arguments);
      var callback = isFn(streams[streams.length - 1] || noop5) && streams.pop() || noop5;
      if (Array.isArray(streams[0])) streams = streams[0];
      if (streams.length < 2) throw new Error("pump requires two streams per minimum");
      var error;
      var destroys = streams.map(function(stream, i) {
        var reading = i < streams.length - 1;
        var writing = i > 0;
        return destroyer(stream, reading, writing, function(err2) {
          if (!error) error = err2;
          if (err2) destroys.forEach(call);
          if (reading) return;
          destroys.forEach(call);
          callback(error);
        });
      });
      return streams.reduce(pipe);
    };
    module.exports = pump2;
  }
});

// node_modules/range-parser/index.js
var require_range_parser = __commonJS({
  "node_modules/range-parser/index.js"(exports, module) {
    "use strict";
    module.exports = rangeParser2;
    function rangeParser2(size, str, options) {
      if (typeof str !== "string") {
        throw new TypeError("argument str must be a string");
      }
      var index = str.indexOf("=");
      if (index === -1) {
        return -2;
      }
      var arr = str.slice(index + 1).split(",");
      var ranges = [];
      ranges.type = str.slice(0, index);
      for (var i = 0; i < arr.length; i++) {
        var range = arr[i].split("-");
        var start = parseInt(range[0], 10);
        var end = parseInt(range[1], 10);
        if (isNaN(start)) {
          start = size - end;
          end = size - 1;
        } else if (isNaN(end)) {
          end = size - 1;
        }
        if (end > size - 1) {
          end = size - 1;
        }
        if (isNaN(start) || isNaN(end) || start > end || start < 0) {
          continue;
        }
        ranges.push({
          start,
          end
        });
      }
      if (ranges.length < 1) {
        return -1;
      }
      return options && options.combine ? combineRanges(ranges) : ranges;
    }
    function combineRanges(ranges) {
      var ordered = ranges.map(mapWithIndex).sort(sortByRangeStart);
      for (var j = 0, i = 1; i < ordered.length; i++) {
        var range = ordered[i];
        var current = ordered[j];
        if (range.start > current.end + 1) {
          ordered[++j] = range;
        } else if (range.end > current.end) {
          current.end = range.end;
          current.index = Math.min(current.index, range.index);
        }
      }
      ordered.length = j + 1;
      var combined = ordered.sort(sortByRangeIndex).map(mapWithoutIndex);
      combined.type = ranges.type;
      return combined;
    }
    function mapWithIndex(range, index) {
      return {
        start: range.start,
        end: range.end,
        index
      };
    }
    function mapWithoutIndex(range) {
      return {
        start: range.start,
        end: range.end
      };
    }
    function sortByRangeIndex(a, b) {
      return a.index - b.index;
    }
    function sortByRangeStart(a, b) {
      return a.start - b.start;
    }
  }
});

// node_modules/webtorrent/index.js
var import_events10 = __toESM(require_events());
var import_path4 = __toESM(require_path());

// node_modules/create-torrent/index.js
var import_block_iterator = __toESM(require_block_iterator());
var import_piece_length = __toESM(require_piece_length());
var import_path = __toESM(require_path());
var import_is_file = __toESM(require_is_file());

// node_modules/junk/index.js
var ignoreList = [
  // # All
  "^npm-debug\\.log$",
  // Error log for npm
  "^\\..*\\.swp$",
  // Swap file for vim state
  // # macOS
  "^\\.DS_Store$",
  // Stores custom folder attributes
  "^\\.AppleDouble$",
  // Stores additional file resources
  "^\\.LSOverride$",
  // Contains the absolute path to the app to be used
  "^Icon\\r$",
  // Custom Finder icon: http://superuser.com/questions/298785/icon-file-on-os-x-desktop
  "^\\._.*",
  // Thumbnail
  "^\\.Spotlight-V100(?:$|\\/)",
  // Directory that might appear on external disk
  "\\.Trashes",
  // File that might appear on external disk
  "^__MACOSX$",
  // Resource fork
  // # Linux
  "~$",
  // Backup file
  // # Windows
  "^Thumbs\\.db$",
  // Image file cache
  "^ehthumbs\\.db$",
  // Folder config file
  "^[Dd]esktop\\.ini$",
  // Stores custom folder attributes
  "@eaDir$"
  // Synology Diskstation "hidden" folder where the server stores thumbnails
];
var junkRegex = new RegExp(ignoreList.join("|"));
function isJunk(filename) {
  return junkRegex.test(filename);
}

// node_modules/create-torrent/index.js
var import_join_async_iterator = __toESM(require_join_async_iterator());
var import_run_parallel = __toESM(require_run_parallel());
var import_queue_microtask = __toESM(require_queue_microtask());

// node_modules/fast-readable-async-iterator/index.js
if (typeof ReadableStream !== "undefined") {
  if (!ReadableStream.prototype[Symbol.asyncIterator]) {
    ReadableStream.prototype[Symbol.asyncIterator] = function({ preventCancel } = {}) {
      const reader = this.getReader();
      const stream = this;
      let last = reader.read();
      return {
        next() {
          const temp = last;
          last = reader.read();
          return temp;
        },
        async return(value) {
          await last;
          reader.releaseLock();
          if (!preventCancel) stream.cancel();
          return { done: true, value };
        },
        async throw(err2) {
          await this.return();
          throw err2;
        },
        [Symbol.asyncIterator]() {
          return this;
        }
      };
    };
  }
  if (!ReadableStream.prototype.getIterator) {
    ReadableStream.prototype.getIterator = function({ preventCancel } = {}) {
      return this[Symbol.asyncIterator]({ preventCancel });
    };
  }
}

// node_modules/create-torrent/index.js
var import_get_files = __toESM(require_get_files());
var announceList = [
  ["udp://tracker.leechers-paradise.org:6969"],
  ["udp://tracker.coppersurfer.tk:6969"],
  ["udp://tracker.opentrackr.org:1337"],
  ["udp://explodie.org:6969"],
  ["udp://tracker.empire-js.us:1337"],
  ["wss://tracker.btorrent.xyz"],
  ["wss://tracker.openwebtorrent.com"],
  ["wss://tracker.webtorrent.dev"]
];
function createTorrent(input, opts, cb) {
  if (typeof opts === "function") [opts, cb] = [cb, opts];
  opts = opts ? Object.assign({}, opts) : {};
  _parseInput(input, opts, (err2, files, singleFileTorrent) => {
    if (err2) return cb(err2);
    opts.singleFileTorrent = singleFileTorrent;
    onFiles(files, opts, cb);
  });
}
function parseInput(input, opts, cb) {
  if (typeof opts === "function") [opts, cb] = [cb, opts];
  opts = opts ? Object.assign({}, opts) : {};
  _parseInput(input, opts, cb);
}
var pathSymbol = Symbol("itemPath");
function _parseInput(input, opts, cb) {
  if (isFileList(input)) input = Array.from(input);
  if (!Array.isArray(input)) input = [input];
  if (input.length === 0) throw new Error("invalid input type");
  input.forEach((item) => {
    if (item == null) throw new Error(`invalid input type: ${item}`);
  });
  input = input.map((item) => {
    if (isBlob(item) && typeof item.path === "string" && typeof import_get_files.default === "function") return item.path;
    return item;
  });
  if (input.length === 1 && typeof input[0] !== "string" && !input[0].name) input[0].name = opts.name;
  let commonPrefix = null;
  input.forEach((item, i) => {
    if (typeof item === "string") {
      return;
    }
    let path4 = item.fullPath || item.name;
    if (!path4) {
      path4 = `Unknown File ${i + 1}`;
      item.unknownName = true;
    }
    item[pathSymbol] = path4.split("/");
    if (!item[pathSymbol][0]) {
      item[pathSymbol].shift();
    }
    if (item[pathSymbol].length < 2) {
      commonPrefix = null;
    } else if (i === 0 && input.length > 1) {
      commonPrefix = item[pathSymbol][0];
    } else if (item[pathSymbol][0] !== commonPrefix) {
      commonPrefix = null;
    }
  });
  const filterJunkFiles = opts.filterJunkFiles === void 0 ? true : opts.filterJunkFiles;
  if (filterJunkFiles) {
    input = input.filter((item) => {
      if (typeof item === "string") {
        return true;
      }
      return !isJunkPath(item[pathSymbol]);
    });
  }
  if (commonPrefix) {
    input.forEach((item) => {
      const pathless = (ArrayBuffer.isView(item) || isReadable(item)) && !item[pathSymbol];
      if (typeof item === "string" || pathless) return;
      item[pathSymbol].shift();
    });
  }
  if (!opts.name && commonPrefix) {
    opts.name = commonPrefix;
  }
  if (!opts.name) {
    input.some((item) => {
      if (typeof item === "string") {
        opts.name = import_path.default.basename(item);
        return true;
      } else if (!item.unknownName) {
        opts.name = item[pathSymbol][item[pathSymbol].length - 1];
        return true;
      }
      return false;
    });
  }
  if (!opts.name) {
    opts.name = `Unnamed Torrent ${Date.now()}`;
  }
  const numPaths = input.reduce((sum, item) => sum + Number(typeof item === "string"), 0);
  let isSingleFileTorrent = input.length === 1;
  if (input.length === 1 && typeof input[0] === "string") {
    if (typeof import_get_files.default !== "function") {
      throw new Error("filesystem paths do not work in the browser");
    }
    (0, import_is_file.default)(input[0], (err2, pathIsFile) => {
      if (err2) return cb(err2);
      isSingleFileTorrent = pathIsFile;
      processInput();
    });
  } else {
    (0, import_queue_microtask.default)(processInput);
  }
  function processInput() {
    (0, import_run_parallel.default)(input.map((item) => (cb2) => {
      const file = {};
      if (isBlob(item)) {
        file.getStream = item.stream();
        file.length = item.size;
      } else if (ArrayBuffer.isView(item)) {
        file.getStream = [item];
        file.length = item.length;
      } else if (isReadable(item)) {
        file.getStream = getStreamStream(item, file);
        file.length = 0;
      } else if (typeof item === "string") {
        if (typeof import_get_files.default !== "function") {
          throw new Error("filesystem paths do not work in the browser");
        }
        const keepRoot = numPaths > 1 || isSingleFileTorrent;
        (0, import_get_files.default)(item, keepRoot, cb2);
        return;
      } else {
        throw new Error("invalid input type");
      }
      file.path = item[pathSymbol];
      cb2(null, file);
    }), (err2, files) => {
      if (err2) return cb(err2);
      files = files.flat();
      cb(null, files, isSingleFileTorrent);
    });
  }
}
var MAX_OUTSTANDING_HASHES = 5;
async function getPieceList(files, pieceLength, estimatedTorrentLength, opts, cb) {
  const pieces = [];
  let length = 0;
  let hashedLength = 0;
  const streams = files.map((file) => file.getStream);
  const onProgress = opts.onProgress;
  let remainingHashes = 0;
  let pieceNum = 0;
  let ended = false;
  const iterator = (0, import_block_iterator.default)((0, import_join_async_iterator.default)(streams), pieceLength, { zeroPadding: false });
  try {
    for await (const chunk of iterator) {
      await new Promise((resolve) => {
        length += chunk.length;
        const i = pieceNum;
        ++pieceNum;
        if (++remainingHashes < MAX_OUTSTANDING_HASHES) resolve();
        hash(chunk, "hex").then((hash2) => {
          pieces[i] = hash2;
          --remainingHashes;
          hashedLength += chunk.length;
          if (onProgress) onProgress(hashedLength, estimatedTorrentLength);
          resolve();
          if (ended && remainingHashes === 0) cb(null, hex2arr(pieces.join("")), length);
        });
      });
    }
    if (remainingHashes === 0) return cb(null, hex2arr(pieces.join("")), length);
    ended = true;
  } catch (err2) {
    cb(err2);
  }
}
function onFiles(files, opts, cb) {
  let _announceList = opts.announceList;
  if (!_announceList) {
    if (typeof opts.announce === "string") _announceList = [[opts.announce]];
    else if (Array.isArray(opts.announce)) {
      _announceList = opts.announce.map((u) => [u]);
    }
  }
  if (!_announceList) _announceList = [];
  if (globalThis.WEBTORRENT_ANNOUNCE) {
    if (typeof globalThis.WEBTORRENT_ANNOUNCE === "string") {
      _announceList.push([[globalThis.WEBTORRENT_ANNOUNCE]]);
    } else if (Array.isArray(globalThis.WEBTORRENT_ANNOUNCE)) {
      _announceList = _announceList.concat(globalThis.WEBTORRENT_ANNOUNCE.map((u) => [u]));
    }
  }
  if (opts.announce === void 0 && opts.announceList === void 0) {
    _announceList = _announceList.concat(announceList);
  }
  if (typeof opts.urlList === "string") opts.urlList = [opts.urlList];
  const torrent = {
    info: {
      name: opts.name
    },
    "creation date": Math.ceil((Number(opts.creationDate) || Date.now()) / 1e3),
    encoding: "UTF-8"
  };
  if (_announceList.length !== 0) {
    torrent.announce = _announceList[0][0];
    torrent["announce-list"] = _announceList;
  }
  if (opts.comment !== void 0) torrent.comment = opts.comment;
  if (opts.createdBy !== void 0) torrent["created by"] = opts.createdBy;
  if (opts.private !== void 0) torrent.info.private = Number(opts.private);
  if (opts.info !== void 0) Object.assign(torrent.info, opts.info);
  if (opts.sslCert !== void 0) torrent.info["ssl-cert"] = opts.sslCert;
  if (opts.urlList !== void 0) torrent["url-list"] = opts.urlList;
  const estimatedTorrentLength = files.reduce(sumLength, 0);
  const pieceLength = opts.pieceLength || (0, import_piece_length.default)(estimatedTorrentLength);
  torrent.info["piece length"] = pieceLength;
  getPieceList(
    files,
    pieceLength,
    estimatedTorrentLength,
    opts,
    (err2, pieces, torrentLength) => {
      if (err2) return cb(err2);
      torrent.info.pieces = pieces;
      files.forEach((file) => {
        delete file.getStream;
      });
      if (opts.singleFileTorrent) {
        torrent.info.length = torrentLength;
      } else {
        torrent.info.files = files;
      }
      cb(null, bencode_default.encode(torrent));
    }
  );
}
function isJunkPath(path4) {
  const filename = path4[path4.length - 1];
  return filename[0] === "." && isJunk(filename);
}
function sumLength(sum, file) {
  return sum + file.length;
}
function isBlob(obj) {
  return typeof Blob !== "undefined" && obj instanceof Blob;
}
function isFileList(obj) {
  return typeof FileList !== "undefined" && obj instanceof FileList;
}
function isReadable(obj) {
  return typeof obj === "object" && obj != null && typeof obj.pipe === "function";
}
async function* getStreamStream(readable, file) {
  for await (const chunk of readable) {
    file.length += chunk.length;
    yield chunk;
  }
}
var create_torrent_default = createTorrent;

// node_modules/webtorrent/index.js
var import_debug12 = __toESM(require_browser());
var import_bittorrent_dht2 = __toESM(require_bittorrent_dht());
var import_load_ip_set = __toESM(require_load_ip_set());
var import_run_parallel5 = __toESM(require_run_parallel());

// node_modules/parse-torrent/index.js
var import_fs = __toESM(require_fs());

// node_modules/cross-fetch-ponyfill/browser.js
var Blob2 = self.Blob;
var File = self.File;
var FormData = self.FormData;
var Headers = self.Headers;
var Request = self.Request;
var Response2 = self.Response;
var AbortController2 = self.AbortController;
var AbortSignal2 = self.AbortSignal;
var fetch2 = self.fetch || (() => {
  throw new Error("global fetch is not available!");
});
var browser_default = fetch2;

// node_modules/@thaunknown/thirty-two/lib/thirty-two/index.js
var byteTable = [
  255,
  255,
  26,
  27,
  28,
  29,
  30,
  31,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  22,
  23,
  24,
  25,
  255,
  255,
  255,
  255,
  255,
  255,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  22,
  23,
  24,
  25,
  255,
  255,
  255,
  255,
  255
];
var decode = function(encoded) {
  if (!ArrayBuffer.isView(encoded) && typeof encoded !== "string") {
    throw new TypeError("base32.decode only takes Buffer or string as parameter");
  }
  let shiftIndex = 0;
  let plainDigit = 0;
  let plainChar;
  let plainPos = 0;
  if (!ArrayBuffer.isView(encoded)) {
    encoded = text2arr(encoded);
  }
  const decoded = new Uint8Array(Math.ceil(encoded.length * 5 / 8));
  for (let i = 0; i < encoded.length; i++) {
    if (encoded[i] === 61) {
      break;
    }
    const encodedByte = encoded[i] - 48;
    if (encodedByte < byteTable.length) {
      plainDigit = byteTable[encodedByte];
      if (shiftIndex <= 3) {
        shiftIndex = (shiftIndex + 5) % 8;
        if (shiftIndex === 0) {
          plainChar |= plainDigit;
          decoded[plainPos] = plainChar;
          plainPos++;
          plainChar = 0;
        } else {
          plainChar |= 255 & plainDigit << 8 - shiftIndex;
        }
      } else {
        shiftIndex = (shiftIndex + 5) % 8;
        plainChar |= 255 & plainDigit >>> shiftIndex;
        decoded[plainPos] = plainChar;
        plainPos++;
        plainChar = 255 & plainDigit << 8 - shiftIndex;
      }
    } else {
      throw new Error("Invalid input - it is not base32 encoded string");
    }
  }
  return decoded.subarray(0, plainPos);
};

// node_modules/bep53-range/index.js
function composeRange(range) {
  return range.reduce((acc, cur, idx, arr) => {
    if (idx === 0 || cur !== arr[idx - 1] + 1) acc.push([]);
    acc[acc.length - 1].push(cur);
    return acc;
  }, []).map((cur) => {
    return cur.length > 1 ? `${cur[0]}-${cur[cur.length - 1]}` : `${cur[0]}`;
  });
}
function parseRange(range) {
  const generateRange = (start, end = start) => Array.from({ length: end - start + 1 }, (cur, idx) => idx + start);
  return range.reduce((acc, cur, idx, arr) => {
    const r = cur.split("-").map((cur2) => parseInt(cur2));
    return acc.concat(generateRange(...r));
  }, []);
}

// node_modules/magnet-uri/index.js
function magnetURIDecode(uri) {
  const result = {};
  const data = uri.split("magnet:?")[1];
  const params = data && data.length >= 0 ? data.split("&") : [];
  params.forEach((param) => {
    const keyval = param.split("=");
    if (keyval.length !== 2) return;
    const key = keyval[0];
    let val = keyval[1];
    if (key === "dn") val = decodeURIComponent(val).replace(/\+/g, " ");
    if (key === "tr" || key === "xs" || key === "as" || key === "ws") {
      val = decodeURIComponent(val);
    }
    if (key === "kt") val = decodeURIComponent(val).split("+");
    if (key === "ix") val = Number(val);
    if (key === "so") val = parseRange(decodeURIComponent(val).split(","));
    if (result[key]) {
      if (!Array.isArray(result[key])) {
        result[key] = [result[key]];
      }
      result[key].push(val);
    } else {
      result[key] = val;
    }
  });
  let m;
  if (result.xt) {
    const xts = Array.isArray(result.xt) ? result.xt : [result.xt];
    xts.forEach((xt) => {
      if (m = xt.match(/^urn:btih:(.{40})/)) {
        result.infoHash = m[1].toLowerCase();
      } else if (m = xt.match(/^urn:btih:(.{32})/)) {
        result.infoHash = arr2hex(decode(m[1]));
      } else if (m = xt.match(/^urn:btmh:1220(.{64})/)) {
        result.infoHashV2 = m[1].toLowerCase();
      }
    });
  }
  if (result.xs) {
    const xss = Array.isArray(result.xs) ? result.xs : [result.xs];
    xss.forEach((xs) => {
      if (m = xs.match(/^urn:btpk:(.{64})/)) {
        result.publicKey = m[1].toLowerCase();
      }
    });
  }
  if (result.infoHash) result.infoHashBuffer = hex2arr(result.infoHash);
  if (result.infoHashV2) result.infoHashV2Buffer = hex2arr(result.infoHashV2);
  if (result.publicKey) result.publicKeyBuffer = hex2arr(result.publicKey);
  if (result.dn) result.name = result.dn;
  if (result.kt) result.keywords = result.kt;
  result.announce = [];
  if (typeof result.tr === "string" || Array.isArray(result.tr)) {
    result.announce = result.announce.concat(result.tr);
  }
  result.urlList = [];
  if (typeof result.as === "string" || Array.isArray(result.as)) {
    result.urlList = result.urlList.concat(result.as);
  }
  if (typeof result.ws === "string" || Array.isArray(result.ws)) {
    result.urlList = result.urlList.concat(result.ws);
  }
  result.peerAddresses = [];
  if (typeof result["x.pe"] === "string" || Array.isArray(result["x.pe"])) {
    result.peerAddresses = result.peerAddresses.concat(result["x.pe"]);
  }
  result.announce = Array.from(new Set(result.announce));
  result.urlList = Array.from(new Set(result.urlList));
  result.peerAddresses = Array.from(new Set(result.peerAddresses));
  return result;
}
function magnetURIEncode(obj) {
  obj = Object.assign({}, obj);
  let xts = /* @__PURE__ */ new Set();
  if (obj.xt && typeof obj.xt === "string") xts.add(obj.xt);
  if (obj.xt && Array.isArray(obj.xt)) xts = new Set(obj.xt);
  if (obj.infoHashBuffer) xts.add(`urn:btih:${arr2hex(obj.infoHashBuffer)}`);
  if (obj.infoHash) xts.add(`urn:btih:${obj.infoHash}`);
  if (obj.infoHashV2Buffer) xts.add(obj.xt = `urn:btmh:1220${arr2hex(obj.infoHashV2Buffer)}`);
  if (obj.infoHashV2) xts.add(`urn:btmh:1220${obj.infoHashV2}`);
  const xtsDeduped = Array.from(xts);
  if (xtsDeduped.length === 1) obj.xt = xtsDeduped[0];
  if (xtsDeduped.length > 1) obj.xt = xtsDeduped;
  if (obj.publicKeyBuffer) obj.xs = `urn:btpk:${arr2hex(obj.publicKeyBuffer)}`;
  if (obj.publicKey) obj.xs = `urn:btpk:${obj.publicKey}`;
  if (obj.name) obj.dn = obj.name;
  if (obj.keywords) obj.kt = obj.keywords;
  if (obj.announce) obj.tr = obj.announce;
  if (obj.urlList) {
    obj.ws = obj.urlList;
    delete obj.as;
  }
  if (obj.peerAddresses) obj["x.pe"] = obj.peerAddresses;
  let result = "magnet:?";
  Object.keys(obj).filter((key) => key.length === 2 || key === "x.pe").forEach((key, i) => {
    const values = Array.isArray(obj[key]) ? obj[key] : [obj[key]];
    values.forEach((val, j) => {
      if ((i > 0 || j > 0) && (key !== "kt" && key !== "so" || j === 0)) result += "&";
      if (key === "dn") val = encodeURIComponent(val).replace(/%20/g, "+");
      if (key === "tr" || key === "as" || key === "ws") {
        val = encodeURIComponent(val);
      }
      if (key === "xs" && !val.startsWith("urn:btpk:")) {
        val = encodeURIComponent(val);
      }
      if (key === "kt") val = encodeURIComponent(val);
      if (key === "so") return;
      if (key === "kt" && j > 0) result += `+${val}`;
      else result += `${key}=${val}`;
    });
    if (key === "so") result += `${key}=${composeRange(values)}`;
  });
  return result;
}
var magnet_uri_default = magnetURIDecode;

// node_modules/parse-torrent/index.js
var import_path2 = __toESM(require_path());
var import_queue_microtask2 = __toESM(require_queue_microtask());
async function parseTorrent(torrentId) {
  if (typeof torrentId === "string" && /^(stream-)?magnet:/.test(torrentId)) {
    const torrentObj = magnet_uri_default(torrentId);
    if (!torrentObj.infoHash) {
      throw new Error("Invalid torrent identifier");
    }
    return torrentObj;
  } else if (typeof torrentId === "string" && (/^[a-f0-9]{40}$/i.test(torrentId) || /^[a-z2-7]{32}$/i.test(torrentId))) {
    return magnet_uri_default(`magnet:?xt=urn:btih:${torrentId}`);
  } else if (ArrayBuffer.isView(torrentId) && torrentId.length === 20) {
    return magnet_uri_default(`magnet:?xt=urn:btih:${arr2hex(torrentId)}`);
  } else if (ArrayBuffer.isView(torrentId)) {
    return await decodeTorrentFile(torrentId);
  } else if (torrentId && torrentId.infoHash) {
    torrentId.infoHash = torrentId.infoHash.toLowerCase();
    if (!torrentId.announce) torrentId.announce = [];
    if (typeof torrentId.announce === "string") {
      torrentId.announce = [torrentId.announce];
    }
    if (!torrentId.urlList) torrentId.urlList = [];
    return torrentId;
  } else {
    throw new Error("Invalid torrent identifier");
  }
}
async function parseTorrentRemote(torrentId, opts, cb) {
  if (typeof opts === "function") return parseTorrentRemote(torrentId, {}, opts);
  if (typeof cb !== "function") throw new Error("second argument must be a Function");
  let parsedTorrent;
  try {
    parsedTorrent = await parseTorrent(torrentId);
  } catch (err2) {
  }
  if (parsedTorrent && parsedTorrent.infoHash) {
    (0, import_queue_microtask2.default)(() => {
      cb(null, parsedTorrent);
    });
  } else if (isBlob2(torrentId)) {
    try {
      const torrentBuf = new Uint8Array(await torrentId.arrayBuffer());
      parseOrThrow(torrentBuf);
    } catch (err2) {
      return cb(new Error(`Error converting Blob: ${err2.message}`));
    }
  } else if (/^https?:/.test(torrentId)) {
    try {
      const res = await browser_default(torrentId, {
        headers: { "user-agent": "WebTorrent (https://webtorrent.io)" },
        signal: AbortSignal.timeout(30 * 1e3),
        ...opts
      });
      const torrentBuf = new Uint8Array(await res.arrayBuffer());
      parseOrThrow(torrentBuf);
    } catch (err2) {
      return cb(new Error(`Error downloading torrent: ${err2.message}`));
    }
  } else if (typeof import_fs.default.readFile === "function" && typeof torrentId === "string") {
    import_fs.default.readFile(torrentId, (err2, torrentBuf) => {
      if (err2) return cb(new Error("Invalid torrent identifier"));
      parseOrThrow(torrentBuf);
    });
  } else {
    (0, import_queue_microtask2.default)(() => {
      cb(new Error("Invalid torrent identifier"));
    });
  }
  async function parseOrThrow(torrentBuf) {
    try {
      parsedTorrent = await parseTorrent(torrentBuf);
    } catch (err2) {
      return cb(err2);
    }
    if (parsedTorrent && parsedTorrent.infoHash) cb(null, parsedTorrent);
    else cb(new Error("Invalid torrent identifier"));
  }
}
async function decodeTorrentFile(torrent) {
  if (ArrayBuffer.isView(torrent)) {
    torrent = bencode_default.decode(torrent);
  }
  ensure(torrent.info, "info");
  ensure(torrent.info["name.utf-8"] || torrent.info.name, "info.name");
  ensure(torrent.info["piece length"], "info['piece length']");
  ensure(torrent.info.pieces, "info.pieces");
  if (torrent.info.files) {
    torrent.info.files.forEach((file) => {
      ensure(typeof file.length === "number", "info.files[0].length");
      ensure(file["path.utf-8"] || file.path, "info.files[0].path");
    });
  } else {
    ensure(typeof torrent.info.length === "number", "info.length");
  }
  const result = {
    info: torrent.info,
    infoBuffer: bencode_default.encode(torrent.info),
    name: arr2text(torrent.info["name.utf-8"] || torrent.info.name),
    announce: []
  };
  result.infoHashBuffer = await hash(result.infoBuffer);
  result.infoHash = arr2hex(result.infoHashBuffer);
  if (torrent.info.private !== void 0) result.private = !!torrent.info.private;
  if (torrent["creation date"]) result.created = new Date(torrent["creation date"] * 1e3);
  if (torrent["created by"]) result.createdBy = arr2text(torrent["created by"]);
  if (ArrayBuffer.isView(torrent.comment)) result.comment = arr2text(torrent.comment);
  if (Array.isArray(torrent["announce-list"]) && torrent["announce-list"].length > 0) {
    torrent["announce-list"].forEach((urls) => {
      urls.forEach((url) => {
        result.announce.push(arr2text(url));
      });
    });
  } else if (torrent.announce) {
    result.announce.push(arr2text(torrent.announce));
  }
  if (ArrayBuffer.isView(torrent["url-list"])) {
    torrent["url-list"] = torrent["url-list"].length > 0 ? [torrent["url-list"]] : [];
  }
  result.urlList = (torrent["url-list"] || []).map((url) => arr2text(url));
  result.announce = Array.from(new Set(result.announce));
  result.urlList = Array.from(new Set(result.urlList));
  const files = torrent.info.files || [torrent.info];
  result.files = files.map((file, i) => {
    const parts = [].concat(result.name, file["path.utf-8"] || file.path || []).map((p) => ArrayBuffer.isView(p) ? arr2text(p) : p);
    return {
      path: import_path2.default.join.apply(null, [import_path2.default.sep].concat(parts)).slice(1),
      name: parts[parts.length - 1],
      length: file.length,
      offset: files.slice(0, i).reduce(sumLength2, 0)
    };
  });
  result.length = files.reduce(sumLength2, 0);
  const lastFile = result.files[result.files.length - 1];
  result.pieceLength = torrent.info["piece length"];
  result.lastPieceLength = (lastFile.offset + lastFile.length) % result.pieceLength || result.pieceLength;
  result.pieces = splitPieces(torrent.info.pieces);
  return result;
}
function encodeTorrentFile(parsed) {
  const torrent = {
    info: parsed.info
  };
  torrent["announce-list"] = (parsed.announce || []).map((url) => {
    if (!torrent.announce) torrent.announce = url;
    url = text2arr(url);
    return [url];
  });
  torrent["url-list"] = parsed.urlList || [];
  if (parsed.private !== void 0) {
    torrent.private = Number(parsed.private);
  }
  if (parsed.created) {
    torrent["creation date"] = parsed.created.getTime() / 1e3 | 0;
  }
  if (parsed.createdBy) {
    torrent["created by"] = parsed.createdBy;
  }
  if (parsed.comment) {
    torrent.comment = parsed.comment;
  }
  return bencode_default.encode(torrent);
}
function isBlob2(obj) {
  return typeof Blob !== "undefined" && obj instanceof Blob;
}
function sumLength2(sum, file) {
  return sum + file.length;
}
function splitPieces(buf) {
  const pieces = [];
  for (let i = 0; i < buf.length; i += 20) {
    pieces.push(arr2hex(buf.slice(i, i + 20)));
  }
  return pieces;
}
function ensure(bool, fieldName) {
  if (!bool) throw new Error(`Torrent is missing required field: ${fieldName}`);
}
var parse_torrent_default = parseTorrent;
var toMagnetURI = magnetURIEncode;

// node_modules/@thaunknown/simple-peer/lite.js
var import_debug = __toESM(require_browser());

// node_modules/webrtc-polyfill/browser.js
var browser_exports = {};
__export(browser_exports, {
  MediaStream: () => MediaStream,
  MediaStreamTrack: () => MediaStreamTrack,
  MediaStreamTrackEvent: () => MediaStreamTrackEvent,
  RTCCertificate: () => RTCCertificate,
  RTCDataChannel: () => RTCDataChannel,
  RTCDataChannelEvent: () => RTCDataChannelEvent,
  RTCDtlsTransport: () => RTCDtlsTransport,
  RTCError: () => RTCError,
  RTCErrorEvent: () => RTCErrorEvent,
  RTCIceCandidate: () => RTCIceCandidate,
  RTCIceTransport: () => RTCIceTransport,
  RTCPeerConnection: () => RTCPeerConnection,
  RTCPeerConnectionIceEvent: () => RTCPeerConnectionIceEvent,
  RTCRtpReceiver: () => RTCRtpReceiver,
  RTCRtpSender: () => RTCRtpSender,
  RTCRtpTransceiver: () => RTCRtpTransceiver,
  RTCSctpTransport: () => RTCSctpTransport,
  RTCSessionDescription: () => RTCSessionDescription,
  RTCTrackEvent: () => RTCTrackEvent,
  default: () => browser_exports
});
var scope = typeof window !== "undefined" ? window : self;
var RTCPeerConnection = scope.RTCPeerConnection || scope.mozRTCPeerConnection || scope.webkitRTCPeerConnection;
var RTCSessionDescription = scope.RTCSessionDescription || scope.mozRTCSessionDescription || scope.webkitRTCSessionDescription;
var RTCIceCandidate = scope.RTCIceCandidate || scope.mozRTCIceCandidate || scope.webkitRTCIceCandidate;
var RTCIceTransport = scope.RTCIceTransport;
var RTCDataChannel = scope.RTCDataChannel;
var RTCSctpTransport = scope.RTCSctpTransport;
var RTCDtlsTransport = scope.RTCDtlsTransport;
var RTCCertificate = scope.RTCCertificate;
var MediaStream = scope.MediaStream;
var MediaStreamTrack = scope.MediaStreamTrack;
var MediaStreamTrackEvent = scope.MediaStreamTrackEvent;
var RTCPeerConnectionIceEvent = scope.RTCPeerConnectionIceEvent;
var RTCDataChannelEvent = scope.RTCDataChannelEvent;
var RTCTrackEvent = scope.RTCTrackEvent;
var RTCError = scope.RTCError;
var RTCErrorEvent = scope.RTCErrorEvent;
var RTCRtpTransceiver = scope.RTCRtpTransceiver;
var RTCRtpReceiver = scope.RTCRtpReceiver;
var RTCRtpSender = scope.RTCRtpSender;

// node_modules/@thaunknown/simple-peer/lite.js
var import_streamx = __toESM(require_streamx());
var import_err_code = __toESM(require_err_code());
var Debug = (0, import_debug.default)("simple-peer");
var MAX_BUFFERED_AMOUNT = 64 * 1024;
var ICECOMPLETE_TIMEOUT = 5 * 1e3;
var CHANNEL_CLOSING_TIMEOUT = 5 * 1e3;
function filterTrickle(sdp) {
  return sdp.replace(/a=ice-options:trickle\s\n/g, "");
}
function warn(message) {
  console.warn(message);
}
var Peer2 = class _Peer extends import_streamx.Duplex {
  constructor(opts) {
    opts = Object.assign({
      allowHalfOpen: false
    }, opts);
    super(opts);
    /** @type {RTCPeerConnection} */
    __publicField(this, "_pc");
    this.__objectMode = !!opts.objectMode;
    this._id = arr2hex(randomBytes(4)).slice(0, 7);
    this._debug("new peer %o", opts);
    this.channelName = opts.initiator ? opts.channelName || arr2hex(randomBytes(20)) : null;
    this.initiator = opts.initiator || false;
    this.channelConfig = opts.channelConfig || _Peer.channelConfig;
    this.channelNegotiated = this.channelConfig.negotiated;
    this.config = Object.assign({}, _Peer.config, opts.config);
    this.offerOptions = opts.offerOptions || {};
    this.answerOptions = opts.answerOptions || {};
    this.sdpTransform = opts.sdpTransform || ((sdp) => sdp);
    this.trickle = opts.trickle !== void 0 ? opts.trickle : true;
    this.allowHalfTrickle = opts.allowHalfTrickle !== void 0 ? opts.allowHalfTrickle : false;
    this.iceCompleteTimeout = opts.iceCompleteTimeout || ICECOMPLETE_TIMEOUT;
    this._destroying = false;
    this._connected = false;
    this.remoteAddress = void 0;
    this.remoteFamily = void 0;
    this.remotePort = void 0;
    this.localAddress = void 0;
    this.localFamily = void 0;
    this.localPort = void 0;
    if (!RTCPeerConnection) {
      if (typeof window === "undefined") {
        throw (0, import_err_code.default)(new Error("No WebRTC support: Specify `opts.wrtc` option in this environment"), "ERR_WEBRTC_SUPPORT");
      } else {
        throw (0, import_err_code.default)(new Error("No WebRTC support: Not a supported browser"), "ERR_WEBRTC_SUPPORT");
      }
    }
    this._pcReady = false;
    this._channelReady = false;
    this._iceComplete = false;
    this._iceCompleteTimer = null;
    this._channel = null;
    this._pendingCandidates = [];
    this._isNegotiating = false;
    this._firstNegotiation = true;
    this._batchedNegotiation = false;
    this._queuedNegotiation = false;
    this._sendersAwaitingStable = [];
    this._closingInterval = null;
    this._remoteTracks = [];
    this._remoteStreams = [];
    this._chunk = null;
    this._cb = null;
    this._interval = null;
    try {
      this._pc = new RTCPeerConnection(this.config);
    } catch (err2) {
      this.__destroy((0, import_err_code.default)(err2, "ERR_PC_CONSTRUCTOR"));
      return;
    }
    this._isReactNativeWebrtc = typeof this._pc._peerConnectionId === "number";
    this._pc.oniceconnectionstatechange = () => {
      this._onIceStateChange();
    };
    this._pc.onicegatheringstatechange = () => {
      this._onIceStateChange();
    };
    this._pc.onconnectionstatechange = () => {
      this._onConnectionStateChange();
    };
    this._pc.onsignalingstatechange = () => {
      this._onSignalingStateChange();
    };
    this._pc.onicecandidate = (event) => {
      this._onIceCandidate(event);
    };
    if (typeof this._pc.peerIdentity === "object") {
      this._pc.peerIdentity.catch((err2) => {
        this.__destroy((0, import_err_code.default)(err2, "ERR_PC_PEER_IDENTITY"));
      });
    }
    if (this.initiator || this.channelNegotiated) {
      this._setupData({
        channel: this._pc.createDataChannel(this.channelName, this.channelConfig)
      });
    } else {
      this._pc.ondatachannel = (event) => {
        this._setupData(event);
      };
    }
    this._debug("initial negotiation");
    this._needsNegotiation();
    this._onFinishBound = () => {
      this._onFinish();
    };
    this.once("finish", this._onFinishBound);
  }
  get bufferSize() {
    return this._channel && this._channel.bufferedAmount || 0;
  }
  // HACK: it's possible channel.readyState is "closing" before peer.destroy() fires
  // https://bugs.chromium.org/p/chromium/issues/detail?id=882743
  get connected() {
    return this._connected && this._channel.readyState === "open";
  }
  address() {
    return { port: this.localPort, family: this.localFamily, address: this.localAddress };
  }
  signal(data) {
    if (this._destroying) return;
    if (this.destroyed) throw (0, import_err_code.default)(new Error("cannot signal after peer is destroyed"), "ERR_DESTROYED");
    if (typeof data === "string") {
      try {
        data = JSON.parse(data);
      } catch (err2) {
        data = {};
      }
    }
    this._debug("signal()");
    if (data.renegotiate && this.initiator) {
      this._debug("got request to renegotiate");
      this._needsNegotiation();
    }
    if (data.transceiverRequest && this.initiator) {
      this._debug("got request for transceiver");
      this.addTransceiver(data.transceiverRequest.kind, data.transceiverRequest.init);
    }
    if (data.candidate) {
      if (this._pc.remoteDescription && this._pc.remoteDescription.type) {
        this._addIceCandidate(data.candidate);
      } else {
        this._pendingCandidates.push(data.candidate);
      }
    }
    if (data.sdp) {
      this._pc.setRemoteDescription(new RTCSessionDescription(data)).then(() => {
        if (this.destroyed) return;
        this._pendingCandidates.forEach((candidate) => {
          this._addIceCandidate(candidate);
        });
        this._pendingCandidates = [];
        if (this._pc.remoteDescription.type === "offer") this._createAnswer();
      }).catch((err2) => {
        this.__destroy((0, import_err_code.default)(err2, "ERR_SET_REMOTE_DESCRIPTION"));
      });
    }
    if (!data.sdp && !data.candidate && !data.renegotiate && !data.transceiverRequest) {
      this.__destroy((0, import_err_code.default)(new Error("signal() called with invalid signal data"), "ERR_SIGNALING"));
    }
  }
  _addIceCandidate(candidate) {
    const iceCandidateObj = new RTCIceCandidate(candidate);
    this._pc.addIceCandidate(iceCandidateObj).catch((err2) => {
      if (!iceCandidateObj.address || iceCandidateObj.address.endsWith(".local")) {
        warn("Ignoring unsupported ICE candidate.");
      } else {
        this.__destroy((0, import_err_code.default)(err2, "ERR_ADD_ICE_CANDIDATE"));
      }
    });
  }
  /**
   * Send text/binary data to the remote peer.
   * @param {ArrayBufferView|ArrayBuffer|Uint8Array|string|Blob} chunk
   */
  send(chunk) {
    if (this._destroying) return;
    if (this.destroyed) throw (0, import_err_code.default)(new Error("cannot send after peer is destroyed"), "ERR_DESTROYED");
    this._channel.send(chunk);
  }
  _needsNegotiation() {
    this._debug("_needsNegotiation");
    if (this._batchedNegotiation) return;
    this._batchedNegotiation = true;
    queueMicrotask(() => {
      this._batchedNegotiation = false;
      if (this.initiator || !this._firstNegotiation) {
        this._debug("starting batched negotiation");
        this.negotiate();
      } else {
        this._debug("non-initiator initial negotiation request discarded");
      }
      this._firstNegotiation = false;
    });
  }
  negotiate() {
    if (this._destroying) return;
    if (this.destroyed) throw (0, import_err_code.default)(new Error("cannot negotiate after peer is destroyed"), "ERR_DESTROYED");
    if (this.initiator) {
      if (this._isNegotiating) {
        this._queuedNegotiation = true;
        this._debug("already negotiating, queueing");
      } else {
        this._debug("start negotiation");
        setTimeout(() => {
          this._createOffer();
        }, 0);
      }
    } else {
      if (this._isNegotiating) {
        this._queuedNegotiation = true;
        this._debug("already negotiating, queueing");
      } else {
        this._debug("requesting negotiation from initiator");
        this.emit("signal", {
          // request initiator to renegotiate
          type: "renegotiate",
          renegotiate: true
        });
      }
    }
    this._isNegotiating = true;
  }
  _final(cb) {
    if (!this._readableState.ended) this.push(null);
    cb(null);
  }
  __destroy(err2) {
    this.end();
    this._destroy(() => {
    }, err2);
  }
  _destroy(cb, err2) {
    if (this.destroyed || this._destroying) return;
    this._destroying = true;
    this._debug("destroying (error: %s)", err2 && (err2.message || err2));
    setTimeout(() => {
      this._connected = false;
      this._pcReady = false;
      this._channelReady = false;
      this._remoteTracks = null;
      this._remoteStreams = null;
      this._senderMap = null;
      clearInterval(this._closingInterval);
      this._closingInterval = null;
      clearInterval(this._interval);
      this._interval = null;
      this._chunk = null;
      this._cb = null;
      if (this._onFinishBound) this.removeListener("finish", this._onFinishBound);
      this._onFinishBound = null;
      if (this._channel) {
        try {
          this._channel.close();
        } catch (err3) {
        }
        this._channel.onmessage = null;
        this._channel.onopen = null;
        this._channel.onclose = null;
        this._channel.onerror = null;
      }
      if (this._pc) {
        try {
          this._pc.close();
        } catch (err3) {
        }
        this._pc.oniceconnectionstatechange = null;
        this._pc.onicegatheringstatechange = null;
        this._pc.onsignalingstatechange = null;
        this._pc.onicecandidate = null;
        this._pc.ontrack = null;
        this._pc.ondatachannel = null;
      }
      this._pc = null;
      this._channel = null;
      if (err2) this.emit("error", err2);
      cb();
    }, 0);
  }
  _setupData(event) {
    if (!event.channel) {
      return this.__destroy((0, import_err_code.default)(new Error("Data channel event is missing `channel` property"), "ERR_DATA_CHANNEL"));
    }
    this._channel = event.channel;
    this._channel.binaryType = "arraybuffer";
    if (typeof this._channel.bufferedAmountLowThreshold === "number") {
      this._channel.bufferedAmountLowThreshold = MAX_BUFFERED_AMOUNT;
    }
    this.channelName = this._channel.label;
    this._channel.onmessage = (event2) => {
      this._onChannelMessage(event2);
    };
    this._channel.onbufferedamountlow = () => {
      this._onChannelBufferedAmountLow();
    };
    this._channel.onopen = () => {
      this._onChannelOpen();
    };
    this._channel.onclose = () => {
      this._onChannelClose();
    };
    this._channel.onerror = (event2) => {
      const err2 = event2.error instanceof Error ? event2.error : new Error(`Datachannel error: ${event2.message} ${event2.filename}:${event2.lineno}:${event2.colno}`);
      this.__destroy((0, import_err_code.default)(err2, "ERR_DATA_CHANNEL"));
    };
    let isClosing = false;
    this._closingInterval = setInterval(() => {
      if (this._channel && this._channel.readyState === "closing") {
        if (isClosing) this._onChannelClose();
        isClosing = true;
      } else {
        isClosing = false;
      }
    }, CHANNEL_CLOSING_TIMEOUT);
  }
  _write(chunk, cb) {
    if (this.destroyed) return cb((0, import_err_code.default)(new Error("cannot write after peer is destroyed"), "ERR_DATA_CHANNEL"));
    if (this._connected) {
      try {
        this.send(chunk);
      } catch (err2) {
        return this.__destroy((0, import_err_code.default)(err2, "ERR_DATA_CHANNEL"));
      }
      if (this._channel.bufferedAmount > MAX_BUFFERED_AMOUNT) {
        this._debug("start backpressure: bufferedAmount %d", this._channel.bufferedAmount);
        this._cb = cb;
      } else {
        cb(null);
      }
    } else {
      this._debug("write before connect");
      this._chunk = chunk;
      this._cb = cb;
    }
  }
  // When stream finishes writing, close socket. Half open connections are not
  // supported.
  _onFinish() {
    if (this.destroyed) return;
    const destroySoon = () => {
      setTimeout(() => this.__destroy(), 1e3);
    };
    if (this._connected) {
      destroySoon();
    } else {
      this.once("connect", destroySoon);
    }
  }
  _startIceCompleteTimeout() {
    if (this.destroyed) return;
    if (this._iceCompleteTimer) return;
    this._debug("started iceComplete timeout");
    this._iceCompleteTimer = setTimeout(() => {
      if (!this._iceComplete) {
        this._iceComplete = true;
        this._debug("iceComplete timeout completed");
        this.emit("iceTimeout");
        this.emit("_iceComplete");
      }
    }, this.iceCompleteTimeout);
  }
  _createOffer() {
    if (this.destroyed) return;
    this._pc.createOffer(this.offerOptions).then((offer) => {
      if (this.destroyed) return;
      if (!this.trickle && !this.allowHalfTrickle) offer.sdp = filterTrickle(offer.sdp);
      offer.sdp = this.sdpTransform(offer.sdp);
      const sendOffer = () => {
        if (this.destroyed) return;
        const signal = this._pc.localDescription || offer;
        this._debug("signal");
        this.emit("signal", {
          type: signal.type,
          sdp: signal.sdp
        });
      };
      const onSuccess = () => {
        this._debug("createOffer success");
        if (this.destroyed) return;
        if (this.trickle || this._iceComplete) sendOffer();
        else this.once("_iceComplete", sendOffer);
      };
      const onError = (err2) => {
        this.__destroy((0, import_err_code.default)(err2, "ERR_SET_LOCAL_DESCRIPTION"));
      };
      this._pc.setLocalDescription(offer).then(onSuccess).catch(onError);
    }).catch((err2) => {
      this.__destroy((0, import_err_code.default)(err2, "ERR_CREATE_OFFER"));
    });
  }
  _createAnswer() {
    if (this.destroyed) return;
    this._pc.createAnswer(this.answerOptions).then((answer) => {
      if (this.destroyed) return;
      if (!this.trickle && !this.allowHalfTrickle) answer.sdp = filterTrickle(answer.sdp);
      answer.sdp = this.sdpTransform(answer.sdp);
      const sendAnswer = () => {
        var _a3;
        if (this.destroyed) return;
        const signal = this._pc.localDescription || answer;
        this._debug("signal");
        this.emit("signal", {
          type: signal.type,
          sdp: signal.sdp
        });
        if (!this.initiator) (_a3 = this._requestMissingTransceivers) == null ? void 0 : _a3.call(this);
      };
      const onSuccess = () => {
        if (this.destroyed) return;
        if (this.trickle || this._iceComplete) sendAnswer();
        else this.once("_iceComplete", sendAnswer);
      };
      const onError = (err2) => {
        this.__destroy((0, import_err_code.default)(err2, "ERR_SET_LOCAL_DESCRIPTION"));
      };
      this._pc.setLocalDescription(answer).then(onSuccess).catch(onError);
    }).catch((err2) => {
      this.__destroy((0, import_err_code.default)(err2, "ERR_CREATE_ANSWER"));
    });
  }
  _onConnectionStateChange() {
    if (this.destroyed || this._destroying) return;
    if (this._pc.connectionState === "failed") {
      this.__destroy((0, import_err_code.default)(new Error("Connection failed."), "ERR_CONNECTION_FAILURE"));
    }
  }
  _onIceStateChange() {
    if (this.destroyed) return;
    const iceConnectionState = this._pc.iceConnectionState;
    const iceGatheringState = this._pc.iceGatheringState;
    this._debug(
      "iceStateChange (connection: %s) (gathering: %s)",
      iceConnectionState,
      iceGatheringState
    );
    this.emit("iceStateChange", iceConnectionState, iceGatheringState);
    if (iceConnectionState === "connected" || iceConnectionState === "completed") {
      this._pcReady = true;
      this._maybeReady();
    }
    if (iceConnectionState === "failed") {
      this.__destroy((0, import_err_code.default)(new Error("Ice connection failed."), "ERR_ICE_CONNECTION_FAILURE"));
    }
    if (iceConnectionState === "closed") {
      this.__destroy((0, import_err_code.default)(new Error("Ice connection closed."), "ERR_ICE_CONNECTION_CLOSED"));
    }
  }
  getStats(cb) {
    const flattenValues = (report) => {
      if (Object.prototype.toString.call(report.values) === "[object Array]") {
        report.values.forEach((value) => {
          Object.assign(report, value);
        });
      }
      return report;
    };
    if (this._pc.getStats.length === 0 || this._isReactNativeWebrtc) {
      this._pc.getStats().then((res) => {
        const reports = [];
        res.forEach((report) => {
          reports.push(flattenValues(report));
        });
        cb(null, reports);
      }, (err2) => cb(err2));
    } else if (this._pc.getStats.length > 0) {
      this._pc.getStats((res) => {
        if (this.destroyed) return;
        const reports = [];
        res.result().forEach((result) => {
          const report = {};
          result.names().forEach((name) => {
            report[name] = result.stat(name);
          });
          report.id = result.id;
          report.type = result.type;
          report.timestamp = result.timestamp;
          reports.push(flattenValues(report));
        });
        cb(null, reports);
      }, (err2) => cb(err2));
    } else {
      cb(null, []);
    }
  }
  _maybeReady() {
    this._debug("maybeReady pc %s channel %s", this._pcReady, this._channelReady);
    if (this._connected || this._connecting || !this._pcReady || !this._channelReady) return;
    this._connecting = true;
    const findCandidatePair = () => {
      if (this.destroyed || this._destroying) return;
      this.getStats((err2, items) => {
        if (this.destroyed || this._destroying) return;
        if (err2) items = [];
        const remoteCandidates = {};
        const localCandidates = {};
        const candidatePairs = {};
        let foundSelectedCandidatePair = false;
        items.forEach((item) => {
          if (item.type === "remotecandidate" || item.type === "remote-candidate") {
            remoteCandidates[item.id] = item;
          }
          if (item.type === "localcandidate" || item.type === "local-candidate") {
            localCandidates[item.id] = item;
          }
          if (item.type === "candidatepair" || item.type === "candidate-pair") {
            candidatePairs[item.id] = item;
          }
        });
        const setSelectedCandidatePair = (selectedCandidatePair) => {
          foundSelectedCandidatePair = true;
          let local = localCandidates[selectedCandidatePair.localCandidateId];
          if (local && (local.ip || local.address)) {
            this.localAddress = local.ip || local.address;
            this.localPort = Number(local.port);
          } else if (local && local.ipAddress) {
            this.localAddress = local.ipAddress;
            this.localPort = Number(local.portNumber);
          } else if (typeof selectedCandidatePair.googLocalAddress === "string") {
            local = selectedCandidatePair.googLocalAddress.split(":");
            this.localAddress = local[0];
            this.localPort = Number(local[1]);
          }
          if (this.localAddress) {
            this.localFamily = this.localAddress.includes(":") ? "IPv6" : "IPv4";
          }
          let remote = remoteCandidates[selectedCandidatePair.remoteCandidateId];
          if (remote && (remote.ip || remote.address)) {
            this.remoteAddress = remote.ip || remote.address;
            this.remotePort = Number(remote.port);
          } else if (remote && remote.ipAddress) {
            this.remoteAddress = remote.ipAddress;
            this.remotePort = Number(remote.portNumber);
          } else if (typeof selectedCandidatePair.googRemoteAddress === "string") {
            remote = selectedCandidatePair.googRemoteAddress.split(":");
            this.remoteAddress = remote[0];
            this.remotePort = Number(remote[1]);
          }
          if (this.remoteAddress) {
            this.remoteFamily = this.remoteAddress.includes(":") ? "IPv6" : "IPv4";
          }
          this._debug(
            "connect local: %s:%s remote: %s:%s",
            this.localAddress,
            this.localPort,
            this.remoteAddress,
            this.remotePort
          );
        };
        items.forEach((item) => {
          if (item.type === "transport" && item.selectedCandidatePairId) {
            setSelectedCandidatePair(candidatePairs[item.selectedCandidatePairId]);
          }
          if (item.type === "googCandidatePair" && item.googActiveConnection === "true" || (item.type === "candidatepair" || item.type === "candidate-pair") && item.selected) {
            setSelectedCandidatePair(item);
          }
        });
        if (!foundSelectedCandidatePair && (!Object.keys(candidatePairs).length || Object.keys(localCandidates).length)) {
          setTimeout(findCandidatePair, 100);
          return;
        } else {
          this._connecting = false;
          this._connected = true;
        }
        if (this._chunk) {
          try {
            this.send(this._chunk);
          } catch (err3) {
            return this.__destroy((0, import_err_code.default)(err3, "ERR_DATA_CHANNEL"));
          }
          this._chunk = null;
          this._debug('sent chunk from "write before connect"');
          const cb = this._cb;
          this._cb = null;
          cb(null);
        }
        if (typeof this._channel.bufferedAmountLowThreshold !== "number") {
          this._interval = setInterval(() => this._onInterval(), 150);
          if (this._interval.unref) this._interval.unref();
        }
        this._debug("connect");
        this.emit("connect");
      });
    };
    findCandidatePair();
  }
  _onInterval() {
    if (!this._cb || !this._channel || this._channel.bufferedAmount > MAX_BUFFERED_AMOUNT) {
      return;
    }
    this._onChannelBufferedAmountLow();
  }
  _onSignalingStateChange() {
    if (this.destroyed) return;
    if (this._pc.signalingState === "stable") {
      this._isNegotiating = false;
      this._debug("flushing sender queue", this._sendersAwaitingStable);
      this._sendersAwaitingStable.forEach((sender) => {
        this._pc.removeTrack(sender);
        this._queuedNegotiation = true;
      });
      this._sendersAwaitingStable = [];
      if (this._queuedNegotiation) {
        this._debug("flushing negotiation queue");
        this._queuedNegotiation = false;
        this._needsNegotiation();
      } else {
        this._debug("negotiated");
        this.emit("negotiated");
      }
    }
    this._debug("signalingStateChange %s", this._pc.signalingState);
    this.emit("signalingStateChange", this._pc.signalingState);
  }
  _onIceCandidate(event) {
    if (this.destroyed) return;
    if (event.candidate && this.trickle) {
      this.emit("signal", {
        type: "candidate",
        candidate: {
          candidate: event.candidate.candidate,
          sdpMLineIndex: event.candidate.sdpMLineIndex,
          sdpMid: event.candidate.sdpMid
        }
      });
    } else if (!event.candidate && !this._iceComplete) {
      this._iceComplete = true;
      this.emit("_iceComplete");
    }
    if (event.candidate) {
      this._startIceCompleteTimeout();
    }
  }
  _onChannelMessage(event) {
    if (this.destroyed) return;
    let data = event.data;
    if (data instanceof ArrayBuffer) {
      data = new Uint8Array(data);
    } else if (this.__objectMode === false) {
      data = text2arr(data);
    }
    this.push(data);
  }
  _onChannelBufferedAmountLow() {
    if (this.destroyed || !this._cb) return;
    this._debug("ending backpressure: bufferedAmount %d", this._channel.bufferedAmount);
    const cb = this._cb;
    this._cb = null;
    cb(null);
  }
  _onChannelOpen() {
    if (this._connected || this.destroyed) return;
    this._debug("on channel open");
    this._channelReady = true;
    this._maybeReady();
  }
  _onChannelClose() {
    if (this.destroyed) return;
    this._debug("on channel close");
    this.__destroy();
  }
  _debug() {
    const args = [].slice.call(arguments);
    args[0] = "[" + this._id + "] " + args[0];
    Debug.apply(null, args);
  }
};
Peer2.WEBRTC_SUPPORT = !!RTCPeerConnection;
Peer2.config = {
  iceServers: [
    {
      urls: [
        "stun:stun.l.google.com:19302",
        "stun:global.stun.twilio.com:3478"
      ]
    }
  ],
  sdpSemantics: "unified-plan"
};
Peer2.channelConfig = {};
var lite_default = Peer2;

// node_modules/webtorrent/index.js
var import_queue_microtask7 = __toESM(require_queue_microtask());
var import_throughput2 = __toESM(require_throughput());
var import_speed_limiter = __toESM(require_speed_limiter());
var import_nat_api = __toESM(require_nat_api());
var import_conn_pool = __toESM(require_conn_pool());

// node_modules/webtorrent/lib/torrent.js
var import_events9 = __toESM(require_events(), 1);
var import_fs2 = __toESM(require_fs(), 1);
var import_net = __toESM(require_net(), 1);
var import_os = __toESM(require_os(), 1);
var import_path3 = __toESM(require_path(), 1);

// node_modules/addr-to-ip-port/index.js
var ADDR_RE = /^\[?([^\]]+)]?:(\d+)$/;
var cache = /* @__PURE__ */ new Map();
function addrToIPPort(addr) {
  if (cache.size === 1e5) cache.clear();
  if (!cache.has(addr)) {
    const m = ADDR_RE.exec(addr);
    if (!m) throw new Error(`invalid addr: ${addr}`);
    cache.set(addr, [m[1], Number(m[2])]);
  }
  return cache.get(addr);
}

// node_modules/webtorrent/lib/torrent.js
var import_cache_chunk_store = __toESM(require_cache_chunk_store(), 1);

// node_modules/chunk-store-iterator/index.js
var import_block_iterator2 = __toESM(require_block_iterator());
async function* chunkStoreRead(store, opts = {}) {
  if (store == null ? void 0 : store[Symbol.asyncIterator]) {
    yield* store[Symbol.asyncIterator](opts.offset);
    return;
  }
  if (!(store == null ? void 0 : store.get)) throw new Error("First argument must be an abstract-chunk-store compliant store");
  const chunkLength = opts.chunkLength || store.chunkLength;
  if (!chunkLength) throw new Error("missing required `chunkLength` property");
  let length = opts.length || store.length;
  if (!Number.isFinite(length)) throw new Error("missing required `length` property");
  const offset = opts.offset || 0;
  const get = (i, length2, offset2) => new Promise((resolve, reject) => {
    store.get(i, { offset: offset2, length: length2 }, (err2, chunk) => {
      if (err2) reject(err2);
      resolve(chunk);
    });
  });
  let index = Math.floor(offset / chunkLength);
  const chunkOffset = offset % chunkLength;
  if (offset) {
    const target = Math.min(length, chunkLength - chunkOffset);
    length -= target;
    yield get(index++, target, chunkOffset);
  }
  for (let remainingLength = length; remainingLength > 0; ++index, remainingLength -= chunkLength) {
    yield get(index, Math.min(remainingLength, chunkLength));
  }
}
async function chunkStoreWrite(store, stream, opts = {}) {
  if (!(store == null ? void 0 : store.put)) throw new Error("First argument must be an abstract-chunk-store compliant store");
  const chunkLength = opts.chunkLength || store.chunkLength;
  if (!chunkLength) throw new Error("missing required `chunkLength` property");
  const storeMaxOutstandingPuts = opts.storeMaxOutstandingPuts || 16;
  let outstandingPuts = 0;
  let index = 0;
  let cb = () => {
  };
  let ended = false;
  for await (const chunk of (0, import_block_iterator2.default)(stream, chunkLength, { zeroPadding: opts.zeroPadding || false })) {
    await new Promise((resolve) => {
      if (outstandingPuts++ <= storeMaxOutstandingPuts) resolve();
      store.put(index++, chunk, (err2) => {
        if (err2) throw err2;
        --outstandingPuts;
        resolve();
        if (ended && outstandingPuts === 0) cb();
      });
    });
  }
  if (outstandingPuts === 0) return;
  ended = new Promise((resolve) => {
    cb = resolve;
  });
  await ended;
}

// node_modules/webtorrent/lib/torrent.js
var import_cpus = __toESM(require_browser2(), 1);
var import_debug11 = __toESM(require_browser(), 1);

// node_modules/torrent-discovery/index.js
var import_debug6 = __toESM(require_browser());

// node_modules/bittorrent-dht/client.js
var import_events = __toESM(require_events(), 1);
var import_debug2 = __toESM(require_browser(), 1);
var import_k_bucket = __toESM(require_k_bucket(), 1);
var import_k_rpc = __toESM(require_k_rpc(), 1);
var import_last_one_wins = __toESM(require_last_one_wins(), 1);
var import_lru = __toESM(require_lru(), 1);
var import_randombytes = __toESM(require_browser3(), 1);
var import_record_cache = __toESM(require_record_cache(), 1);
var import_crypto = __toESM(require_crypto(), 1);
var debug2 = (0, import_debug2.default)("bittorrent-dht");
var ROTATE_INTERVAL = 5 * 60 * 1e3;
var BUCKET_OUTDATED_TIMESPAN = 15 * 60 * 1e3;
var DHT = class extends import_events.EventEmitter {
  constructor(opts = {}) {
    super();
    this._tables = new import_lru.default({ maxAge: ROTATE_INTERVAL, max: opts.maxTables || 1e3 });
    this._values = new import_lru.default(opts.maxValues || 1e3);
    this._peers = (0, import_record_cache.default)({
      maxAge: opts.maxAge || 0,
      maxSize: opts.maxPeers || 1e4
    });
    this._secrets = null;
    this._hash = opts.hash || sha1;
    this._hashLength = this._hash(Buffer.from("")).length;
    this._rpc = opts.krpc || (0, import_k_rpc.default)(Object.assign({ idLength: this._hashLength }, opts));
    this._rpc.on("query", onquery);
    this._rpc.on("node", onnode);
    this._rpc.on("warning", onwarning);
    this._rpc.on("error", onerror);
    this._rpc.on("listening", onlistening);
    this._rotateSecrets();
    this._verify = opts.verify || null;
    this._host = opts.host || null;
    this._interval = setInterval(rotateSecrets, ROTATE_INTERVAL);
    this._runningBucketCheck = false;
    this._bucketCheckTimeout = null;
    this._bucketOutdatedTimeSpan = opts.timeBucketOutdated || BUCKET_OUTDATED_TIMESPAN;
    this.listening = false;
    this.destroyed = false;
    this.nodeId = this._rpc.id;
    this.nodes = this._rpc.nodes;
    const onping = (0, import_last_one_wins.default)(ping);
    this._rpc.on("ping", (older, swap) => {
      onping({ older, swap });
    });
    process.nextTick(bootstrap);
    this._debug("new DHT %s", this.nodeId);
    const self2 = this;
    function ping(opts2, cb) {
      const older = opts2.older;
      const swap = opts2.swap;
      self2._debug("received ping", older);
      self2._checkNodes(older, false, (_, deadNode) => {
        if (deadNode) {
          self2._debug("swaping dead node with newer", deadNode);
          swap(deadNode);
          return cb();
        }
        self2._debug("no node added, all other nodes ok");
        cb();
      });
    }
    function onlistening() {
      self2.listening = true;
      self2._debug("listening %d", self2.address().port);
      self2.updateBucketTimestamp();
      self2._setBucketCheckInterval();
      self2.emit("listening");
    }
    function onquery(query, peer) {
      self2._onquery(query, peer);
    }
    function rotateSecrets() {
      self2._rotateSecrets();
    }
    function bootstrap() {
      if (!self2.destroyed) self2._bootstrap(opts.bootstrap !== false);
    }
    function onwarning(err2) {
      self2.emit("warning", err2);
    }
    function onerror(err2) {
      self2.emit("error", err2);
    }
    function onnode(node) {
      self2.emit("node", node);
    }
  }
  _setBucketCheckInterval() {
    const self2 = this;
    const interval = 1 * 60 * 1e3;
    this._runningBucketCheck = true;
    queueNext();
    function checkBucket() {
      const diff = Date.now() - self2._rpc.nodes.metadata.lastChange;
      if (diff < self2._bucketOutdatedTimeSpan) return queueNext();
      self2._pingAll(() => {
        if (self2.destroyed) return;
        if (self2.nodes.toArray().length < 1) {
          self2._bootstrap(true);
        }
        queueNext();
      });
    }
    function queueNext() {
      if (!self2._runningBucketCheck || self2.destroyed) return;
      const nextTimeout = Math.floor(Math.random() * interval + interval / 2);
      self2._bucketCheckTimeout = setTimeout(checkBucket, nextTimeout);
    }
  }
  _pingAll(cb) {
    this._checkAndRemoveNodes(this.nodes.toArray(), cb);
  }
  removeBucketCheckInterval() {
    this._runningBucketCheck = false;
    clearTimeout(this._bucketCheckTimeout);
  }
  updateBucketTimestamp() {
    this._rpc.nodes.metadata.lastChange = Date.now();
  }
  _checkAndRemoveNodes(nodes, cb) {
    const self2 = this;
    this._checkNodes(nodes, true, (_, node) => {
      if (node) self2.removeNode(node.id);
      cb(null, node);
    });
  }
  _checkNodes(nodes, force, cb) {
    const self2 = this;
    test(nodes);
    function test(acc) {
      let current = null;
      while (acc.length) {
        current = acc.pop();
        if (!current.id || force) break;
        if (Date.now() - (current.seen || 0) > 1e4) break;
        current = null;
      }
      if (!current) return cb(null);
      self2._sendPing(current, (err2) => {
        if (!err2) {
          self2.updateBucketTimestamp();
          return test(acc);
        }
        cb(null, current);
      });
    }
  }
  addNode(node) {
    const self2 = this;
    if (node.id) {
      node.id = toBuffer(node.id);
      const old = !!this._rpc.nodes.get(node.id);
      this._rpc.nodes.add(node);
      if (!old) {
        this.emit("node", node);
        this.updateBucketTimestamp();
      }
      return;
    }
    this._sendPing(node, (_, node2) => {
      if (node2) self2.addNode(node2);
    });
  }
  removeNode(id) {
    this._rpc.nodes.remove(toBuffer(id));
  }
  _sendPing(node, cb) {
    const self2 = this;
    const expectedId = node.id;
    this._rpc.query(node, { q: "ping" }, (err2, pong, node2) => {
      if (err2) return cb(err2);
      if (!pong.r || !pong.r.id || !Buffer.isBuffer(pong.r.id) || pong.r.id.length !== self2._hashLength) {
        return cb(new Error("Bad reply"));
      }
      if (Buffer.isBuffer(expectedId) && !expectedId.equals(pong.r.id)) {
        return cb(new Error("Unexpected node id"));
      }
      self2.updateBucketTimestamp();
      cb(null, {
        id: pong.r.id,
        host: node2.host || node2.address,
        port: node2.port
      });
    });
  }
  toJSON() {
    const self2 = this;
    const values = {};
    Object.keys(this._values.cache).forEach((key) => {
      const value = self2._values.cache[key].value;
      values[key] = {
        v: value.v.toString("hex"),
        id: value.id.toString("hex")
      };
      if (value.seq != null) values[key].seq = value.seq;
      if (value.sig != null) values[key].sig = value.sig.toString("hex");
      if (value.k != null) values[key].k = value.k.toString("hex");
    });
    return {
      nodes: this._rpc.nodes.toArray().map(toNode),
      values
    };
  }
  put(opts, cb) {
    if (Buffer.isBuffer(opts) || typeof opts === "string") opts = { v: opts };
    const isMutable = !!opts.k;
    if (opts.v === void 0) {
      throw new Error("opts.v not given");
    }
    if (opts.v.length >= 1e3) {
      throw new Error("v must be less than 1000 bytes in put()");
    }
    if (isMutable && opts.cas !== void 0 && typeof opts.cas !== "number") {
      throw new Error("opts.cas must be an integer if provided");
    }
    if (isMutable && opts.k.length !== 32) {
      throw new Error("opts.k ed25519 public key must be 32 bytes");
    }
    if (isMutable && typeof opts.sign !== "function" && !Buffer.isBuffer(opts.sig)) {
      throw new Error("opts.sign function or options.sig signature is required for mutable put");
    }
    if (isMutable && opts.salt && opts.salt.length > 64) {
      throw new Error("opts.salt is > 64 bytes long");
    }
    if (isMutable && opts.seq === void 0) {
      throw new Error("opts.seq not provided for a mutable update");
    }
    if (isMutable && typeof opts.seq !== "number") {
      throw new Error("opts.seq not an integer");
    }
    return this._put(opts, cb);
  }
  _put(opts, cb) {
    if (!cb) cb = noop;
    const isMutable = !!opts.k;
    const v = typeof opts.v === "string" ? Buffer.from(opts.v) : opts.v;
    const key = isMutable ? this._hash(opts.salt ? Buffer.concat([opts.k, opts.salt]) : opts.k) : this._hash(bencode_default.encode(v));
    const table = this._tables.get(key.toString("hex"));
    if (!table) return this._preput(key, opts, cb);
    const message = {
      q: "put",
      a: {
        id: this._rpc.id,
        token: null,
        // queryAll sets this
        v
      }
    };
    if (isMutable) {
      if (typeof opts.cas === "number") message.a.cas = opts.cas;
      if (opts.salt) message.a.salt = opts.salt;
      message.a.k = opts.k;
      message.a.seq = opts.seq;
      if (typeof opts.sign === "function") message.a.sig = opts.sign(encodeSigData(message.a));
      else if (Buffer.isBuffer(opts.sig)) message.a.sig = opts.sig;
    } else {
      this._values.set(key.toString("hex"), message.a);
    }
    this._rpc.queryAll(table.closest(key), message, null, (err2, n) => {
      if (err2) return cb(err2, key, n);
      cb(null, key, n);
    });
    return key;
  }
  _preput(key, opts, cb) {
    const self2 = this;
    this._closest(key, {
      q: "get",
      a: {
        id: this._rpc.id,
        target: key
      }
    }, null, (err2, n) => {
      if (err2) return cb(err2);
      self2.put(opts, cb);
    });
    return key;
  }
  get(key, opts, cb) {
    key = toBuffer(key);
    if (typeof opts === "function") {
      cb = opts;
      opts = null;
    }
    if (!opts) opts = {};
    const verify = opts.verify || this._verify;
    const hash2 = this._hash;
    let value = this._values.get(key.toString("hex")) || null;
    if (value && opts.cache !== false) {
      value = createGetResponse(this._rpc.id, null, value);
      return process.nextTick(done);
    }
    this._closest(key, {
      q: "get",
      a: {
        id: this._rpc.id,
        target: key
      }
    }, onreply, done);
    function done(err2) {
      if (err2) return cb(err2);
      cb(null, value);
    }
    function onreply(message) {
      const r = message.r;
      if (!r || !r.v) return true;
      const isMutable = r.k || r.sig;
      if (opts.salt) r.salt = Buffer.from(opts.salt);
      if (isMutable) {
        if (!verify || !r.sig || !r.k) return true;
        if (!verify(r.sig, encodeSigData(r), r.k)) return true;
        if (hash2(r.salt ? Buffer.concat([r.k, r.salt]) : r.k).equals(key)) {
          if (!value || r.seq > value.seq) value = r;
        }
      } else {
        if (hash2(bencode_default.encode(r.v)).equals(key)) {
          value = r;
          return false;
        }
      }
      return true;
    }
  }
  announce(infoHash, port, cb) {
    if (typeof port === "function") return this.announce(infoHash, 0, port);
    infoHash = toBuffer(infoHash);
    if (!cb) cb = noop;
    const table = this._tables.get(infoHash.toString("hex"));
    if (!table) return this._preannounce(infoHash, port, cb);
    if (this._host) {
      const dhtPort = this.listening ? this.address().port : 0;
      this._addPeer(
        { host: this._host, port: port || dhtPort },
        infoHash,
        { host: this._host, port: dhtPort }
      );
    }
    const message = {
      q: "announce_peer",
      a: {
        id: this._rpc.id,
        token: null,
        // queryAll sets this
        info_hash: infoHash,
        port,
        implied_port: port ? 0 : 1
      }
    };
    this._debug("announce %s %d", infoHash, port);
    this._rpc.queryAll(table.closest(infoHash), message, null, cb);
  }
  _preannounce(infoHash, port, cb) {
    const self2 = this;
    this.lookup(infoHash, (err2) => {
      if (self2.destroyed) return cb(new Error("dht is destroyed"));
      if (err2) return cb(err2);
      self2.announce(infoHash, port, cb);
    });
  }
  lookup(infoHash, cb) {
    infoHash = toBuffer(infoHash);
    if (!cb) cb = noop;
    const self2 = this;
    let aborted = false;
    this._debug("lookup %s", infoHash);
    process.nextTick(emit);
    this._closest(infoHash, {
      q: "get_peers",
      a: {
        id: this._rpc.id,
        info_hash: infoHash
      }
    }, onreply, cb);
    function emit(values, from) {
      if (!values) values = self2._peers.get(infoHash.toString("hex"), 100);
      const peers = decodePeers(values);
      for (let i = 0; i < peers.length; i++) {
        self2.emit("peer", peers[i], infoHash, from || null);
      }
    }
    function onreply(message, node) {
      if (aborted) return false;
      if (message.r.values) emit(message.r.values, node);
    }
    return function abort() {
      aborted = true;
    };
  }
  address() {
    return this._rpc.address();
  }
  // listen([port], [address], [onlistening])
  listen(...args) {
    this._rpc.bind(...args);
  }
  destroy(cb) {
    if (this.destroyed) {
      if (cb) process.nextTick(cb);
      return;
    }
    this.destroyed = true;
    const self2 = this;
    clearInterval(this._interval);
    this.removeBucketCheckInterval();
    this._peers.destroy();
    this._debug("destroying");
    this._rpc.destroy(() => {
      self2.emit("close");
      if (cb) cb();
    });
  }
  _onquery(query, peer) {
    if (query.q === void 0 || query.q === null) return;
    const q = query.q.toString();
    this._debug("received %s query from %s:%d", q, peer.address, peer.port);
    if (!query.a) return;
    switch (q) {
      case "ping":
        return this._rpc.response(peer, query, { id: this._rpc.id });
      case "find_node":
        return this._onfindnode(query, peer);
      case "get_peers":
        return this._ongetpeers(query, peer);
      case "announce_peer":
        return this._onannouncepeer(query, peer);
      case "get":
        return this._onget(query, peer);
      case "put":
        return this._onput(query, peer);
    }
  }
  _onfindnode(query, peer) {
    const target = query.a.target;
    if (!target) return this._rpc.error(peer, query, [203, "`find_node` missing required `a.target` field"]);
    this.emit("find_node", target);
    const nodes = this._rpc.nodes.closest(target);
    this._rpc.response(peer, query, { id: this._rpc.id }, nodes);
  }
  _ongetpeers(query, peer) {
    const host = peer.address || peer.host;
    const infoHash = query.a.info_hash;
    if (!infoHash) return this._rpc.error(peer, query, [203, "`get_peers` missing required `a.info_hash` field"]);
    this.emit("get_peers", infoHash);
    const r = { id: this._rpc.id, token: this._generateToken(host) };
    const peers = this._peers.get(infoHash.toString("hex"));
    if (peers.length) {
      r.values = peers;
      this._rpc.response(peer, query, r);
    } else {
      this._rpc.response(peer, query, r, this._rpc.nodes.closest(infoHash));
    }
  }
  _onannouncepeer(query, peer) {
    const host = peer.address || peer.host;
    const port = query.a.implied_port ? peer.port : query.a.port;
    if (!port || typeof port !== "number" || port <= 0 || port > 65535) return;
    const infoHash = query.a.info_hash;
    const token = query.a.token;
    if (!infoHash || !token) return;
    if (!this._validateToken(host, token)) {
      return this._rpc.error(peer, query, [203, "cannot `announce_peer` with bad token"]);
    }
    this.emit("announce_peer", infoHash, { host, port: peer.port });
    this._addPeer({ host, port }, infoHash, { host, port: peer.port });
    this._rpc.response(peer, query, { id: this._rpc.id });
  }
  _addPeer(peer, infoHash, from) {
    this._peers.add(infoHash.toString("hex"), encodePeer(peer.host, peer.port));
    this.emit("announce", peer, infoHash, from);
  }
  _onget(query, peer) {
    const host = peer.address || peer.host;
    const target = query.a.target;
    if (!target) return;
    const token = this._generateToken(host);
    const value = this._values.get(target.toString("hex"));
    this.emit("get", target, value);
    if (!value) {
      const nodes = this._rpc.nodes.closest(target);
      this._rpc.response(peer, query, { id: this._rpc.id, token }, nodes);
    } else {
      this._rpc.response(peer, query, createGetResponse(this._rpc.id, token, value));
    }
  }
  _onput(query, peer) {
    const host = peer.address || peer.host;
    const a = query.a;
    if (!a) return;
    const v = query.a.v;
    if (!v) return;
    const id = query.a.id;
    if (!id) return;
    const token = a.token;
    if (!token) return;
    if (!this._validateToken(host, token)) {
      return this._rpc.error(peer, query, [203, "cannot `put` with bad token"]);
    }
    if (v.length > 1e3) {
      return this._rpc.error(peer, query, [205, "data payload too large"]);
    }
    const isMutable = !!(a.k || a.sig);
    if (isMutable && !a.k && !a.sig) return;
    const key = isMutable ? this._hash(a.salt ? Buffer.concat([a.k, a.salt]) : a.k) : this._hash(bencode_default.encode(v));
    const keyHex = key.toString("hex");
    this.emit("put", key, v);
    if (isMutable) {
      if (!this._verify) return this._rpc.error(peer, query, [400, "verification not supported"]);
      if (!this._verify(a.sig, encodeSigData(a), a.k)) return;
      const prev = this._values.get(keyHex);
      if (prev && typeof a.cas === "number" && prev.seq !== a.cas) {
        return this._rpc.error(peer, query, [301, "CAS mismatch, re-read and try again"]);
      }
      if (prev && typeof prev.seq === "number" && !(a.seq > prev.seq)) {
        return this._rpc.error(peer, query, [302, "sequence number less than current"]);
      }
      this._values.set(keyHex, { v, k: a.k, salt: a.salt, sig: a.sig, seq: a.seq, id });
    } else {
      this._values.set(keyHex, { v, id });
    }
    this._rpc.response(peer, query, { id: this._rpc.id });
  }
  _bootstrap(populate) {
    const self2 = this;
    if (!populate) return process.nextTick(ready);
    this._rpc.populate(self2._rpc.id, {
      q: "find_node",
      a: {
        id: self2._rpc.id,
        target: self2._rpc.id
      }
    }, ready);
    function ready() {
      if (self2.ready) return;
      self2._debug("emit ready");
      self2.ready = true;
      self2.emit("ready");
    }
  }
  _closest(target, message, onmessage2, cb) {
    const self2 = this;
    const table = new import_k_bucket.default({
      localNodeId: target,
      numberOfNodesPerKBucket: this._rpc.k
    });
    this._rpc.closest(target, message, onreply, done);
    function done(err2, n) {
      if (err2) return cb(err2);
      self2._tables.set(target.toString("hex"), table);
      self2._debug("visited %d nodes", n);
      cb(null, n);
    }
    function onreply(message2, node) {
      if (!message2.r) return true;
      if (message2.r.token && message2.r.id && Buffer.isBuffer(message2.r.id) && message2.r.id.length === self2._hashLength) {
        self2._debug("found node %s (target: %s)", message2.r.id, target);
        table.add({
          id: message2.r.id,
          host: node.host || node.address,
          port: node.port,
          token: message2.r.token
        });
      }
      if (!onmessage2) return true;
      return onmessage2(message2, node);
    }
  }
  _debug() {
    if (!debug2.enabled) return;
    const args = [].slice.call(arguments);
    args[0] = `[${this.nodeId.toString("hex").substring(0, 7)}] ${args[0]}`;
    for (let i = 1; i < args.length; i++) {
      if (Buffer.isBuffer(args[i])) args[i] = args[i].toString("hex");
    }
    debug2(...args);
  }
  _validateToken(host, token) {
    const tokenA = this._generateToken(host, this._secrets[0]);
    const tokenB = this._generateToken(host, this._secrets[1]);
    return token.equals(tokenA) || token.equals(tokenB);
  }
  _generateToken(host, secret) {
    if (!secret) secret = this._secrets[0];
    return this._hash(Buffer.concat([Buffer.from(host), secret]));
  }
  _rotateSecrets() {
    if (!this._secrets) {
      this._secrets = [(0, import_randombytes.default)(this._hashLength), (0, import_randombytes.default)(this._hashLength)];
    } else {
      this._secrets[1] = this._secrets[0];
      this._secrets[0] = (0, import_randombytes.default)(this._hashLength);
    }
  }
};
function noop() {
}
function sha1(buf) {
  return import_crypto.default.createHash("sha1").update(buf).digest();
}
function createGetResponse(id, token, value) {
  const r = { id, token, v: value.v };
  if (value.sig) {
    r.sig = value.sig;
    r.k = value.k;
    if (typeof value.seq === "number") r.seq = value.seq;
  }
  return r;
}
function encodePeer(host, port) {
  const buf = Buffer.allocUnsafe(6);
  const ip = host.split(".");
  for (let i = 0; i < 4; i++) buf[i] = parseInt(ip[i] || 0, 10);
  buf.writeUInt16BE(port, 4);
  return buf;
}
function decodePeers(buf) {
  const peers = [];
  try {
    for (let i = 0; i < buf.length; i++) {
      const port = buf[i].readUInt16BE(4);
      if (!port) continue;
      peers.push({
        host: parseIp(buf[i], 0),
        port
      });
    }
  } catch (err2) {
  }
  return peers;
}
function parseIp(buf, offset) {
  return `${buf[offset++]}.${buf[offset++]}.${buf[offset++]}.${buf[offset++]}`;
}
function encodeSigData(msg) {
  const ref = { seq: msg.seq || 0, v: msg.v };
  if (msg.salt) ref.salt = msg.salt;
  return bencode_default.encode(ref).slice(1, -1);
}
function toNode(node) {
  return {
    host: node.host,
    port: node.port
  };
}
function toBuffer(str) {
  if (Buffer.isBuffer(str)) return str;
  if (ArrayBuffer.isView(str)) return Buffer.from(str.buffer, str.byteOffset, str.byteLength);
  if (typeof str === "string") return Buffer.from(str, "hex");
  throw new Error("Pass a buffer or a string");
}
var client_default = DHT;

// node_modules/torrent-discovery/index.js
var import_events4 = __toESM(require_events());
var import_run_parallel3 = __toESM(require_run_parallel());

// node_modules/bittorrent-tracker/client.js
var import_debug5 = __toESM(require_browser(), 1);
var import_events3 = __toESM(require_events(), 1);
var import_once = __toESM(require_once(), 1);
var import_run_parallel2 = __toESM(require_run_parallel(), 1);
var import_queue_microtask4 = __toESM(require_queue_microtask(), 1);

// node_modules/bittorrent-tracker/lib/common.js
var common_exports = {};
__export(common_exports, {
  DEFAULT_ANNOUNCE_PEERS: () => DEFAULT_ANNOUNCE_PEERS,
  MAX_ANNOUNCE_PEERS: () => MAX_ANNOUNCE_PEERS,
  default: () => common_default,
  parseUrl: () => parseUrl
});
var common = __toESM(require_common_node(), 1);
__reExport(common_exports, __toESM(require_common_node(), 1));
var DEFAULT_ANNOUNCE_PEERS = 50;
var MAX_ANNOUNCE_PEERS = 82;
var parseUrl = (str) => {
  const url = new URL(str.replace(/^udp:/, "http:"));
  if (str.match(/^udp:/)) {
    Object.defineProperties(url, {
      href: { value: url.href.replace(/^http/, "udp") },
      protocol: { value: url.protocol.replace(/^http/, "udp") },
      origin: { value: url.origin.replace(/^http/, "udp") }
    });
  }
  return url;
};
var common_default = {
  DEFAULT_ANNOUNCE_PEERS,
  MAX_ANNOUNCE_PEERS,
  parseUrl,
  ...common
};

// node_modules/bittorrent-tracker/client.js
var import_http_tracker = __toESM(require_http_tracker(), 1);
var import_udp_tracker = __toESM(require_udp_tracker(), 1);

// node_modules/bittorrent-tracker/lib/client/websocket-tracker.js
var import_debug4 = __toESM(require_browser(), 1);

// node_modules/@thaunknown/simple-websocket/index.js
var import_debug3 = __toESM(require_browser());
var import_queue_microtask3 = __toESM(require_queue_microtask());
var import_ws = __toESM(require_ws());
var import_streamx2 = __toESM(require_streamx());
var debug3 = (0, import_debug3.default)("simple-websocket");
var _WebSocket = typeof import_ws.default !== "function" ? WebSocket : import_ws.default;
var MAX_BUFFERED_AMOUNT2 = 64 * 1024;
var Socket = class extends import_streamx2.Duplex {
  constructor(opts = {}) {
    if (typeof opts === "string") {
      opts = { url: opts };
    }
    opts = Object.assign({
      allowHalfOpen: false
    }, opts);
    super(opts);
    this.__objectMode = !!opts.objectMode;
    if (opts.objectMode != null) delete opts.objectMode;
    if (opts.url == null && opts.socket == null) {
      throw new Error("Missing required `url` or `socket` option");
    }
    if (opts.url != null && opts.socket != null) {
      throw new Error("Must specify either `url` or `socket` option, not both");
    }
    this._id = arr2hex(randomBytes(4)).slice(0, 7);
    this._debug("new websocket: %o", opts);
    this.connected = false;
    this._chunk = null;
    this._cb = null;
    this._interval = null;
    if (opts.socket) {
      this.url = opts.socket.url;
      this._ws = opts.socket;
      this.connected = opts.socket.readyState === _WebSocket.OPEN;
    } else {
      this.url = opts.url;
      try {
        if (typeof import_ws.default === "function") {
          this._ws = new _WebSocket(opts.url, {
            ...opts,
            encoding: void 0
            // encoding option breaks ws internals
          });
        } else {
          this._ws = new _WebSocket(opts.url);
        }
      } catch (err2) {
        (0, import_queue_microtask3.default)(() => this.destroy(err2));
        return;
      }
    }
    this._ws.binaryType = "arraybuffer";
    if (opts.socket && this.connected) {
      (0, import_queue_microtask3.default)(() => this._handleOpen());
    } else {
      this._ws.onopen = () => this._handleOpen();
    }
    this._ws.onmessage = (event) => this._handleMessage(event);
    this._ws.onclose = () => this._handleClose();
    this._ws.onerror = (err2) => this._handleError(err2);
    this._handleFinishBound = () => this._handleFinish();
    this.once("finish", this._handleFinishBound);
  }
  /**
   * Send text/binary data to the WebSocket server.
   * @param {TypedArrayView|ArrayBuffer|Uint8Array|string|Blob|Object} chunk
   */
  send(chunk) {
    this._ws.send(chunk);
  }
  _final(cb) {
    if (!this._readableState.ended) this.push(null);
    cb(null);
  }
  _destroy(cb) {
    if (this.destroyed) return;
    if (!this._writableState.ended) this.end();
    this.connected = false;
    clearInterval(this._interval);
    this._interval = null;
    this._chunk = null;
    this._cb = null;
    if (this._handleFinishBound) {
      this.removeListener("finish", this._handleFinishBound);
    }
    this._handleFinishBound = null;
    if (this._ws) {
      const ws2 = this._ws;
      const onClose = () => {
        ws2.onclose = null;
      };
      if (ws2.readyState === _WebSocket.CLOSED) {
        onClose();
      } else {
        try {
          ws2.onclose = onClose;
          ws2.close();
        } catch (err2) {
          onClose();
        }
      }
      ws2.onopen = null;
      ws2.onmessage = null;
      ws2.onerror = () => {
      };
    }
    this._ws = null;
    cb();
  }
  _write(chunk, cb) {
    if (this.destroyed) return cb(new Error("cannot write after socket is destroyed"));
    if (this.connected) {
      try {
        this.send(chunk);
      } catch (err2) {
        return this.destroy(err2);
      }
      if (typeof import_ws.default !== "function" && this._ws.bufferedAmount > MAX_BUFFERED_AMOUNT2) {
        this._debug("start backpressure: bufferedAmount %d", this._ws.bufferedAmount);
        this._cb = cb;
      } else {
        cb(null);
      }
    } else {
      this._debug("write before connect");
      this._chunk = chunk;
      this._cb = cb;
    }
  }
  _handleOpen() {
    if (this.connected || this.destroyed) return;
    this.connected = true;
    if (this._chunk) {
      try {
        this.send(this._chunk);
      } catch (err2) {
        return this.destroy(err2);
      }
      this._chunk = null;
      this._debug('sent chunk from "write before connect"');
      const cb = this._cb;
      this._cb = null;
      cb(null);
    }
    if (typeof import_ws.default !== "function") {
      this._interval = setInterval(() => this._onInterval(), 150);
      if (this._interval.unref) this._interval.unref();
    }
    this._debug("connect");
    this.emit("connect");
  }
  _handleMessage(event) {
    if (this.destroyed) return;
    let data = event.data;
    if (data instanceof ArrayBuffer) data = new Uint8Array(data);
    if (this.__objectMode === false) data = text2arr(data);
    this.push(data);
  }
  _handleClose() {
    if (this.destroyed) return;
    this._debug("on close");
    this.destroy();
  }
  _handleError(_) {
    this.destroy(new Error(`Error connecting to ${this.url}`));
  }
  // When stream finishes writing, close socket. Half open connections are not
  // supported.
  _handleFinish() {
    if (this.destroyed) return;
    const destroySoon = () => {
      setTimeout(() => this.destroy(), 1e3);
    };
    if (this.connected) {
      destroySoon();
    } else {
      this.once("connect", destroySoon);
    }
  }
  _onInterval() {
    if (!this._cb || !this._ws || this._ws.bufferedAmount > MAX_BUFFERED_AMOUNT2) {
      return;
    }
    this._debug("ending backpressure: bufferedAmount %d", this._ws.bufferedAmount);
    const cb = this._cb;
    this._cb = null;
    cb(null);
  }
  _debug() {
    const args = [].slice.call(arguments);
    args[0] = "[" + this._id + "] " + args[0];
    debug3.apply(null, args);
  }
};
Socket.WEBSOCKET_SUPPORT = !!_WebSocket;

// node_modules/bittorrent-tracker/lib/client/tracker.js
var import_events2 = __toESM(require_events(), 1);
var Tracker = class extends import_events2.default {
  constructor(client, announceUrl) {
    super();
    this.client = client;
    this.announceUrl = announceUrl;
    this.interval = null;
    this.destroyed = false;
  }
  setInterval(intervalMs) {
    if (intervalMs == null) intervalMs = this.DEFAULT_ANNOUNCE_INTERVAL;
    clearInterval(this.interval);
    if (intervalMs) {
      this.interval = setInterval(() => {
        this.announce(this.client._defaultAnnounceOpts());
      }, intervalMs);
      if (this.interval.unref) this.interval.unref();
    }
  }
};
var tracker_default = Tracker;

// node_modules/bittorrent-tracker/lib/client/websocket-tracker.js
var debug4 = (0, import_debug4.default)("bittorrent-tracker:websocket-tracker");
var socketPool = {};
var RECONNECT_MINIMUM = 10 * 1e3;
var RECONNECT_MAXIMUM = 60 * 60 * 1e3;
var RECONNECT_VARIANCE = 5 * 60 * 1e3;
var OFFER_TIMEOUT = 50 * 1e3;
var WebSocketTracker = class extends tracker_default {
  constructor(client, announceUrl) {
    super(client, announceUrl);
    debug4("new websocket tracker %s", announceUrl);
    this.peers = {};
    this.socket = null;
    this.reconnecting = false;
    this.retries = 0;
    this.reconnectTimer = null;
    this.expectingResponse = false;
    this._openSocket();
  }
  announce(opts) {
    if (this.destroyed || this.reconnecting) return;
    if (!this.socket.connected) {
      this.socket.once("connect", () => {
        this.announce(opts);
      });
      return;
    }
    const params = Object.assign({}, opts, {
      action: "announce",
      info_hash: this.client._infoHashBinary,
      peer_id: this.client._peerIdBinary
    });
    if (this._trackerId) params.trackerid = this._trackerId;
    if (opts.event === "stopped" || opts.event === "completed") {
      this._send(params);
    } else {
      const numwant = Math.min(opts.numwant, 5);
      this._generateOffers(numwant, (offers) => {
        params.numwant = numwant;
        params.offers = offers;
        this._send(params);
      });
    }
  }
  scrape(opts) {
    if (this.destroyed || this.reconnecting) return;
    if (!this.socket.connected) {
      this.socket.once("connect", () => {
        this.scrape(opts);
      });
      return;
    }
    const infoHashes = Array.isArray(opts.infoHash) && opts.infoHash.length > 0 ? opts.infoHash.map((infoHash) => hex2bin(infoHash)) : opts.infoHash && hex2bin(opts.infoHash) || this.client._infoHashBinary;
    const params = {
      action: "scrape",
      info_hash: infoHashes
    };
    this._send(params);
  }
  destroy(cb = noop2) {
    if (this.destroyed) return cb(null);
    this.destroyed = true;
    clearInterval(this.interval);
    clearTimeout(this.reconnectTimer);
    for (const peerId in this.peers) {
      const peer = this.peers[peerId];
      clearTimeout(peer.trackerTimeout);
      peer.destroy();
    }
    this.peers = null;
    if (this.socket) {
      this.socket.removeListener("connect", this._onSocketConnectBound);
      this.socket.removeListener("data", this._onSocketDataBound);
      this.socket.removeListener("close", this._onSocketCloseBound);
      this.socket.removeListener("error", this._onSocketErrorBound);
      this.socket = null;
    }
    this._onSocketConnectBound = null;
    this._onSocketErrorBound = null;
    this._onSocketDataBound = null;
    this._onSocketCloseBound = null;
    if (socketPool[this.announceUrl]) {
      socketPool[this.announceUrl].consumers -= 1;
    }
    if (socketPool[this.announceUrl].consumers > 0) return cb();
    let socket = socketPool[this.announceUrl];
    delete socketPool[this.announceUrl];
    socket.on("error", noop2);
    socket.once("close", cb);
    let timeout;
    if (!this.expectingResponse) return destroyCleanup();
    timeout = setTimeout(destroyCleanup, common_default.DESTROY_TIMEOUT);
    socket.once("data", destroyCleanup);
    function destroyCleanup() {
      if (timeout) {
        clearTimeout(timeout);
        timeout = null;
      }
      socket.removeListener("data", destroyCleanup);
      socket.destroy();
      socket = null;
    }
  }
  _openSocket() {
    this.destroyed = false;
    if (!this.peers) this.peers = {};
    this._onSocketConnectBound = () => {
      this._onSocketConnect();
    };
    this._onSocketErrorBound = (err2) => {
      this._onSocketError(err2);
    };
    this._onSocketDataBound = (data) => {
      this._onSocketData(data);
    };
    this._onSocketCloseBound = () => {
      this._onSocketClose();
    };
    this.socket = socketPool[this.announceUrl];
    if (this.socket) {
      socketPool[this.announceUrl].consumers += 1;
      if (this.socket.connected) {
        this._onSocketConnectBound();
      }
    } else {
      const parsedUrl = new URL(this.announceUrl);
      let agent;
      if (this.client._proxyOpts) {
        agent = parsedUrl.protocol === "wss:" ? this.client._proxyOpts.httpsAgent : this.client._proxyOpts.httpAgent;
        if (!agent && this.client._proxyOpts.socksProxy) {
          agent = this.client._proxyOpts.socksProxy;
        }
      }
      this.socket = socketPool[this.announceUrl] = new Socket({ url: this.announceUrl, agent });
      this.socket.consumers = 1;
      this.socket.once("connect", this._onSocketConnectBound);
    }
    this.socket.on("data", this._onSocketDataBound);
    this.socket.once("close", this._onSocketCloseBound);
    this.socket.once("error", this._onSocketErrorBound);
  }
  _onSocketConnect() {
    if (this.destroyed) return;
    if (this.reconnecting) {
      this.reconnecting = false;
      this.retries = 0;
      this.announce(this.client._defaultAnnounceOpts());
    }
  }
  _onSocketData(data) {
    if (this.destroyed) return;
    this.expectingResponse = false;
    try {
      data = JSON.parse(arr2text(data));
    } catch (err2) {
      this.client.emit("warning", new Error("Invalid tracker response"));
      return;
    }
    if (data.action === "announce") {
      this._onAnnounceResponse(data);
    } else if (data.action === "scrape") {
      this._onScrapeResponse(data);
    } else {
      this._onSocketError(new Error(`invalid action in WS response: ${data.action}`));
    }
  }
  _onAnnounceResponse(data) {
    if (data.info_hash !== this.client._infoHashBinary) {
      debug4(
        "ignoring websocket data from %s for %s (looking for %s: reused socket)",
        this.announceUrl,
        bin2hex(data.info_hash),
        this.client.infoHash
      );
      return;
    }
    if (data.peer_id && data.peer_id === this.client._peerIdBinary) {
      return;
    }
    debug4(
      "received %s from %s for %s",
      JSON.stringify(data),
      this.announceUrl,
      this.client.infoHash
    );
    const failure = data["failure reason"];
    if (failure) return this.client.emit("warning", new Error(failure));
    const warning = data["warning message"];
    if (warning) this.client.emit("warning", new Error(warning));
    const interval = data.interval || data["min interval"];
    if (interval) this.setInterval(interval * 1e3);
    const trackerId = data["tracker id"];
    if (trackerId) {
      this._trackerId = trackerId;
    }
    if (data.complete != null) {
      const response = Object.assign({}, data, {
        announce: this.announceUrl,
        infoHash: bin2hex(data.info_hash)
      });
      this.client.emit("update", response);
    }
    let peer;
    if (data.offer && data.peer_id) {
      debug4("creating peer (from remote offer)");
      peer = this._createPeer();
      peer.id = bin2hex(data.peer_id);
      peer.once("signal", (answer) => {
        const params = {
          action: "announce",
          info_hash: this.client._infoHashBinary,
          peer_id: this.client._peerIdBinary,
          to_peer_id: data.peer_id,
          answer,
          offer_id: data.offer_id
        };
        if (this._trackerId) params.trackerid = this._trackerId;
        this._send(params);
      });
      this.client.emit("peer", peer);
      peer.signal(data.offer);
    }
    if (data.answer && data.peer_id) {
      const offerId = bin2hex(data.offer_id);
      peer = this.peers[offerId];
      if (peer) {
        peer.id = bin2hex(data.peer_id);
        this.client.emit("peer", peer);
        peer.signal(data.answer);
        clearTimeout(peer.trackerTimeout);
        peer.trackerTimeout = null;
        delete this.peers[offerId];
      } else {
        debug4(`got unexpected answer: ${JSON.stringify(data.answer)}`);
      }
    }
  }
  _onScrapeResponse(data) {
    data = data.files || {};
    const keys = Object.keys(data);
    if (keys.length === 0) {
      this.client.emit("warning", new Error("invalid scrape response"));
      return;
    }
    keys.forEach((infoHash) => {
      const response = Object.assign(data[infoHash], {
        announce: this.announceUrl,
        infoHash: bin2hex(infoHash)
      });
      this.client.emit("scrape", response);
    });
  }
  _onSocketClose() {
    if (this.destroyed) return;
    this.destroy();
    this._startReconnectTimer();
  }
  _onSocketError(err2) {
    if (this.destroyed) return;
    this.destroy();
    this.client.emit("warning", err2);
    this._startReconnectTimer();
  }
  _startReconnectTimer() {
    const ms = Math.floor(Math.random() * RECONNECT_VARIANCE) + Math.min(Math.pow(2, this.retries) * RECONNECT_MINIMUM, RECONNECT_MAXIMUM);
    this.reconnecting = true;
    clearTimeout(this.reconnectTimer);
    this.reconnectTimer = setTimeout(() => {
      this.retries++;
      this._openSocket();
    }, ms);
    if (this.reconnectTimer.unref) this.reconnectTimer.unref();
    debug4("reconnecting socket in %s ms", ms);
  }
  _send(params) {
    if (this.destroyed) return;
    this.expectingResponse = true;
    const message = JSON.stringify(params);
    debug4("send %s", message);
    this.socket.send(message);
  }
  _generateOffers(numwant, cb) {
    const self2 = this;
    const offers = [];
    debug4("generating %s offers", numwant);
    for (let i = 0; i < numwant; ++i) {
      generateOffer();
    }
    checkDone();
    function generateOffer() {
      const offerId = arr2hex(randomBytes(20));
      debug4("creating peer (from _generateOffers)");
      const peer = self2.peers[offerId] = self2._createPeer({ initiator: true });
      peer.once("signal", (offer) => {
        offers.push({
          offer,
          offer_id: hex2bin(offerId)
        });
        checkDone();
      });
      peer.trackerTimeout = setTimeout(() => {
        debug4("tracker timeout: destroying peer");
        peer.trackerTimeout = null;
        delete self2.peers[offerId];
        peer.destroy();
      }, OFFER_TIMEOUT);
      if (peer.trackerTimeout.unref) peer.trackerTimeout.unref();
    }
    function checkDone() {
      if (offers.length === numwant) {
        debug4("generated %s offers", numwant);
        cb(offers);
      }
    }
  }
  _createPeer(opts) {
    const self2 = this;
    opts = Object.assign({
      trickle: false,
      config: self2.client._rtcConfig,
      wrtc: self2.client._wrtc
    }, opts);
    const peer = new lite_default(opts);
    peer.once("error", onError);
    peer.once("connect", onConnect);
    return peer;
    function onError(err2) {
      self2.client.emit("warning", new Error(`Connection error: ${err2.message}`));
      peer.destroy();
    }
    function onConnect() {
      peer.removeListener("error", onError);
      peer.removeListener("connect", onConnect);
    }
  }
};
WebSocketTracker.prototype.DEFAULT_ANNOUNCE_INTERVAL = 30 * 1e3;
WebSocketTracker._socketPool = socketPool;
function noop2() {
}
var websocket_tracker_default = WebSocketTracker;

// node_modules/bittorrent-tracker/client.js
var debug5 = (0, import_debug5.default)("bittorrent-tracker:client");
var Client = class extends import_events3.default {
  constructor(opts = {}) {
    super();
    if (!opts.peerId) throw new Error("Option `peerId` is required");
    if (!opts.infoHash) throw new Error("Option `infoHash` is required");
    if (!opts.announce) throw new Error("Option `announce` is required");
    if (!process.browser && !opts.port) throw new Error("Option `port` is required");
    this.peerId = typeof opts.peerId === "string" ? opts.peerId : arr2hex(opts.peerId);
    this._peerIdBuffer = hex2arr(this.peerId);
    this._peerIdBinary = hex2bin(this.peerId);
    this.infoHash = typeof opts.infoHash === "string" ? opts.infoHash.toLowerCase() : arr2hex(opts.infoHash);
    this._infoHashBuffer = hex2arr(this.infoHash);
    this._infoHashBinary = hex2bin(this.infoHash);
    debug5("new client %s", this.infoHash);
    this.destroyed = false;
    this._port = opts.port;
    this._getAnnounceOpts = opts.getAnnounceOpts;
    this._rtcConfig = opts.rtcConfig;
    this._userAgent = opts.userAgent;
    this._proxyOpts = opts.proxyOpts;
    this._wrtc = typeof opts.wrtc === "function" ? opts.wrtc() : opts.wrtc;
    let announce = typeof opts.announce === "string" ? [opts.announce] : opts.announce == null ? [] : opts.announce;
    announce = announce.map((announceUrl) => {
      if (ArrayBuffer.isView(announceUrl)) announceUrl = arr2text(announceUrl);
      if (announceUrl[announceUrl.length - 1] === "/") {
        announceUrl = announceUrl.substring(0, announceUrl.length - 1);
      }
      return announceUrl;
    });
    announce = Array.from(new Set(announce));
    const webrtcSupport = this._wrtc !== false && (!!this._wrtc || lite_default.WEBRTC_SUPPORT);
    const nextTickWarn = (err2) => {
      (0, import_queue_microtask4.default)(() => {
        this.emit("warning", err2);
      });
    };
    this._trackers = announce.map((announceUrl) => {
      let parsedUrl;
      try {
        parsedUrl = common_default.parseUrl(announceUrl);
      } catch (err2) {
        nextTickWarn(new Error(`Invalid tracker URL: ${announceUrl}`));
        return null;
      }
      const port = parsedUrl.port;
      if (port < 0 || port > 65535) {
        nextTickWarn(new Error(`Invalid tracker port: ${announceUrl}`));
        return null;
      }
      const protocol = parsedUrl.protocol;
      if ((protocol === "http:" || protocol === "https:") && typeof import_http_tracker.default === "function") {
        return new import_http_tracker.default(this, announceUrl);
      } else if (protocol === "udp:" && typeof import_udp_tracker.default === "function") {
        return new import_udp_tracker.default(this, announceUrl);
      } else if ((protocol === "ws:" || protocol === "wss:") && webrtcSupport) {
        if (protocol === "ws:" && typeof window !== "undefined" && window.location.protocol === "https:") {
          nextTickWarn(new Error(`Unsupported tracker protocol: ${announceUrl}`));
          return null;
        }
        return new websocket_tracker_default(this, announceUrl);
      } else {
        nextTickWarn(new Error(`Unsupported tracker protocol: ${announceUrl}`));
        return null;
      }
    }).filter(Boolean);
  }
  /**
   * Send a `start` announce to the trackers.
   * @param {Object} opts
   * @param {number=} opts.uploaded
   * @param {number=} opts.downloaded
   * @param {number=} opts.left (if not set, calculated automatically)
   */
  start(opts) {
    opts = this._defaultAnnounceOpts(opts);
    opts.event = "started";
    debug5("send `start` %o", opts);
    this._announce(opts);
    this._trackers.forEach((tracker) => {
      tracker.setInterval();
    });
  }
  /**
   * Send a `stop` announce to the trackers.
   * @param {Object} opts
   * @param {number=} opts.uploaded
   * @param {number=} opts.downloaded
   * @param {number=} opts.numwant
   * @param {number=} opts.left (if not set, calculated automatically)
   */
  stop(opts) {
    opts = this._defaultAnnounceOpts(opts);
    opts.event = "stopped";
    debug5("send `stop` %o", opts);
    this._announce(opts);
  }
  /**
   * Send a `complete` announce to the trackers.
   * @param {Object} opts
   * @param {number=} opts.uploaded
   * @param {number=} opts.downloaded
   * @param {number=} opts.numwant
   * @param {number=} opts.left (if not set, calculated automatically)
   */
  complete(opts) {
    if (!opts) opts = {};
    opts = this._defaultAnnounceOpts(opts);
    opts.event = "completed";
    debug5("send `complete` %o", opts);
    this._announce(opts);
  }
  /**
   * Send a `update` announce to the trackers.
   * @param {Object} opts
   * @param {number=} opts.uploaded
   * @param {number=} opts.downloaded
   * @param {number=} opts.numwant
   * @param {number=} opts.left (if not set, calculated automatically)
   */
  update(opts) {
    opts = this._defaultAnnounceOpts(opts);
    if (opts.event) delete opts.event;
    debug5("send `update` %o", opts);
    this._announce(opts);
  }
  _announce(opts) {
    this._trackers.forEach((tracker) => {
      tracker.announce(opts);
    });
  }
  /**
   * Send a scrape request to the trackers.
   * @param {Object} opts
   */
  scrape(opts) {
    debug5("send `scrape`");
    if (!opts) opts = {};
    this._trackers.forEach((tracker) => {
      tracker.scrape(opts);
    });
  }
  setInterval(intervalMs) {
    debug5("setInterval %d", intervalMs);
    this._trackers.forEach((tracker) => {
      tracker.setInterval(intervalMs);
    });
  }
  destroy(cb) {
    if (this.destroyed) return;
    this.destroyed = true;
    debug5("destroy");
    const tasks = this._trackers.map((tracker) => (cb2) => {
      tracker.destroy(cb2);
    });
    (0, import_run_parallel2.default)(tasks, cb);
    this._trackers = [];
    this._getAnnounceOpts = null;
  }
  _defaultAnnounceOpts(opts = {}) {
    if (opts.numwant == null) opts.numwant = common_default.DEFAULT_ANNOUNCE_PEERS;
    if (opts.uploaded == null) opts.uploaded = 0;
    if (opts.downloaded == null) opts.downloaded = 0;
    if (this._getAnnounceOpts) opts = Object.assign({}, opts, this._getAnnounceOpts());
    return opts;
  }
};
Client.scrape = (opts, cb) => {
  cb = (0, import_once.default)(cb);
  if (!opts.infoHash) throw new Error("Option `infoHash` is required");
  if (!opts.announce) throw new Error("Option `announce` is required");
  const clientOpts = Object.assign({}, opts, {
    infoHash: Array.isArray(opts.infoHash) ? opts.infoHash[0] : opts.infoHash,
    peerId: text2arr("01234567890123456789"),
    // dummy value
    port: 6881
    // dummy value
  });
  const client = new Client(clientOpts);
  client.once("error", cb);
  client.once("warning", cb);
  let len = Array.isArray(opts.infoHash) ? opts.infoHash.length : 1;
  const results = {};
  client.on("scrape", (data) => {
    len -= 1;
    results[data.infoHash] = data;
    if (len === 0) {
      client.destroy();
      const keys = Object.keys(results);
      if (keys.length === 1) {
        cb(null, results[keys[0]]);
      } else {
        cb(null, results);
      }
    }
  });
  client.scrape({ infoHash: opts.infoHash });
  return client;
};
var client_default2 = Client;

// node_modules/bittorrent-tracker/index.js
var import_server2 = __toESM(require_server());

// node_modules/torrent-discovery/index.js
var import_bittorrent_lsd = __toESM(require_bittorrent_lsd());
var debug6 = (0, import_debug6.default)("torrent-discovery");
var Discovery = class extends import_events4.EventEmitter {
  constructor(opts) {
    super();
    if (!opts.peerId) throw new Error("Option `peerId` is required");
    if (!opts.infoHash) throw new Error("Option `infoHash` is required");
    if (!process.browser && !opts.port) throw new Error("Option `port` is required");
    this.peerId = typeof opts.peerId === "string" ? opts.peerId : opts.peerId.toString("hex");
    this.infoHash = typeof opts.infoHash === "string" ? opts.infoHash.toLowerCase() : opts.infoHash.toString("hex");
    this._port = opts.port;
    this._userAgent = opts.userAgent;
    this.destroyed = false;
    this._announce = opts.announce || [];
    this._intervalMs = opts.intervalMs || 15 * 60 * 1e3;
    this._trackerOpts = null;
    this._dhtAnnouncing = false;
    this._dhtTimeout = false;
    this._internalDHT = false;
    this._onWarning = (err2) => {
      this.emit("warning", err2);
    };
    this._onError = (err2) => {
      this.emit("error", err2);
    };
    this._onDHTPeer = (peer, infoHash) => {
      if (infoHash.toString("hex") !== this.infoHash) return;
      this.emit("peer", `${peer.host}:${peer.port}`, "dht");
    };
    this._onTrackerPeer = (peer) => {
      this.emit("peer", peer, "tracker");
    };
    this._onTrackerAnnounce = () => {
      this.emit("trackerAnnounce");
    };
    this._onLSDPeer = (peer, infoHash) => {
      this.emit("peer", peer, "lsd");
    };
    const createDHT = (port, opts2) => {
      const dht = new client_default(opts2);
      dht.on("warning", this._onWarning);
      dht.on("error", this._onError);
      dht.listen(port);
      this._internalDHT = true;
      return dht;
    };
    if (opts.tracker === false) {
      this.tracker = null;
    } else if (opts.tracker && typeof opts.tracker === "object") {
      this._trackerOpts = Object.assign({}, opts.tracker);
      this.tracker = this._createTracker();
    } else {
      this.tracker = this._createTracker();
    }
    if (opts.dht === false || typeof client_default !== "function") {
      this.dht = null;
    } else if (opts.dht && typeof opts.dht.addNode === "function") {
      this.dht = opts.dht;
    } else if (opts.dht && typeof opts.dht === "object") {
      this.dht = createDHT(opts.dhtPort, opts.dht);
    } else {
      this.dht = createDHT(opts.dhtPort);
    }
    if (this.dht) {
      this.dht.on("peer", this._onDHTPeer);
      this._dhtAnnounce();
    }
    if (opts.lsd === false || typeof import_bittorrent_lsd.default !== "function") {
      this.lsd = null;
    } else {
      this.lsd = this._createLSD();
    }
  }
  updatePort(port) {
    if (port === this._port) return;
    this._port = port;
    if (this.dht) this._dhtAnnounce();
    if (this.tracker) {
      this.tracker.stop();
      this.tracker.destroy(() => {
        this.tracker = this._createTracker();
      });
    }
  }
  complete(opts) {
    if (this.tracker) {
      this.tracker.complete(opts);
    }
  }
  destroy(cb) {
    if (this.destroyed) return;
    this.destroyed = true;
    clearTimeout(this._dhtTimeout);
    const tasks = [];
    if (this.tracker) {
      this.tracker.stop();
      this.tracker.removeListener("warning", this._onWarning);
      this.tracker.removeListener("error", this._onError);
      this.tracker.removeListener("peer", this._onTrackerPeer);
      this.tracker.removeListener("update", this._onTrackerAnnounce);
      tasks.push((cb2) => {
        this.tracker.destroy(cb2);
      });
    }
    if (this.dht) {
      this.dht.removeListener("peer", this._onDHTPeer);
    }
    if (this._internalDHT) {
      this.dht.removeListener("warning", this._onWarning);
      this.dht.removeListener("error", this._onError);
      tasks.push((cb2) => {
        this.dht.destroy(cb2);
      });
    }
    if (this.lsd) {
      this.lsd.removeListener("warning", this._onWarning);
      this.lsd.removeListener("error", this._onError);
      this.lsd.removeListener("peer", this._onLSDPeer);
      tasks.push((cb2) => {
        this.lsd.destroy(cb2);
      });
    }
    (0, import_run_parallel3.default)(tasks, cb);
    this.dht = null;
    this.tracker = null;
    this.lsd = null;
    this._announce = null;
  }
  _createTracker() {
    const opts = Object.assign({}, this._trackerOpts, {
      infoHash: this.infoHash,
      announce: this._announce,
      peerId: this.peerId,
      port: this._port,
      userAgent: this._userAgent
    });
    const tracker = new client_default2(opts);
    tracker.on("warning", this._onWarning);
    tracker.on("error", this._onError);
    tracker.on("peer", this._onTrackerPeer);
    tracker.on("update", this._onTrackerAnnounce);
    tracker.setInterval(this._intervalMs);
    tracker.start();
    return tracker;
  }
  _dhtAnnounce() {
    if (this._dhtAnnouncing) return;
    debug6("dht announce");
    this._dhtAnnouncing = true;
    clearTimeout(this._dhtTimeout);
    this.dht.announce(this.infoHash, this._port, (err2) => {
      this._dhtAnnouncing = false;
      debug6("dht announce complete");
      if (err2) this.emit("warning", err2);
      this.emit("dhtAnnounce");
      if (!this.destroyed) {
        this._dhtTimeout = setTimeout(() => {
          this._dhtAnnounce();
        }, this._intervalMs + Math.floor(Math.random() * this._intervalMs / 5));
        if (this._dhtTimeout.unref) this._dhtTimeout.unref();
      }
    });
  }
  _createLSD() {
    const opts = Object.assign({}, {
      infoHash: this.infoHash,
      peerId: this.peerId,
      port: this._port
    });
    const lsd = new import_bittorrent_lsd.default(opts);
    lsd.on("warning", this._onWarning);
    lsd.on("error", this._onError);
    lsd.on("peer", this._onLSDPeer);
    lsd.start();
    return lsd;
  }
};
var torrent_discovery_default = Discovery;

// node_modules/filename-reserved-regex/index.js
function filenameReservedRegex() {
  return /[<>:"/\\|?*\u0000-\u001F]/g;
}

// node_modules/fsa-chunk-store/createWritable.js
var INVALID = ["seeking position failed.", "InvalidStateError"];
var GONE = ["A requested file or directory could not be found at the time an operation was processed.", "NotFoundError"];
var SYNTAX = (m) => [`Failed to execute 'write' on 'UnderlyingSinkBase': Invalid params passed. ${m}`, "SyntaxError"];
var _FileSystemWritableFileStream = class extends WritableStream {
  constructor(writer) {
    super(writer);
    Object.setPrototypeOf(this, FileSystemWritableFileStream.prototype);
    this._closed = false;
  }
  async close() {
    this._closed = true;
    const w = this.getWriter();
    const p = w.close();
    w.releaseLock();
    return p;
  }
  /** @param {number} position */
  seek(position) {
    return this.write({ type: "seek", position });
  }
  /** @param {number} size */
  truncate(size) {
    return this.write({ type: "truncate", size });
  }
  // The write(data) method steps are:
  write(data) {
    if (this._closed) {
      return Promise.reject(new TypeError("Cannot write to a CLOSED writable stream"));
    }
    const writer = this.getWriter();
    const result = writer.write(data);
    writer.releaseLock();
    return result;
  }
};
Object.defineProperty(_FileSystemWritableFileStream.prototype, Symbol.toStringTag, {
  value: "FileSystemWritableFileStream",
  writable: false,
  enumerable: false,
  configurable: true
});
Object.defineProperties(_FileSystemWritableFileStream.prototype, {
  close: { enumerable: true },
  seek: { enumerable: true },
  truncate: { enumerable: true },
  write: { enumerable: true }
});
if (globalThis.FileSystemFileHandle && !globalThis.FileSystemFileHandle.prototype.createWritable && !globalThis.FileSystemWritableFileStream) {
  globalThis.FileSystemWritableFileStream = _FileSystemWritableFileStream;
}
if (globalThis.FileSystemFileHandle && !globalThis.FileSystemFileHandle.prototype.createWritable) {
  const wm = /* @__PURE__ */ new WeakMap();
  let workerUrl;
  const code = () => {
    let fileHandle, handle;
    onmessage = async (evt) => {
      const port = evt.ports[0];
      const cmd = evt.data;
      switch (cmd.type) {
        case "open": {
          const file = cmd.name;
          let dir = await navigator.storage.getDirectory();
          for (const folder of cmd.path) {
            dir = await dir.getDirectoryHandle(folder);
          }
          fileHandle = await dir.getFileHandle(file);
          handle = await fileHandle.createSyncAccessHandle();
          break;
        }
        case "write":
          handle.write(cmd.data, { at: cmd.position });
          handle.flush();
          break;
        case "truncate":
          handle.truncate(cmd.size);
          break;
        case "abort":
        case "close":
          handle.close();
          break;
      }
      port.postMessage(0);
    };
  };
  globalThis.FileSystemFileHandle.prototype.createWritable = async function(options) {
    if (!workerUrl) {
      const stringCode = `(${code.toString()})()`;
      const blob = new Blob([stringCode], {
        type: "text/javascript"
      });
      workerUrl = URL.createObjectURL(blob);
    }
    const worker = new Worker(workerUrl, { type: "module" });
    let position = 0;
    const textEncoder = new TextEncoder();
    let size = await this.getFile().then((file) => file.size);
    const send = (message) => new Promise((resolve, reject) => {
      const mc = new MessageChannel();
      mc.port1.onmessage = (evt) => {
        if (evt.data instanceof Error) reject(evt.data);
        else resolve(evt.data);
        mc.port1.close();
        mc.port2.close();
        mc.port1.onmessage = null;
      };
      worker.postMessage(message, [mc.port2]);
    });
    const root = await navigator.storage.getDirectory();
    const parent = await wm.get(this);
    const path4 = await root.resolve(parent);
    if (path4 === null) throw new DOMException(...GONE);
    await send({ type: "open", path: path4, name: this.name });
    if ((options == null ? void 0 : options.keepExistingData) === false) {
      await send({ type: "truncate", size: 0 });
      size = 0;
    }
    return new _FileSystemWritableFileStream({
      async write(chunk) {
        const isPlainObject = (chunk == null ? void 0 : chunk.constructor) === Object;
        if (isPlainObject) {
          chunk = { ...chunk };
        } else {
          chunk = { type: "write", data: chunk, position };
        }
        if (chunk.type === "write") {
          if (!("data" in chunk)) {
            await send({ type: "close" });
            throw new DOMException(...SYNTAX("write requires a data argument"));
          }
          chunk.position ?? (chunk.position = position);
          if (typeof chunk.data === "string") {
            chunk.data = textEncoder.encode(chunk.data);
          } else if (chunk.data instanceof ArrayBuffer) {
            chunk.data = new Uint8Array(chunk.data);
          } else if (!(chunk.data instanceof Uint8Array) && ArrayBuffer.isView(chunk.data)) {
            chunk.data = new Uint8Array(chunk.data.buffer, chunk.data.byteOffset, chunk.data.byteLength);
          } else if (!(chunk.data instanceof Uint8Array)) {
            const ab = await new Response(chunk.data).arrayBuffer();
            chunk.data = new Uint8Array(ab);
          }
          if (Number.isInteger(chunk.position) && chunk.position >= 0) {
            position = chunk.position;
          }
          position += chunk.data.byteLength;
          size += chunk.data.byteLength;
        } else if (chunk.type === "seek") {
          if (Number.isInteger(chunk.position) && chunk.position >= 0) {
            if (size < chunk.position) {
              throw new DOMException(...INVALID);
            }
            position = chunk.position;
            return;
          } else {
            await send({ type: "close" });
            throw new DOMException(...SYNTAX("seek requires a position argument"));
          }
        } else if (chunk.type === "truncate") {
          if (Number.isInteger(chunk.size) && chunk.size >= 0) {
            size = chunk.size;
            if (position > size) {
              position = size;
            }
          } else {
            await send({ type: "close" });
            throw new DOMException(...SYNTAX("truncate requires a size argument"));
          }
        }
        await send(chunk);
      },
      async close() {
        await send({ type: "close" });
        worker.terminate();
      },
      async abort(reason) {
        await send({ type: "abort", reason });
        worker.terminate();
      }
    });
  };
  const orig = FileSystemDirectoryHandle.prototype.getFileHandle;
  FileSystemDirectoryHandle.prototype.getFileHandle = async function(...args) {
    const handle = await orig.call(this, ...args);
    wm.set(handle, this);
    return handle;
  };
}

// node_modules/fsa-chunk-store/index.js
var RESERVED_FILENAME_REGEX = filenameReservedRegex();
var _a, _b;
if ((_b = (_a = globalThis.navigator) == null ? void 0 : _a.storage) == null ? void 0 : _b.getDirectory) {
  navigator.storage.getDirectory().then((storageDir) => {
    storageDir.removeEntry("chunks", { recursive: true }).catch(() => {
    });
  });
}
var noop3 = (_, __) => {
};
var err = (cb = noop3, err2) => queueMicrotask(() => cb(new Error(err2)));
var FSAChunkStore = class {
  /**
   * @param {number} chunkLength
   * @param {{ name?: string, rootDir?: Promise<FileSystemDirectoryHandle>, length?: number, files?: {path: string, length: number, offset?: number, handle?: Promise<FileSystemFileHandle>, blob?: Promise<Blob>, stream?: Promise<FileSystemWritableFileStream> }[] }} [opts]
   */
  constructor(chunkLength, opts = {}) {
    __publicField(this, "name", "");
    __publicField(this, "chunks", []);
    // individual chunks, required for reads :/
    __publicField(this, "chunkMap", []);
    // full files
    __publicField(this, "directoryMap", {});
    __publicField(this, "files");
    __publicField(this, "rootDirPromise");
    __publicField(this, "storageDirPromise");
    __publicField(this, "chunksDirPromise");
    __publicField(this, "closing", false);
    __publicField(this, "closed", false);
    var _a3, _b3;
    this.chunkLength = Number(chunkLength);
    if (!this.chunkLength) {
      throw new Error("First argument must be a chunk length");
    }
    if (!((_b3 = (_a3 = globalThis.navigator) == null ? void 0 : _a3.storage) == null ? void 0 : _b3.getDirectory)) {
      throw new Error("FSA API is not supported");
    }
    this.closed = false;
    this.name = opts.name || crypto.randomUUID();
    this.rootDirPromise = opts.rootDir || navigator.storage.getDirectory();
    this.storageDirPromise = (async () => {
      const rootDir = await this.rootDirPromise;
      return rootDir.getDirectoryHandle(this.name, { create: true });
    })();
    this.chunksDirPromise = this.storageDirPromise;
    if (opts.files && opts.rootDir) {
      this.chunksDirPromise = this._getChunksDirHandle();
      this.files = opts.files.map((file, i, files) => {
        if (file.path == null) throw new Error("File is missing `path` property");
        if (file.length == null) throw new Error("File is missing `length` property");
        if (file.offset == null) {
          if (i === 0) {
            file.offset = 0;
          } else {
            const prevFile = files[i - 1];
            file.offset = prevFile.offset + prevFile.length;
          }
        }
        if (file.handle == null) file.handle = this._createFileHandle({ path: file.path });
        file.blob = this._createBlobReference(file.handle);
        const fileStart = file.offset;
        const fileEnd = file.offset + file.length;
        const firstChunk = Math.floor(fileStart / this.chunkLength);
        const lastChunk = Math.floor((fileEnd - 1) / this.chunkLength);
        for (let i2 = firstChunk; i2 <= lastChunk; ++i2) {
          const chunkStart = i2 * this.chunkLength;
          const chunkEnd = chunkStart + this.chunkLength;
          const from = fileStart < chunkStart ? 0 : fileStart - chunkStart;
          const to = fileEnd > chunkEnd ? this.chunkLength : fileEnd - chunkStart;
          const offset = fileStart > chunkStart ? 0 : chunkStart - fileStart;
          if (!this.chunkMap[i2]) this.chunkMap[i2] = [];
          this.chunkMap[i2].push({ from, to, offset, file });
        }
        return file;
      });
      window.addEventListener("pagehide", () => this.cleanup());
      this.length = this.files.reduce((sum, file) => sum + file.length, 0);
      if (opts.length != null && opts.length !== this.length) {
        throw new Error("total `files` length is not equal to explicit `length` option");
      }
    } else {
      this.length = Number(opts.length) || Infinity;
    }
    if (this.length !== Infinity) {
      this.lastChunkLength = this.length % this.chunkLength || this.chunkLength;
      this.lastChunkIndex = Math.ceil(this.length / this.chunkLength) - 1;
    }
  }
  async _getChunkHandle(index) {
    let chunk = this.chunks[index];
    if (!chunk) {
      const storageDir = await this.chunksDirPromise;
      this.chunks[index] = chunk = await storageDir.getFileHandle(index, { create: true });
    }
    return chunk;
  }
  /**
   * @param {{path: string}} opts
   */
  async _createFileHandle(opts) {
    const fileName = opts.path.slice(opts.path.lastIndexOf("/") + 1);
    return (await this._getDirectoryHandle(opts)).getFileHandle(fileName.replace(RESERVED_FILENAME_REGEX, ""), { create: true });
  }
  async _createBlobReference(handle) {
    return (await handle).getFile();
  }
  /**
   * recursive, equiv of cd and mkdirp
   * @param {{path: string}} opts
   * @returns {Promise<FileSystemDirectoryHandle>}
   */
  async _getDirectoryHandle(opts) {
    const lastIndex = opts.path.lastIndexOf("/");
    if (lastIndex === -1 || lastIndex === 0) return this.storageDirPromise;
    const path4 = opts.path = opts.path.slice(0, lastIndex);
    if (!this.directoryMap[path4]) {
      this.directoryMap[path4] = (async () => {
        const parent = await this._getDirectoryHandle(opts);
        return parent.getDirectoryHandle(path4.slice(path4.lastIndexOf("/") + 1), { create: true });
      })();
    }
    return this.directoryMap[path4];
  }
  async _getChunksDirHandle() {
    const storageDir = await navigator.storage.getDirectory();
    const chunksDir = await storageDir.getDirectoryHandle("chunks", { create: true });
    return chunksDir.getDirectoryHandle(this.name, { create: true });
  }
  async put(index, buf, cb = noop3) {
    try {
      await this._put(index, buf);
      cb(null);
      return null;
    } catch (e) {
      queueMicrotask(() => cb(e));
      return e;
    }
  }
  /**
   * @param {Promise<FileSystemFileHandle>} handle
   */
  async getStreamForHandle(handle) {
    return (await handle).createWritable({ keepExistingData: true });
  }
  // wrapped in prep for callback drop
  async _put(index, buf) {
    if (this.closed) throw new Error("Storage is closed");
    const isLastChunk = index === this.lastChunkIndex;
    if (isLastChunk && buf.length !== this.lastChunkLength) throw new Error(`Last chunk length must be ${this.lastChunkLength}`);
    if (!isLastChunk && buf.length !== this.chunkLength) throw new Error(`Chunk length must be ${this.chunkLength}`);
    const chunkWrite = (async () => {
      const chunk = await this._getChunkHandle(index);
      const stream = await chunk.createWritable({ keepExistingData: false });
      await stream.write(buf);
      await stream.close();
    })();
    if (!this.files) return chunkWrite;
    const targets = this.chunkMap[index];
    if (!targets) throw new Error("No files matching the request range");
    const promises = targets.map(async ({ file, offset, from, to }) => {
      if (!file.stream) {
        file.stream = this.getStreamForHandle(file.handle);
      }
      await (await file.stream).write({ type: "write", position: offset, data: buf.slice(from, to) });
    });
    promises.push(chunkWrite);
    await Promise.all(promises);
  }
  async get(index, opts, cb = noop3) {
    if (opts == null) opts = {};
    try {
      const data = await this._get(index, opts);
      cb(null, data);
      return data;
    } catch (e) {
      cb(e);
      return e;
    }
  }
  // wrapped in prep for callback drop
  async _get(index, opts) {
    if (typeof opts === "function") return this.get(index, void 0, opts);
    if (this.closed) throw new Error("Storage is closed");
    const isLastChunk = index === this.lastChunkIndex;
    const chunkLength = isLastChunk ? (
      /** @type {number} */
      this.lastChunkLength
    ) : this.chunkLength;
    const rangeFrom = opts.offset || 0;
    const rangeTo = opts.length ? rangeFrom + opts.length : chunkLength;
    const len = opts.length || chunkLength - rangeFrom;
    if (rangeFrom < 0 || rangeFrom < 0 || rangeTo > chunkLength) throw new Error("Invalid offset and/or length");
    if (rangeFrom === rangeTo) return new Uint8Array(0);
    if (!this.files || this.chunks[index]) {
      const chunk = await this._getChunkHandle(index);
      let file = await chunk.getFile();
      if (rangeFrom !== 0 || len !== chunkLength) {
        file = file.slice(rangeFrom, len + rangeFrom);
      }
      const buf2 = await file.arrayBuffer();
      if (buf2.byteLength === 0) throw new Error(`Index ${index} does not exist`);
      return new Uint8Array(buf2);
    }
    let targets = this.chunkMap[index];
    if (!targets) throw new Error("No files matching the request range");
    if (opts) {
      targets = targets.filter(({ from, to }) => to > rangeFrom && from < rangeTo);
      if (targets.length === 0) throw new Error("No files matching the request range");
    }
    const promises = targets.map(async ({ from, to, offset, file }) => {
      if (opts) {
        if (to > rangeTo) to = rangeTo;
        if (from < rangeFrom) {
          offset += rangeFrom - from;
          from = rangeFrom;
        }
      }
      const blob = await file.blob;
      return blob.slice(offset, offset + to - from);
    });
    const values = await Promise.all(promises);
    const buf = values.length === 1 ? await values[0].arrayBuffer() : await new Blob(values).arrayBuffer();
    if (buf.byteLength === 0) throw new Error(`Index ${index} does not exist`);
    return new Uint8Array(buf);
  }
  async close(cb = noop3) {
    if (this.closing) return err(cb, "Storage is closed");
    this.closing = true;
    this.chunkMap = void 0;
    this.directoryMap = void 0;
    if (this.files) await this.cleanup();
    this.closed = true;
    queueMicrotask(() => cb(null));
  }
  async cleanup() {
    if (this.closed || !this.files) return;
    const streams = [];
    for (const file of this.files) {
      if (file.stream) {
        streams.push(file.stream.then((stream) => stream.close()));
        file.stream = void 0;
      }
    }
    const clearChunks = (async () => {
      const storageDir = await this.chunksDirPromise;
      this.chunks = [];
      for await (const key of storageDir.keys()) {
        await storageDir.removeEntry(key, { recursive: true });
      }
      this.chunksDirPromise = this._getChunksDirHandle();
      await this.chunksDirPromise;
    })();
    await Promise.all(streams);
    for (const file of this.files) {
      file.blob = this._createBlobReference(file.handle);
    }
    await clearChunks;
  }
  async destroy(cb = noop3) {
    this.close(async (err2) => {
      if (err2) return cb(err2);
      try {
        const rootDir = await this.rootDirPromise;
        await rootDir.removeEntry(this.name, { recursive: true });
      } catch (err3) {
        return cb(err3);
      }
      cb(null);
    });
  }
};

// node_modules/webtorrent/lib/torrent.js
var import_immediate_chunk_store = __toESM(require_immediate_chunk_store(), 1);

// node_modules/lt_donthave/index.js
var import_unordered_array_remove = __toESM(require_unordered_array_remove());
var import_events5 = __toESM(require_events());
var import_debug7 = __toESM(require_browser());
var debug7 = (0, import_debug7.default)("lt_donthave");
var lt_donthave_default = () => {
  class ltDontHave extends import_events5.EventEmitter {
    constructor(wire) {
      super();
      this._peerSupports = false;
      this._wire = wire;
    }
    onExtendedHandshake() {
      this._peerSupports = true;
    }
    onMessage(buf) {
      let index;
      try {
        const view = new DataView(buf.buffer);
        index = view.getUint32(0);
      } catch (err2) {
        return;
      }
      if (!this._wire.peerPieces.get(index)) return;
      debug7("got donthave %d", index);
      this._wire.peerPieces.set(index, false);
      this.emit("donthave", index);
      this._failRequests(index);
    }
    donthave(index) {
      if (!this._peerSupports) return;
      debug7("donthave %d", index);
      const buf = new Uint8Array(4);
      const view = new DataView(buf.buffer);
      view.setUint32(0, index);
      this._wire.extended("lt_donthave", buf);
    }
    _failRequests(index) {
      const requests = this._wire.requests;
      for (let i = 0; i < requests.length; i++) {
        const req = requests[i];
        if (req.piece === index) {
          (0, import_unordered_array_remove.default)(requests, i);
          i -= 1;
          this._wire._callback(req, new Error("peer sent donthave"), null);
        }
      }
    }
  }
  ltDontHave.prototype.name = "lt_donthave";
  return ltDontHave;
};

// node_modules/webtorrent/lib/torrent.js
var import_memory_chunk_store = __toESM(require_memory_chunk_store(), 1);
var import_join_async_iterator2 = __toESM(require_join_async_iterator(), 1);
var import_run_parallel4 = __toESM(require_run_parallel(), 1);
var import_run_parallel_limit = __toESM(require_run_parallel_limit(), 1);

// node_modules/torrent-piece/index.js
var BLOCK_LENGTH = 1 << 14;
var Piece = class {
  constructor(length) {
    this.length = length;
    this.missing = length;
    this.sources = null;
    this._chunks = Math.ceil(length / BLOCK_LENGTH);
    this._remainder = length % BLOCK_LENGTH || BLOCK_LENGTH;
    this._buffered = 0;
    this._buffer = null;
    this._cancellations = null;
    this._reservations = 0;
    this._flushed = false;
  }
  chunkLength(i) {
    return i === this._chunks - 1 ? this._remainder : BLOCK_LENGTH;
  }
  chunkLengthRemaining(i) {
    return this.length - i * BLOCK_LENGTH;
  }
  chunkOffset(i) {
    return i * BLOCK_LENGTH;
  }
  reserve() {
    if (!this.init()) return -1;
    if (this._cancellations.length) return this._cancellations.pop();
    if (this._reservations < this._chunks) return this._reservations++;
    return -1;
  }
  reserveRemaining() {
    if (!this.init()) return -1;
    if (this._cancellations.length || this._reservations < this._chunks) {
      let min = this._reservations;
      while (this._cancellations.length) {
        min = Math.min(min, this._cancellations.pop());
      }
      this._reservations = this._chunks;
      return min;
    }
    return -1;
  }
  cancel(i) {
    if (!this.init()) return;
    this._cancellations.push(i);
  }
  cancelRemaining(i) {
    if (!this.init()) return;
    this._reservations = i;
  }
  get(i) {
    if (!this.init()) return null;
    return this._buffer[i];
  }
  set(i, data, source) {
    if (!this.init()) return false;
    const len = data.length;
    const blocks = Math.ceil(len / BLOCK_LENGTH);
    for (let j = 0; j < blocks; j++) {
      if (!this._buffer[i + j]) {
        const offset = j * BLOCK_LENGTH;
        const splitData = data.slice(offset, offset + BLOCK_LENGTH);
        this._buffered++;
        this._buffer[i + j] = splitData;
        this.missing -= splitData.length;
        if (!this.sources.includes(source)) {
          this.sources.push(source);
        }
      }
    }
    return this._buffered === this._chunks;
  }
  flush() {
    if (!this._buffer || this._chunks !== this._buffered) return null;
    const buffer = concat(this._buffer, this.length);
    this._buffer = null;
    this._cancellations = null;
    this.sources = null;
    this._flushed = true;
    return buffer;
  }
  init() {
    if (this._flushed) return false;
    if (this._buffer) return true;
    this._buffer = new Array(this._chunks);
    this._cancellations = [];
    this.sources = [];
    return true;
  }
};
Piece.BLOCK_LENGTH = BLOCK_LENGTH;

// node_modules/webtorrent/lib/torrent.js
var import_queue_microtask5 = __toESM(require_queue_microtask(), 1);
var import_random_iterate = __toESM(require_random_iterate(), 1);
var import_throughput = __toESM(require_throughput(), 1);

// node_modules/ut_metadata/index.js
var import_events6 = __toESM(require_events());
var import_debug8 = __toESM(require_browser());
var debug8 = (0, import_debug8.default)("ut_metadata");
var MAX_METADATA_SIZE = 1e7;
var BITFIELD_GROW = 1e3;
var PIECE_LENGTH = 1 << 14;
var ut_metadata_default = (metadata) => {
  class utMetadata extends import_events6.EventEmitter {
    constructor(wire) {
      super();
      this._wire = wire;
      this._fetching = false;
      this._metadataComplete = false;
      this._metadataSize = null;
      this._remainingRejects = null;
      this._bitfield = new BitField(0, { grow: BITFIELD_GROW });
      if (ArrayBuffer.isView(metadata)) {
        this.setMetadata(metadata);
      }
    }
    onHandshake(infoHash, peerId, extensions) {
      this._infoHash = infoHash;
    }
    onExtendedHandshake(handshake) {
      if (!handshake.m || !handshake.m.ut_metadata) {
        return this.emit("warning", new Error("Peer does not support ut_metadata"));
      }
      if (!handshake.metadata_size) {
        return this.emit("warning", new Error("Peer does not have metadata"));
      }
      if (typeof handshake.metadata_size !== "number" || MAX_METADATA_SIZE < handshake.metadata_size || handshake.metadata_size <= 0) {
        return this.emit("warning", new Error("Peer gave invalid metadata size"));
      }
      this._metadataSize = handshake.metadata_size;
      this._numPieces = Math.ceil(this._metadataSize / PIECE_LENGTH);
      this._remainingRejects = this._numPieces * 2;
      this._requestPieces();
    }
    onMessage(buf) {
      let dict;
      let trailer;
      try {
        const str = arr2text(buf);
        const trailerIndex = str.indexOf("ee") + 2;
        dict = bencode_default.decode(str.substring(0, trailerIndex));
        trailer = buf.slice(trailerIndex);
      } catch (err2) {
        return;
      }
      switch (dict.msg_type) {
        case 0:
          this._onRequest(dict.piece);
          break;
        case 1:
          this._onData(dict.piece, trailer, dict.total_size);
          break;
        case 2:
          this._onReject(dict.piece);
          break;
      }
    }
    /**
     * Ask the peer to send metadata.
     * @public
     */
    fetch() {
      if (this._metadataComplete) {
        return;
      }
      this._fetching = true;
      if (this._metadataSize) {
        this._requestPieces();
      }
    }
    /**
     * Stop asking the peer to send metadata.
     * @public
     */
    cancel() {
      this._fetching = false;
    }
    async setMetadata(metadata2) {
      if (this._metadataComplete) return true;
      debug8("set metadata");
      try {
        const info = bencode_default.decode(metadata2).info;
        if (info) {
          metadata2 = bencode_default.encode(info);
        }
      } catch (err2) {
      }
      if (this._infoHash && this._infoHash !== await hash(metadata2, "hex")) {
        return false;
      }
      this.cancel();
      this.metadata = metadata2;
      this._metadataComplete = true;
      this._metadataSize = this.metadata.length;
      this._wire.extendedHandshake.metadata_size = this._metadataSize;
      this.emit("metadata", bencode_default.encode({
        info: bencode_default.decode(this.metadata)
      }));
      return true;
    }
    _send(dict, trailer) {
      let buf = bencode_default.encode(dict);
      if (ArrayBuffer.isView(trailer)) {
        buf = concat([buf, trailer]);
      }
      this._wire.extended("ut_metadata", buf);
    }
    _request(piece) {
      this._send({ msg_type: 0, piece });
    }
    _data(piece, buf, totalSize) {
      const msg = { msg_type: 1, piece };
      if (typeof totalSize === "number") {
        msg.total_size = totalSize;
      }
      this._send(msg, buf);
    }
    _reject(piece) {
      this._send({ msg_type: 2, piece });
    }
    _onRequest(piece) {
      if (!this._metadataComplete) {
        this._reject(piece);
        return;
      }
      const start = piece * PIECE_LENGTH;
      let end = start + PIECE_LENGTH;
      if (end > this._metadataSize) {
        end = this._metadataSize;
      }
      const buf = this.metadata.slice(start, end);
      this._data(piece, buf, this._metadataSize);
    }
    _onData(piece, buf, totalSize) {
      if (buf.length > PIECE_LENGTH || !this._fetching) {
        return;
      }
      this.metadata.set(buf, piece * PIECE_LENGTH);
      this._bitfield.set(piece);
      this._checkDone();
    }
    _onReject(piece) {
      if (this._remainingRejects > 0 && this._fetching) {
        this._request(piece);
        this._remainingRejects -= 1;
      } else {
        this.emit("warning", new Error('Peer sent "reject" too much'));
      }
    }
    _requestPieces() {
      if (!this._fetching) return;
      this.metadata = new Uint8Array(this._metadataSize);
      for (let piece = 0; piece < this._numPieces; piece++) {
        this._request(piece);
      }
    }
    async _checkDone() {
      let done = true;
      for (let piece = 0; piece < this._numPieces; piece++) {
        if (!this._bitfield.get(piece)) {
          done = false;
          break;
        }
      }
      if (!done) return;
      const success = await this.setMetadata(this.metadata);
      if (!success) {
        this._failedMetadata();
      }
    }
    _failedMetadata() {
      this._bitfield = new BitField(0, { grow: BITFIELD_GROW });
      this._remainingRejects -= this._numPieces;
      if (this._remainingRejects > 0) {
        this._requestPieces();
      } else {
        this.emit("warning", new Error("Peer sent invalid metadata"));
      }
    }
  }
  utMetadata.prototype.name = "ut_metadata";
  return utMetadata;
};

// node_modules/webtorrent/lib/torrent.js
var import_ut_pex = __toESM(require_ut_pex(), 1);

// node_modules/webtorrent/lib/file.js
var import_events8 = __toESM(require_events(), 1);
var import_streamx3 = __toESM(require_streamx(), 1);
var import_lite3 = __toESM(require_lite(), 1);

// node_modules/webtorrent/lib/file-iterator.js
var import_debug9 = __toESM(require_browser(), 1);
var import_events7 = __toESM(require_events(), 1);
var debug9 = (0, import_debug9.default)("webtorrent:file-iterator");
var FileIterator = class extends import_events7.default {
  constructor(file, { start, end }) {
    super();
    this._torrent = file._torrent;
    this._pieceLength = file._torrent.pieceLength;
    this._startPiece = (start + file.offset) / this._pieceLength | 0;
    this._endPiece = (end + file.offset) / this._pieceLength | 0;
    this._piece = this._startPiece;
    this._offset = start + file.offset - this._startPiece * this._pieceLength;
    this._missing = end - start + 1;
    this._criticalLength = Math.min(1024 * 1024 / this._pieceLength | 0, 2);
    this._torrent._select(this._startPiece, this._endPiece, 1, null, true);
    this.destroyed = false;
  }
  [Symbol.asyncIterator]() {
    return this;
  }
  next() {
    return new Promise((resolve, reject) => {
      if (this._missing === 0 || this.destroyed) {
        resolve({ done: true });
        return this.destroy();
      }
      const pump2 = (index, opts) => {
        if (!this._torrent.bitfield.get(index)) {
          const listener = (i) => {
            if (i === index || this.destroyed) {
              this._torrent.removeListener("verified", listener);
              pump2(index, opts);
            }
          };
          this._torrent.on("verified", listener);
          return this._torrent.critical(index, index + this._criticalLength);
        }
        if (this._torrent.destroyed) return reject(new Error("Torrent removed"));
        this._torrent.store.get(index, opts, (err2, buffer) => {
          if (this.destroyed) return resolve({ done: true });
          debug9("read %s and yielding (length %s) (err %s)", index, buffer == null ? void 0 : buffer.length, err2 == null ? void 0 : err2.message);
          if (err2) return reject(err2);
          resolve({ value: buffer, done: false });
        });
      };
      const length = Math.min(this._missing, this._pieceLength - this._offset);
      pump2(this._piece++, { length, offset: this._offset });
      this._missing -= length;
      this._offset = 0;
    });
  }
  async return() {
    this.destroy();
    return { done: true };
  }
  async throw(err2) {
    throw err2;
  }
  destroy(cb = () => {
  }, err2) {
    if (this.destroyed) return;
    this.destroyed = true;
    if (!this._torrent.destroyed) {
      this._torrent._deselect(this._startPiece, this._endPiece, true);
    }
    this.emit("return");
    cb(err2);
  }
};

// node_modules/webtorrent/lib/file.js
var File2 = class extends import_events8.default {
  constructor(torrent, file) {
    super();
    this._torrent = torrent;
    this._destroyed = false;
    this._fileStreams = /* @__PURE__ */ new Set();
    this._iterators = /* @__PURE__ */ new Set();
    this.name = file.name;
    this.path = file.path;
    this.length = file.length;
    this.size = file.length;
    this.type = import_lite3.default.getType(this.name) || "application/octet-stream";
    this.offset = file.offset;
    this.done = false;
    const start = file.offset;
    const end = start + file.length - 1;
    this._startPiece = start / this._torrent.pieceLength | 0;
    this._endPiece = end / this._torrent.pieceLength | 0;
    if (this.length === 0) {
      this.done = true;
      this.emit("done");
    }
    this._client = torrent.client;
  }
  get downloaded() {
    if (this._destroyed || !this._torrent.bitfield) return 0;
    const { pieces, bitfield, pieceLength, lastPieceLength } = this._torrent;
    const { _startPiece: start, _endPiece: end } = this;
    const getPieceLength = (pieceIndex) => pieceIndex === pieces.length - 1 ? lastPieceLength : pieceLength;
    const getPieceDownloaded = (pieceIndex) => {
      const len = pieceIndex === pieces.length - 1 ? lastPieceLength : pieceLength;
      if (bitfield.get(pieceIndex)) {
        return len;
      } else {
        return len - pieces[pieceIndex].missing;
      }
    };
    let downloaded = 0;
    for (let index = start; index <= end; index += 1) {
      const pieceDownloaded = getPieceDownloaded(index);
      downloaded += pieceDownloaded;
      if (index === start) {
        const irrelevantFirstPieceBytes = this.offset % pieceLength;
        downloaded -= Math.min(irrelevantFirstPieceBytes, pieceDownloaded);
      }
      if (index === end) {
        const irrelevantLastPieceBytes = getPieceLength(end) - (this.offset + this.length) % pieceLength;
        downloaded -= Math.min(irrelevantLastPieceBytes, pieceDownloaded);
      }
    }
    return downloaded;
  }
  get progress() {
    return this.length ? this.downloaded / this.length : 0;
  }
  select(priority) {
    if (this.length === 0) return;
    this._torrent.select(this._startPiece, this._endPiece, priority);
  }
  deselect() {
    if (this.length === 0) return;
    this._torrent.deselect(this._startPiece, this._endPiece);
  }
  [Symbol.asyncIterator](opts = {}) {
    if (this.length === 0) return async function* empty() {
    }();
    const { start = 0 } = opts ?? {};
    const end = (opts == null ? void 0 : opts.end) && opts.end < this.length ? opts.end : this.length - 1;
    if (this.done) {
      return chunkStoreRead(this._torrent.store, { offset: start + this.offset, length: end - start + 1 });
    }
    const iterator = new FileIterator(this, { start, end });
    this._iterators.add(iterator);
    iterator.once("return", () => {
      this._iterators.delete(iterator);
    });
    return iterator;
  }
  createReadStream(opts) {
    const iterator = this[Symbol.asyncIterator](opts);
    const fileStream = import_streamx3.Readable.from(iterator);
    this._fileStreams.add(fileStream);
    fileStream.once("close", () => {
      this._fileStreams.delete(fileStream);
    });
    return fileStream;
  }
  async arrayBuffer(opts = {}) {
    const { start = 0 } = opts;
    const end = (opts == null ? void 0 : opts.end) && opts.end < this.length ? opts.end : this.length - 1;
    const data = new Uint8Array(end - start + 1);
    let offset = 0;
    for await (const chunk of this[Symbol.asyncIterator]({ start, end })) {
      data.set(chunk, offset);
      offset += chunk.length;
    }
    return data.buffer;
  }
  async blob(opts) {
    return new Blob([await this.arrayBuffer(opts)], { type: this.type });
  }
  stream(opts) {
    let iterator;
    return new ReadableStream({
      start: () => {
        iterator = this[Symbol.asyncIterator](opts);
      },
      async pull(controller) {
        const { value, done } = await iterator.next();
        if (done) {
          controller.close();
        } else {
          controller.enqueue(value);
        }
      },
      cancel() {
        iterator.return();
      }
    });
  }
  get streamURL() {
    if (!this._client._server) throw new Error("No server created");
    return `${this._client._server.pathname}/${this._torrent.infoHash}/${this.path}`;
  }
  streamTo(elem) {
    elem.src = this.streamURL;
    return elem;
  }
  includes(piece) {
    return this._startPiece <= piece && this._endPiece >= piece;
  }
  _destroy() {
    this._destroyed = true;
    this._torrent = null;
    for (const fileStream of this._fileStreams) {
      fileStream.destroy();
    }
    this._fileStreams.clear();
    for (const iterator of this._iterators) {
      iterator.destroy();
    }
    this._iterators.clear();
  }
};

// node_modules/webtorrent/lib/rarity-map.js
var RarityMap = class {
  constructor(torrent) {
    this._torrent = torrent;
    this._numPieces = torrent.pieces.length;
    this._pieces = new Array(this._numPieces);
    this._onWire = (wire) => {
      this.recalculate();
      this._initWire(wire);
    };
    this._onWireHave = (index) => {
      this._pieces[index] += 1;
    };
    this._onWireBitfield = () => {
      this.recalculate();
    };
    this._torrent.wires.forEach((wire) => {
      this._initWire(wire);
    });
    this._torrent.on("wire", this._onWire);
    this.recalculate();
  }
  /**
   * Get the index of the rarest piece. Optionally, pass a filter function to exclude
   * certain pieces (for instance, those that we already have).
   *
   * @param {function} pieceFilterFunc
   * @return {number} index of rarest piece, or -1
   */
  getRarestPiece(pieceFilterFunc) {
    let candidates = [];
    let min = Infinity;
    for (let i = 0; i < this._numPieces; ++i) {
      if (pieceFilterFunc && !pieceFilterFunc(i)) continue;
      const availability = this._pieces[i];
      if (availability === min) {
        candidates.push(i);
      } else if (availability < min) {
        candidates = [i];
        min = availability;
      }
    }
    if (candidates.length) {
      return candidates[Math.random() * candidates.length | 0];
    } else {
      return -1;
    }
  }
  destroy() {
    this._torrent.removeListener("wire", this._onWire);
    this._torrent.wires.forEach((wire) => {
      this._cleanupWireEvents(wire);
    });
    this._torrent = null;
    this._pieces = null;
    this._onWire = null;
    this._onWireHave = null;
    this._onWireBitfield = null;
  }
  _initWire(wire) {
    wire._onClose = () => {
      this._cleanupWireEvents(wire);
      for (let i = 0; i < this._numPieces; ++i) {
        this._pieces[i] -= wire.peerPieces.get(i);
      }
    };
    wire.on("have", this._onWireHave);
    wire.on("bitfield", this._onWireBitfield);
    wire.once("close", wire._onClose);
  }
  /**
   * Recalculates piece availability across all peers in the torrent.
   */
  recalculate() {
    this._pieces.fill(0);
    for (const wire of this._torrent.wires) {
      for (let i = 0; i < this._numPieces; ++i) {
        this._pieces[i] += wire.peerPieces.get(i);
      }
    }
  }
  _cleanupWireEvents(wire) {
    wire.removeListener("have", this._onWireHave);
    wire.removeListener("bitfield", this._onWireBitfield);
    if (wire._onClose) wire.removeListener("close", wire._onClose);
    wire._onClose = null;
  }
};

// node_modules/webtorrent/lib/torrent.js
var import_utp = __toESM(require_utp(), 1);

// node_modules/webtorrent/lib/webconn.js
var import_debug10 = __toESM(require_browser(), 1);
var import_once2 = __toESM(require_once(), 1);
var import_version = __toESM(require_version(), 1);
var debug10 = (0, import_debug10.default)("webtorrent:webconn");
var SOCKET_TIMEOUT = 6e4;
var RETRY_DELAY = 1e4;
var WebConn = class extends bittorrent_protocol_default {
  constructor(url, torrent) {
    super();
    this.url = url;
    this.connId = url;
    this._torrent = torrent;
    this._init(url);
  }
  _init(url) {
    this.setKeepAlive(true);
    this.use(lt_donthave_default());
    this.once("handshake", async (infoHash, peerId) => {
      const hex = await hash(url, "hex");
      if (this.destroyed) return;
      this.handshake(infoHash, hex);
      const numPieces = this._torrent.pieces.length;
      const bitfield = new BitField(numPieces);
      for (let i = 0; i <= numPieces; i++) {
        bitfield.set(i, true);
      }
      this.bitfield(bitfield);
    });
    this.once("interested", () => {
      debug10("interested");
      this.unchoke();
    });
    this.on("uninterested", () => {
      debug10("uninterested");
    });
    this.on("choke", () => {
      debug10("choke");
    });
    this.on("unchoke", () => {
      debug10("unchoke");
    });
    this.on("bitfield", () => {
      debug10("bitfield");
    });
    this.lt_donthave.on("donthave", () => {
      debug10("donthave");
    });
    this.on("request", (pieceIndex, offset, length, callback) => {
      debug10("request pieceIndex=%d offset=%d length=%d", pieceIndex, offset, length);
      this.httpRequest(pieceIndex, offset, length, (err2, data) => {
        if (err2) {
          this.lt_donthave.donthave(pieceIndex);
          const retryTimeout = setTimeout(() => {
            if (this.destroyed) return;
            this.have(pieceIndex);
          }, RETRY_DELAY);
          if (retryTimeout.unref) retryTimeout.unref();
        }
        callback(err2, data);
      });
    });
  }
  async httpRequest(pieceIndex, offset, length, cb) {
    cb = (0, import_once2.default)(cb);
    const pieceOffset = pieceIndex * this._torrent.pieceLength;
    const rangeStart = pieceOffset + offset;
    const rangeEnd = rangeStart + length - 1;
    const files = this._torrent.files;
    let requests;
    if (files.length <= 1) {
      requests = [{
        url: this.url,
        start: rangeStart,
        end: rangeEnd
      }];
    } else {
      const requestedFiles = files.filter((file) => file.offset <= rangeEnd && file.offset + file.length > rangeStart);
      if (requestedFiles.length < 1) {
        return cb(new Error("Could not find file corresponding to web seed range request"));
      }
      requests = requestedFiles.map((requestedFile) => {
        const fileEnd = requestedFile.offset + requestedFile.length - 1;
        const url = this.url + (this.url[this.url.length - 1] === "/" ? "" : "/") + requestedFile.path.replace(this._torrent.path, "");
        return {
          url,
          fileOffsetInRange: Math.max(requestedFile.offset - rangeStart, 0),
          start: Math.max(rangeStart - requestedFile.offset, 0),
          end: Math.min(fileEnd, rangeEnd - requestedFile.offset)
        };
      });
    }
    let chunks;
    try {
      chunks = await Promise.all(requests.map(async ({ start, end, url }) => {
        debug10(
          "Requesting url=%s pieceIndex=%d offset=%d length=%d start=%d end=%d",
          url,
          pieceIndex,
          offset,
          length,
          start,
          end
        );
        const res = await browser_default(url, {
          cache: "no-store",
          method: "GET",
          headers: {
            "Cache-Control": "no-store",
            "user-agent": `WebTorrent/${import_version.default} (https://webtorrent.io)`,
            range: `bytes=${start}-${end}`
          },
          signal: AbortSignal.timeout(SOCKET_TIMEOUT)
        });
        if (!res.ok) throw new Error(`Unexpected HTTP status code ${res.status}`);
        const data = new Uint8Array(await res.arrayBuffer());
        debug10("Got data of length %d", data.length);
        return data;
      }));
    } catch (e) {
      return cb(e);
    }
    cb(null, concat(chunks));
  }
  destroy() {
    super.destroy();
    this._torrent = null;
  }
};

// node_modules/webtorrent/lib/selections.js
var Selections = class {
  constructor() {
    /** @type {Array<SelectionItem>} */
    __publicField(this, "_items", []);
  }
  /**
   * @param {MinimalSelectionItem & {isStreamSelection?: boolean}} item Interval to be removed from the selection
   */
  remove(item) {
    for (let i = 0; i < this._items.length; i++) {
      const existing = this._items[i];
      if (existing.isStreamSelection) {
        if (item.isStreamSelection) {
          if (existing.from === item.from && existing.to === item.to) {
            this._items.splice(i, 1);
            break;
          }
        } else {
          continue;
        }
      } else {
        if (isLowerIntersecting(item, existing)) {
          existing.to = Math.max(item.from - 1, 0);
        } else if (isUpperIntersecting(item, existing)) {
          existing.from = item.to + 1;
        } else if (isInsideExisting(item, existing)) {
          const replacingItems = [];
          const existingStart = { ...existing, to: Math.max(item.from - 1, 0) };
          if (existingStart.to - existingStart.from >= 0 && item.from !== 0) replacingItems.push(existingStart);
          const existingEnd = { ...existing, from: item.to + 1 };
          if (existingEnd.to - existingEnd.from >= 0) replacingItems.push(existingEnd);
          this._items.splice(i, 1, ...replacingItems);
          i = i - 1 + replacingItems.length;
        } else if (isCoveringExisting(item, existing)) {
          this._items.splice(i, 1);
          i--;
        }
      }
    }
  }
  /**
   * @param {SelectionItem & NotificationItem} newItem
   */
  insert(newItem) {
    if (newItem.from > newItem.to) {
      throw new Error("Invalid interval");
    }
    if (!newItem.isStreamSelection) {
      const { notify: oldNotify } = newItem;
      const intersectingNotifyFunctions = [];
      for (const existing of this._items) {
        if (existing.notify && isIntersecting(newItem, existing)) {
          intersectingNotifyFunctions.push(existing.notify);
        }
      }
      if (intersectingNotifyFunctions.length > 0) {
        newItem.notify = () => {
          intersectingNotifyFunctions.forEach((fn) => fn());
          oldNotify == null ? void 0 : oldNotify();
        };
      }
      this.remove(newItem);
    }
    this._items.push(newItem);
  }
  /** @param {(a: SelectionItem, b: SelectionItem) => number} sortFn */
  sort(sortFn = (a, b) => a.from - b.from) {
    this._items.sort(sortFn);
  }
  get length() {
    return this._items.length;
  }
  /**  @param {number} index */
  get(index) {
    return this._items[index];
  }
  swap(i, j) {
    const temp = this._items[i];
    this._items[i] = this._items[j];
    this._items[j] = temp;
  }
  clear() {
    this._items.length = 0;
  }
  /** @returns {Generator<SelectionItem & {remove: () => void, replaceWith: (MinimalSelectionItem[]) => void}>} */
  *[Symbol.iterator]() {
    for (let i = 0; i < this._items.length; i++) {
      const item = this._items[i];
      item.remove = () => {
        this._items.splice(i, 1);
        i--;
      };
      yield item;
      delete item.remove;
    }
  }
};
function isLowerIntersecting(newItem, existing) {
  return newItem.from <= existing.to && newItem.from > existing.from && newItem.to > existing.to;
}
function isUpperIntersecting(newItem, existing) {
  return newItem.to >= existing.from && newItem.to < existing.to && newItem.from < existing.from;
}
function isInsideExisting(newItem, existing) {
  const existingIntervalSize = existing.to - existing.from;
  const newItemIntervalSize = newItem.to - newItem.from;
  return newItem.from >= existing.from && newItem.to <= existing.to && newItemIntervalSize < existingIntervalSize;
}
function isCoveringExisting(newItem, existing) {
  return newItem.from <= existing.from && newItem.to >= existing.to;
}
var isIntersecting = (newItem, existing) => () => isLowerIntersecting(newItem, existing) || isUpperIntersecting(newItem, existing) || isInsideExisting(newItem, existing) || isCoveringExisting(newItem, existing);

// node_modules/webtorrent/lib/torrent.js
var import_version2 = __toESM(require_version(), 1);
var debug11 = (0, import_debug11.default)("webtorrent:torrent");
var MAX_BLOCK_LENGTH = 128 * 1024;
var PIECE_TIMEOUT = 3e4;
var CHOKE_TIMEOUT = 5e3;
var SPEED_THRESHOLD = 3 * Piece.BLOCK_LENGTH;
var PIPELINE_MIN_DURATION = 0.5;
var PIPELINE_MAX_DURATION = 1;
var RECHOKE_INTERVAL = 1e4;
var RECHOKE_OPTIMISTIC_DURATION = 2;
var DEFAULT_NO_PEERS_INTERVAL = 3e4;
var FILESYSTEM_CONCURRENCY = process.browser ? (0, import_cpus.default)().length : 2;
var RECONNECT_WAIT = [1e3, 5e3, 15e3];
var USER_AGENT = `WebTorrent/${import_version2.default} (https://webtorrent.io)`;
var _a2, _b2, _c, _d;
var SUPPORTS_FSA = ((_b2 = (_a2 = globalThis.navigator) == null ? void 0 : _a2.storage) == null ? void 0 : _b2.getDirectory) && ((_d = (_c = globalThis.FileSystemFileHandle) == null ? void 0 : _c.prototype) == null ? void 0 : _d.createWritable);
var FALLBACK_STORE = !process.browser || SUPPORTS_FSA ? FSAChunkStore : import_memory_chunk_store.default;
var TMP;
try {
  TMP = import_path3.default.join(import_fs2.default.statSync("/tmp") && "/tmp", "webtorrent");
} catch (err2) {
  TMP = import_path3.default.join(typeof import_os.default.tmpdir === "function" ? import_os.default.tmpdir() : "/", "webtorrent");
}
var IDLE_CALLBACK = typeof window !== "undefined" && typeof window.requestIdleCallback === "function" && window.requestIdleCallback;
var Torrent = class extends import_events9.default {
  constructor(torrentId, client, opts) {
    super();
    this._debugId = "unknown infohash";
    this.client = client;
    this.announce = opts.announce;
    this.urlList = opts.urlList;
    this.path = opts.path || TMP;
    this.addUID = opts.addUID || false;
    this.rootDir = opts.rootDir || null;
    this.skipVerify = !!opts.skipVerify;
    this._store = opts.store || FALLBACK_STORE;
    this._preloadedStore = opts.preloadedStore || null;
    this._storeCacheSlots = opts.storeCacheSlots !== void 0 ? opts.storeCacheSlots : 20;
    this._destroyStoreOnDestroy = opts.destroyStoreOnDestroy || false;
    this.store = null;
    this.storeOpts = opts.storeOpts;
    this.alwaysChokeSeeders = opts.alwaysChokeSeeders ?? true;
    this._getAnnounceOpts = opts.getAnnounceOpts;
    if (typeof opts.private === "boolean") this.private = opts.private;
    this.strategy = opts.strategy || "sequential";
    this.maxWebConns = opts.maxWebConns || 4;
    this._rechokeNumSlots = opts.uploads === false || opts.uploads === 0 ? 0 : +opts.uploads || 10;
    this._rechokeOptimisticWire = null;
    this._rechokeOptimisticTime = 0;
    this._rechokeIntervalId = null;
    this._noPeersIntervalId = null;
    this._noPeersIntervalTime = opts.noPeersIntervalTime ? opts.noPeersIntervalTime * 1e3 : DEFAULT_NO_PEERS_INTERVAL;
    this._startAsDeselected = opts.deselect || false;
    this.ready = false;
    this.destroyed = false;
    this.paused = opts.paused || false;
    this.done = false;
    this.metadata = null;
    this.files = [];
    this.pieces = [];
    this._amInterested = false;
    this._selections = new Selections();
    this._critical = [];
    this.wires = [];
    this._queue = [];
    this._peers = {};
    this._peersLength = 0;
    this.received = 0;
    this.uploaded = 0;
    this._downloadSpeed = (0, import_throughput.default)();
    this._uploadSpeed = (0, import_throughput.default)();
    this._servers = [];
    this._xsRequests = [];
    this._fileModtimes = opts.fileModtimes;
    if (torrentId !== null) this._onTorrentId(torrentId);
    this._debug("new torrent");
  }
  get timeRemaining() {
    if (this.done) return 0;
    if (this.downloadSpeed === 0) return Infinity;
    return (this.length - this.downloaded) / this.downloadSpeed * 1e3;
  }
  get downloaded() {
    if (!this.bitfield) return 0;
    let downloaded = 0;
    for (let index = 0, len = this.pieces.length; index < len; ++index) {
      if (this.bitfield.get(index)) {
        downloaded += index === len - 1 ? this.lastPieceLength : this.pieceLength;
      } else {
        const piece = this.pieces[index];
        downloaded += piece.length - piece.missing;
      }
    }
    return downloaded;
  }
  // TODO: re-enable this. The number of missing pieces. Used to implement 'end game' mode.
  // Object.defineProperty(Storage.prototype, 'numMissing', {
  //   get: function () {
  //     var self = this
  //     var numMissing = self.pieces.length
  //     for (var index = 0, len = self.pieces.length; index < len; index++) {
  //       numMissing -= self.bitfield.get(index)
  //     }
  //     return numMissing
  //   }
  // })
  get downloadSpeed() {
    return this._downloadSpeed();
  }
  get uploadSpeed() {
    return this._uploadSpeed();
  }
  get progress() {
    return this.length ? this.downloaded / this.length : 0;
  }
  get ratio() {
    return this.uploaded / (this.received || this.length);
  }
  get numPeers() {
    return this.wires.length;
  }
  get torrentFileBlob() {
    if (!this.torrentFile) return null;
    return new Blob([this.torrentFile], { type: "application/x-bittorrent" });
  }
  get _numQueued() {
    return this._queue.length + (this._peersLength - this._numConns);
  }
  get _numConns() {
    let numConns = 0;
    for (const id in this._peers) {
      if (this._peers[id].connected) numConns += 1;
    }
    return numConns;
  }
  async _onTorrentId(torrentId) {
    if (this.destroyed) return;
    let parsedTorrent;
    try {
      parsedTorrent = await parse_torrent_default(torrentId);
    } catch (err2) {
    }
    if (parsedTorrent) {
      this.infoHash = parsedTorrent.infoHash;
      this._debugId = arr2hex(parsedTorrent.infoHash).substring(0, 7);
      (0, import_queue_microtask5.default)(() => {
        if (this.destroyed) return;
        this._onParsedTorrent(parsedTorrent);
      });
    } else {
      parseTorrentRemote(torrentId, (err2, parsedTorrent2) => {
        if (this.destroyed) return;
        if (err2) return this._destroy(err2);
        this._onParsedTorrent(parsedTorrent2);
      });
    }
  }
  _onParsedTorrent(parsedTorrent) {
    if (this.destroyed) return;
    this._processParsedTorrent(parsedTorrent);
    if (!this.infoHash) {
      return this._destroy(new Error("Malformed torrent data: No info hash"));
    }
    this._rechokeIntervalId = setInterval(() => {
      this._rechoke();
    }, RECHOKE_INTERVAL);
    if (this._rechokeIntervalId.unref) this._rechokeIntervalId.unref();
    this.emit("_infoHash", this.infoHash);
    if (this.destroyed) return;
    this.emit("infoHash", this.infoHash);
    if (this.destroyed) return;
    if (this.client.listening) {
      this._onListening();
    } else {
      this.client.once("listening", () => {
        this._onListening();
      });
    }
  }
  _processParsedTorrent(parsedTorrent) {
    this._debugId = arr2hex(parsedTorrent.infoHash).substring(0, 7);
    if (typeof this.private !== "undefined") {
      parsedTorrent.private = this.private;
    }
    if (Array.isArray(this.announce)) {
      parsedTorrent.announce = parsedTorrent.announce.concat(this.announce);
    }
    if (this.client.tracker && Array.isArray(this.client.tracker.announce) && !parsedTorrent.private) {
      parsedTorrent.announce = parsedTorrent.announce.concat(this.client.tracker.announce);
    }
    if (this.client.tracker && global.WEBTORRENT_ANNOUNCE && !parsedTorrent.private) {
      parsedTorrent.announce = parsedTorrent.announce.concat(global.WEBTORRENT_ANNOUNCE);
    }
    if (this.urlList) {
      parsedTorrent.urlList = parsedTorrent.urlList.concat(this.urlList);
    }
    parsedTorrent.announce = Array.from(new Set(parsedTorrent.announce));
    parsedTorrent.urlList = Array.from(new Set(parsedTorrent.urlList));
    Object.assign(this, parsedTorrent);
    this.magnetURI = toMagnetURI(parsedTorrent);
    this.torrentFile = encodeTorrentFile(parsedTorrent);
  }
  _onListening() {
    if (this.destroyed) return;
    if (this.info) {
      this._onMetadata(this);
    } else {
      if (this.xs) this._getMetadataFromServer();
      this._startDiscovery();
    }
  }
  _startDiscovery() {
    if (this.discovery || this.destroyed) return;
    let trackerOpts = this.client.tracker;
    if (trackerOpts) {
      trackerOpts = Object.assign({}, this.client.tracker, {
        getAnnounceOpts: () => {
          if (this.destroyed) return;
          const opts = {
            uploaded: this.uploaded,
            downloaded: this.downloaded,
            left: Math.max(this.length - this.downloaded, 0)
          };
          if (this.client.tracker.getAnnounceOpts) {
            Object.assign(opts, this.client.tracker.getAnnounceOpts());
          }
          if (this._getAnnounceOpts) {
            Object.assign(opts, this._getAnnounceOpts());
          }
          return opts;
        }
      });
    }
    if (this.peerAddresses) {
      this.peerAddresses.forEach((peer) => this.addPeer(peer, Peer.SOURCE_MANUAL));
    }
    this.discovery = new torrent_discovery_default({
      infoHash: this.infoHash,
      announce: this.announce,
      peerId: this.client.peerId,
      dht: !this.private && this.client.dht,
      tracker: trackerOpts,
      port: this.client.torrentPort,
      userAgent: USER_AGENT,
      lsd: this.client.lsd
    });
    this.discovery.on("error", (err2) => {
      this._destroy(err2);
    });
    this.discovery.on("peer", (peer, source) => {
      this._debug("peer %s discovered via %s", peer, source);
      if (!this.client.seedOutgoingConnections && this.done) {
        this._debug("ignoring peer %s: torrent is done and seedOutgoingConnections is false", peer);
        return;
      }
      this.addPeer(peer, source);
    });
    this.discovery.on("trackerAnnounce", () => {
      this.emit("trackerAnnounce");
    });
    this.discovery.on("dhtAnnounce", () => {
      this.emit("dhtAnnounce");
    });
    this.discovery.on("warning", (err2) => {
      this.emit("warning", err2);
    });
    this._noPeersIntervalId = setInterval(() => {
      if (this.destroyed) return;
      const counters = {
        [Peer.SOURCE_TRACKER]: {
          enabled: !!this.client.tracker,
          numPeers: 0
        },
        [Peer.SOURCE_DHT]: {
          enabled: !!this.client.dht,
          numPeers: 0
        },
        [Peer.SOURCE_LSD]: {
          enabled: !!this.client.lsd,
          numPeers: 0
        },
        [Peer.SOURCE_UT_PEX]: {
          enabled: this.client.utPex && typeof import_ut_pex.default === "function",
          numPeers: 0
        }
      };
      for (const peer of Object.values(this._peers)) {
        const counter = counters[peer.source];
        if (typeof counter !== "undefined") counter.numPeers++;
      }
      for (const source of Object.keys(counters)) {
        const counter = counters[source];
        if (counter.enabled && counter.numPeers === 0) this.emit("noPeers", source);
      }
    }, this._noPeersIntervalTime);
    if (this._noPeersIntervalId.unref) this._noPeersIntervalId.unref();
  }
  _getMetadataFromServer() {
    const self2 = this;
    const urls = Array.isArray(this.xs) ? this.xs : [this.xs];
    self2._xsRequestsController = new AbortController();
    const signal = self2._xsRequestsController.signal;
    const tasks = urls.map((url) => (cb) => {
      getMetadataFromURL(url, cb);
    });
    (0, import_run_parallel4.default)(tasks);
    async function getMetadataFromURL(url, cb) {
      if (url.indexOf("http://") !== 0 && url.indexOf("https://") !== 0) {
        self2.emit("warning", new Error(`skipping non-http xs param: ${url}`));
        return cb(null);
      }
      const opts = {
        method: "GET",
        headers: {
          "user-agent": USER_AGENT
        },
        signal
      };
      let res;
      try {
        res = await browser_default(url, opts);
      } catch (err2) {
        self2.emit("warning", new Error(`http error from xs param: ${url}`));
        return cb(null);
      }
      if (self2.destroyed) return cb(null);
      if (self2.metadata) return cb(null);
      if (res.status !== 200) {
        self2.emit("warning", new Error(`non-200 status code ${res.status} from xs param: ${url}`));
        return cb(null);
      }
      let torrent;
      try {
        torrent = new Uint8Array(await res.arrayBuffer());
      } catch (e) {
        self2.emit("warning", e);
        return cb(null);
      }
      let parsedTorrent;
      try {
        parsedTorrent = await parse_torrent_default(torrent);
      } catch (err2) {
      }
      if (!parsedTorrent) {
        self2.emit("warning", new Error(`got invalid torrent file from xs param: ${url}`));
        return cb(null);
      }
      if (parsedTorrent.infoHash !== self2.infoHash) {
        self2.emit("warning", new Error(`got torrent file with incorrect info hash from xs param: ${url}`));
        return cb(null);
      }
      self2._onMetadata(parsedTorrent);
      cb(null);
    }
  }
  /**
   * Called when the full torrent metadata is received.
   */
  async _onMetadata(metadata) {
    var _a3;
    if (this.metadata || this.destroyed) return;
    this._debug("got metadata");
    (_a3 = this._xsRequestsController) == null ? void 0 : _a3.abort();
    this._xsRequestsController = null;
    let parsedTorrent;
    if (metadata && metadata.infoHash) {
      parsedTorrent = metadata;
    } else {
      try {
        parsedTorrent = await parse_torrent_default(metadata);
      } catch (err2) {
        return this._destroy(err2);
      }
    }
    this._processParsedTorrent(parsedTorrent);
    this.metadata = this.torrentFile;
    if (this.client.enableWebSeeds) {
      this.urlList.forEach((url) => {
        this.addWebSeed(url);
      });
    }
    this._rarityMap = new RarityMap(this);
    this.files = this.files.map((file) => new File2(this, file));
    let rawStore = this._preloadedStore;
    if (!rawStore) {
      rawStore = new this._store(this.pieceLength, {
        ...this.storeOpts,
        torrent: this,
        path: this.path,
        files: this.files,
        length: this.length,
        name: this.name + " - " + this.infoHash.slice(0, 8),
        addUID: this.addUID,
        rootDir: this.rootDir,
        max: this._storeCacheSlots
      });
    }
    if (this._storeCacheSlots > 0 && !(rawStore instanceof import_memory_chunk_store.default)) {
      rawStore = new import_cache_chunk_store.default(rawStore, {
        max: this._storeCacheSlots
      });
    }
    this.store = new import_immediate_chunk_store.default(
      rawStore
    );
    if (this.so && !this._startAsDeselected) {
      this.files.forEach((v, i) => {
        if (this.so.includes(i)) {
          this.files[i].select();
        }
      });
    } else {
      if (this.pieces.length !== 0 && !this._startAsDeselected) {
        this.select(0, this.pieces.length - 1, 0);
      }
    }
    this._hashes = this.pieces;
    this.pieces = this.pieces.map((hash2, i) => {
      const pieceLength = i === this.pieces.length - 1 ? this.lastPieceLength : this.pieceLength;
      return new Piece(pieceLength);
    });
    this._reservations = this.pieces.map(() => []);
    this.bitfield = new BitField(this.pieces.length);
    this.emit("metadata");
    if (this.destroyed) return;
    if (this.skipVerify) {
      this._markAllVerified();
      this._onStore();
    } else {
      const onPiecesVerified = (err2) => {
        if (err2) return this._destroy(err2);
        this._debug("done verifying");
        this._onStore();
      };
      this._debug("verifying existing torrent data");
      if (this._fileModtimes && this._store === FSAChunkStore) {
        this.getFileModtimes((err2, fileModtimes) => {
          if (err2) return this._destroy(err2);
          const unchanged = this.files.map((_, index) => fileModtimes[index] === this._fileModtimes[index]).every((x) => x);
          if (unchanged) {
            this._markAllVerified();
            this._onStore();
          } else {
            this._verifyPieces(onPiecesVerified);
          }
        });
      } else {
        this._verifyPieces(onPiecesVerified);
      }
    }
  }
  /*
   * TODO: remove this
   * Gets the last modified time of every file on disk for this torrent.
   * Only valid in Node, not in the browser.
   */
  getFileModtimes(cb) {
    const ret = [];
    (0, import_run_parallel_limit.default)(this.files.map((file, index) => (cb2) => {
      const filePath = this.addUID ? import_path3.default.join(this.name + " - " + this.infoHash.slice(0, 8)) : import_path3.default.join(this.path, file.path);
      import_fs2.default.stat(filePath, (err2, stat) => {
        if (err2 && err2.code !== "ENOENT") return cb2(err2);
        ret[index] = stat && stat.mtime.getTime();
        cb2(null);
      });
    }), FILESYSTEM_CONCURRENCY, (err2) => {
      this._debug("done getting file modtimes");
      cb(err2, ret);
    });
  }
  _verifyPieces(cb) {
    (0, import_run_parallel_limit.default)(this.pieces.map((piece, index) => (cb2) => {
      if (this.destroyed) return cb2(new Error("torrent is destroyed"));
      const getOpts = {};
      if (index === this.pieces.length - 1) {
        getOpts.length = this.lastPieceLength;
      }
      this.store.get(index, getOpts, async (err2, buf) => {
        if (this.destroyed) return cb2(new Error("torrent is destroyed"));
        if (err2) return (0, import_queue_microtask5.default)(() => cb2(null));
        const hex = await hash(buf, "hex");
        if (this.destroyed) return cb2(new Error("torrent is destroyed"));
        if (hex === this._hashes[index]) {
          this._debug("piece verified %s", index);
          this._markVerified(index);
        } else {
          this._markUnverified(index);
          this._debug("piece invalid %s", index);
        }
        cb2(null);
      });
    }), FILESYSTEM_CONCURRENCY, cb);
  }
  rescanFiles(cb) {
    if (this.destroyed) throw new Error("torrent is destroyed");
    if (!cb) cb = noop4;
    this._verifyPieces((err2) => {
      if (err2) {
        this._destroy(err2);
        return cb(err2);
      }
      this._checkDone();
      cb(null);
    });
  }
  _markAllVerified() {
    for (let index = 0; index < this.pieces.length; index++) {
      this._markVerified(index);
    }
  }
  _markVerified(index) {
    this.pieces[index] = null;
    this._reservations[index] = null;
    this.bitfield.set(index, true);
    this.emit("verified", index);
  }
  _markUnverified(index) {
    const len = index === this.pieces.length - 1 ? this.lastPieceLength : this.pieceLength;
    this.pieces[index] = new Piece(len);
    this.bitfield.set(index, false);
    if (!this._startAsDeselected) this.select(index, index, 1);
    this.files.forEach((file) => {
      if (file.done && file.includes(index)) file.done = false;
    });
  }
  _hasAllPieces() {
    for (let index = 0; index < this.pieces.length; index++) {
      if (!this.bitfield.get(index)) return false;
    }
    return true;
  }
  _hasNoPieces() {
    return !this._hasMorePieces(0);
  }
  _hasMorePieces(threshold) {
    let count = 0;
    for (let index = 0; index < this.pieces.length; index++) {
      if (this.bitfield.get(index)) {
        count += 1;
        if (count > threshold) return true;
      }
    }
    return false;
  }
  /**
   * Called when the metadata, listening server, and underlying chunk store is initialized.
   */
  _onStore() {
    if (this.destroyed) return;
    this._debug("on store");
    this._startDiscovery();
    this.ready = true;
    this.emit("ready");
    this._checkDone();
    this._updateSelections();
    this.wires.forEach((wire) => {
      if (wire.ut_metadata) wire.ut_metadata.setMetadata(this.metadata);
      this._onWireWithMetadata(wire);
    });
  }
  destroy(opts, cb) {
    if (typeof opts === "function") return this.destroy(null, opts);
    this._destroy(null, opts, cb);
  }
  _destroy(err2, opts, cb) {
    var _a3;
    if (typeof opts === "function") return this._destroy(err2, null, opts);
    if (this.destroyed) return;
    this.destroyed = true;
    this._debug("destroy");
    this.client._remove(this);
    this._selections.clear();
    clearInterval(this._rechokeIntervalId);
    clearInterval(this._noPeersIntervalId);
    (_a3 = this._xsRequestsController) == null ? void 0 : _a3.abort();
    if (this._rarityMap) {
      this._rarityMap.destroy();
    }
    for (const id in this._peers) {
      this.removePeer(id);
    }
    this.files.forEach((file) => {
      if (file instanceof File2) file._destroy();
    });
    const tasks = this._servers.map((server) => (cb2) => {
      server.destroy(cb2);
    });
    if (this.discovery) {
      tasks.push((cb2) => {
        this.discovery.destroy(cb2);
      });
    }
    if (this.store) {
      let destroyStore = this._destroyStoreOnDestroy;
      if (opts && opts.destroyStore !== void 0) {
        destroyStore = opts.destroyStore;
      }
      tasks.push((cb2) => {
        if (destroyStore) {
          this.store.destroy(cb2);
        } else {
          this.store.close(cb2);
        }
      });
    }
    (0, import_run_parallel4.default)(tasks, cb);
    if (err2) {
      if (this.listenerCount("error") === 0) {
        this.client.emit("error", err2);
      } else {
        this.emit("error", err2);
      }
    }
    this.emit("close");
    this.client = null;
    this.files = [];
    this.discovery = null;
    this.store = null;
    this._rarityMap = null;
    this._peers = null;
    this._servers = null;
    this._xsRequests = null;
  }
  addPeer(peer, source) {
    if (this.destroyed) throw new Error("torrent is destroyed");
    if (!this.infoHash) throw new Error("addPeer() must not be called before the `infoHash` event");
    let host;
    if (typeof peer === "string") {
      let parts;
      try {
        parts = addrToIPPort(peer);
      } catch (e) {
        this._debug("ignoring peer: invalid %s", peer);
        this.emit("invalidPeer", peer);
        return false;
      }
      host = parts[0];
    } else if (typeof peer.remoteAddress === "string") {
      host = peer.remoteAddress;
    }
    if (this.client.blocked && host && this.client.blocked.contains(host)) {
      this._debug("ignoring peer: blocked %s", peer);
      if (typeof peer !== "string") peer.destroy();
      this.emit("blockedPeer", peer);
      return false;
    }
    const type = this.client.utp && this._isIPv4(host) ? "utp" : "tcp";
    const wasAdded = !!this._addPeer(peer, type, source);
    if (wasAdded) {
      this.emit("peer", peer);
    } else {
      this.emit("invalidPeer", peer);
    }
    return wasAdded;
  }
  _addPeer(peer, type, source) {
    if (this.destroyed) {
      if (typeof peer !== "string") peer.destroy();
      return null;
    }
    if (typeof peer === "string" && !this._validAddr(peer)) {
      this._debug("ignoring peer: invalid %s", peer);
      return null;
    }
    const id = peer && peer.id || peer;
    if (this._peers[id]) {
      this._debug("ignoring peer: duplicate (%s)", id);
      if (typeof peer !== "string") peer.destroy();
      return null;
    }
    if (this.paused) {
      this._debug("ignoring peer: torrent is paused");
      if (typeof peer !== "string") peer.destroy();
      return null;
    }
    this._debug("add peer %s", id);
    let newPeer;
    if (typeof peer === "string") {
      newPeer = type === "utp" ? Peer.createUTPOutgoingPeer(peer, this, this.client.throttleGroups) : Peer.createTCPOutgoingPeer(peer, this, this.client.throttleGroups);
    } else {
      newPeer = Peer.createWebRTCPeer(peer, this, this.client.throttleGroups);
    }
    this._registerPeer(newPeer);
    if (typeof peer === "string") {
      this._queue.push(newPeer);
      this._drain();
    }
    return newPeer;
  }
  addWebSeed(urlOrConn) {
    if (this.destroyed) throw new Error("torrent is destroyed");
    let id;
    let conn;
    if (typeof urlOrConn === "string") {
      id = urlOrConn;
      if (!/^https?:\/\/.+/.test(id)) {
        this.emit("warning", new Error(`ignoring invalid web seed: ${id}`));
        this.emit("invalidPeer", id);
        return;
      }
      if (this._peers[id]) {
        this.emit("warning", new Error(`ignoring duplicate web seed: ${id}`));
        this.emit("invalidPeer", id);
        return;
      }
      conn = new WebConn(id, this);
    } else if (urlOrConn && typeof urlOrConn.connId === "string") {
      conn = urlOrConn;
      id = conn.connId;
      if (this._peers[id]) {
        this.emit("warning", new Error(`ignoring duplicate web seed: ${id}`));
        this.emit("invalidPeer", id);
        return;
      }
    } else {
      this.emit("warning", new Error("addWebSeed must be passed a string or connection object with id property"));
      return;
    }
    this._debug("add web seed %s", id);
    const newPeer = Peer.createWebSeedPeer(conn, id, this, this.client.throttleGroups);
    this._registerPeer(newPeer);
    this.emit("peer", id);
  }
  /**
   * Called whenever a new incoming TCP peer connects to this torrent swarm. Called with a
   * peer that has already sent a handshake.
   */
  _addIncomingPeer(peer) {
    if (this.destroyed) return peer.destroy(new Error("torrent is destroyed"));
    if (this.paused) return peer.destroy(new Error("torrent is paused"));
    this._debug("add incoming peer %s", peer.id);
    this._registerPeer(peer);
  }
  _registerPeer(newPeer) {
    newPeer.on("download", (downloaded) => {
      if (this.destroyed) return;
      this.received += downloaded;
      this._downloadSpeed(downloaded);
      this.client._downloadSpeed(downloaded);
      this.emit("download", downloaded);
      if (this.destroyed) return;
      this.client.emit("download", downloaded);
    });
    newPeer.on("upload", (uploaded) => {
      if (this.destroyed) return;
      this.uploaded += uploaded;
      this._uploadSpeed(uploaded);
      this.client._uploadSpeed(uploaded);
      this.emit("upload", uploaded);
      if (this.destroyed) return;
      this.client.emit("upload", uploaded);
    });
    this._peers[newPeer.id] = newPeer;
    this._peersLength += 1;
  }
  removePeer(peer) {
    var _a3;
    const id = (peer == null ? void 0 : peer.id) || peer;
    if (peer && !peer.id) peer = (_a3 = this._peers) == null ? void 0 : _a3[id];
    if (!peer) return;
    peer.destroy();
    if (this.destroyed) return;
    this._debug("removePeer %s", id);
    delete this._peers[id];
    this._peersLength -= 1;
    this._drain();
  }
  _select(start, end, priority, notify, isStreamSelection = false) {
    if (this.destroyed) throw new Error("torrent is destroyed");
    if (start < 0 || end < start || this.pieces.length <= end) {
      throw new Error(`invalid selection ${start} : ${end}`);
    }
    priority = Number(priority) || 0;
    this._debug("select %s-%s (priority %s)", start, end, priority);
    this._selections.insert({
      from: start,
      to: end,
      offset: 0,
      priority,
      notify,
      isStreamSelection
    });
    this._selections.sort((a, b) => b.priority - a.priority);
    this._updateSelections();
  }
  select(start, end, priority, notify) {
    this._select(start, end, priority, notify, false);
  }
  _deselect(from, to, isStreamSelection = false) {
    if (this.destroyed) throw new Error("torrent is destroyed");
    this._debug("deselect %s-%s", from, to);
    this._selections.remove({ from, to, isStreamSelection });
    this._updateSelections();
  }
  deselect(start, end) {
    this._deselect(start, end, false);
  }
  critical(start, end) {
    if (this.destroyed) throw new Error("torrent is destroyed");
    this._debug("critical %s-%s", start, end);
    for (let i = start; i <= end; ++i) {
      this._critical[i] = true;
    }
    this._updateSelections();
  }
  _onWire(wire, addr) {
    this._debug("got wire %s (%s)", wire._debugId, addr || "Unknown");
    this.wires.push(wire);
    if (addr) {
      const parts = addrToIPPort(addr);
      wire.remoteAddress = parts[0];
      wire.remotePort = parts[1];
    }
    if (this.client.dht && this.client.dht.listening) {
      wire.on("port", (port) => {
        if (this.destroyed || this.client.dht.destroyed) {
          return;
        }
        if (!wire.remoteAddress) {
          return this._debug("ignoring PORT from peer with no address");
        }
        if (port === 0 || port > 65536) {
          return this._debug("ignoring invalid PORT from peer");
        }
        this._debug("port: %s (from %s)", port, addr);
        this.client.dht.addNode({ host: wire.remoteAddress, port });
      });
    }
    wire.on("timeout", () => {
      this._debug("wire timeout (%s)", addr);
      wire.destroy();
    });
    if (wire.type !== "webSeed") {
      wire.setTimeout(PIECE_TIMEOUT, true);
    }
    wire.setKeepAlive(true);
    wire.use(ut_metadata_default(this.metadata));
    wire.ut_metadata.on("warning", (err2) => {
      this._debug("ut_metadata warning: %s", err2.message);
    });
    if (!this.metadata) {
      wire.ut_metadata.on("metadata", (metadata) => {
        this._debug("got metadata via ut_metadata");
        this._onMetadata(metadata);
      });
      wire.ut_metadata.fetch();
    }
    if (this.client.utPex && typeof import_ut_pex.default === "function" && !this.private) {
      wire.use((0, import_ut_pex.default)());
      wire.ut_pex.on("peer", (peer) => {
        if (this.done) return;
        this._debug("ut_pex: got peer: %s (from %s)", peer, addr);
        this.addPeer(peer, Peer.SOURCE_UT_PEX);
      });
      wire.ut_pex.on("dropped", (peer) => {
        const peerObj = this._peers[peer];
        if (peerObj && !peerObj.connected) {
          this._debug("ut_pex: dropped peer: %s (from %s)", peer, addr);
          this.removePeer(peer);
        }
      });
      wire.once("close", () => {
        wire.ut_pex.reset();
      });
    }
    wire.use(lt_donthave_default());
    this.emit("wire", wire, addr);
    if (this.ready) {
      (0, import_queue_microtask5.default)(() => {
        this._onWireWithMetadata(wire);
      });
    }
  }
  _onWireWithMetadata(wire) {
    let timeoutId = null;
    const onChokeTimeout = () => {
      if (this.destroyed || wire.destroyed) return;
      if (this._numQueued > 2 * (this._numConns - this.numPeers) && wire.amInterested) {
        wire.destroy();
      } else {
        timeoutId = setTimeout(onChokeTimeout, CHOKE_TIMEOUT);
        if (timeoutId.unref) timeoutId.unref();
      }
    };
    let i;
    const updateSeedStatus = () => {
      if (wire.peerPieces.buffer.length !== this.bitfield.buffer.length) return;
      for (i = 0; i < this.pieces.length; ++i) {
        if (!wire.peerPieces.get(i)) return;
      }
      wire.isSeeder = true;
      if (this.alwaysChokeSeeders) wire.choke();
    };
    wire.on("bitfield", () => {
      updateSeedStatus();
      this._update();
      this._updateWireInterest(wire);
    });
    wire.on("have", () => {
      updateSeedStatus();
      this._update();
      this._updateWireInterest(wire);
    });
    wire.lt_donthave.on("donthave", () => {
      updateSeedStatus();
      this._update();
      this._updateWireInterest(wire);
    });
    wire.on("have-all", () => {
      wire.isSeeder = true;
      if (this.alwaysChokeSeeders) wire.choke();
      this._update();
      this._updateWireInterest(wire);
    });
    wire.on("have-none", () => {
      wire.isSeeder = false;
      this._update();
      this._updateWireInterest(wire);
    });
    wire.on("allowed-fast", (index) => {
      this._update();
    });
    wire.once("interested", () => {
      wire.unchoke();
    });
    wire.once("close", () => {
      clearTimeout(timeoutId);
    });
    wire.on("choke", () => {
      clearTimeout(timeoutId);
      timeoutId = setTimeout(onChokeTimeout, CHOKE_TIMEOUT);
      if (timeoutId.unref) timeoutId.unref();
    });
    wire.on("unchoke", () => {
      clearTimeout(timeoutId);
      this._update();
    });
    wire.on("request", (index, offset, length, cb) => {
      if (length > MAX_BLOCK_LENGTH) {
        return wire.destroy();
      }
      if (this.pieces[index]) return;
      this.store.get(index, { offset, length }, cb);
    });
    if (wire.hasFast && this._hasAllPieces()) wire.haveAll();
    else if (wire.hasFast && this._hasNoPieces()) wire.haveNone();
    else wire.bitfield(this.bitfield);
    this._updateWireInterest(wire);
    if (wire.peerExtensions.dht && this.client.dht && this.client.dht.listening) {
      wire.port(this.client.dht.address().port);
    }
    if (wire.type !== "webSeed") {
      timeoutId = setTimeout(onChokeTimeout, CHOKE_TIMEOUT);
      if (timeoutId.unref) timeoutId.unref();
    }
    wire.isSeeder = false;
    updateSeedStatus();
  }
  /**
   * Called on selection changes.
   */
  _updateSelections() {
    if (!this.ready || this.destroyed) return;
    (0, import_queue_microtask5.default)(() => {
      this._gcSelections();
    });
    this._updateInterest();
    this._update();
  }
  /**
   * Garbage collect selections with respect to the store's current state.
   */
  _gcSelections() {
    var _a3, _b3;
    for (const s of this._selections) {
      const oldOffset = s.offset;
      while (this.bitfield.get(s.from + s.offset) && s.from + s.offset < s.to) {
        s.offset += 1;
      }
      if (oldOffset !== s.offset) (_a3 = s.notify) == null ? void 0 : _a3.call(s);
      if (s.to !== s.from + s.offset) continue;
      if (!this.bitfield.get(s.from + s.offset)) continue;
      s.remove();
      (_b3 = s.notify) == null ? void 0 : _b3.call(s);
      this._updateInterest();
    }
    if (!this._selections.length) this.emit("idle");
  }
  /**
   * Update interested status for all peers.
   */
  _updateInterest() {
    const prev = this._amInterested;
    this._amInterested = !!this._selections.length;
    this.wires.forEach((wire) => this._updateWireInterest(wire));
    if (prev === this._amInterested) return;
    if (this._amInterested) this.emit("interested");
    else this.emit("uninterested");
  }
  _updateWireInterest(wire) {
    let interested = false;
    for (let index = 0; index < this.pieces.length; ++index) {
      if (this.pieces[index] && wire.peerPieces.get(index)) {
        interested = true;
        break;
      }
    }
    if (interested) wire.interested();
    else wire.uninterested();
  }
  /**
   * Heartbeat to update all peers and their requests.
   */
  _update() {
    if (IDLE_CALLBACK) {
      IDLE_CALLBACK(() => this._updateWireWrapper(), { timeout: 250 });
    } else {
      this._updateWireWrapper();
    }
  }
  _updateWireWrapper() {
    if (this.destroyed) return;
    const ite = (0, import_random_iterate.default)(this.wires);
    let wire;
    while (wire = ite()) {
      this._updateWire(wire);
    }
  }
  /**
   * Attempts to update a peer's requests
   */
  _updateWire(wire) {
    if (wire.destroyed) return false;
    const self2 = this;
    const minOutstandingRequests = getBlockPipelineLength(wire, PIPELINE_MIN_DURATION);
    if (wire.requests.length >= minOutstandingRequests) return;
    const maxOutstandingRequests = getBlockPipelineLength(wire, PIPELINE_MAX_DURATION);
    if (wire.peerChoking) {
      if (wire.hasFast && wire.peerAllowedFastSet.length > 0 && !this._hasMorePieces(wire.peerAllowedFastSet.length - 1)) {
        requestAllowedFastSet();
      }
      return;
    }
    if (!wire.downloaded) return validateWire();
    trySelectWire(false) || trySelectWire(true);
    function requestAllowedFastSet() {
      if (wire.requests.length >= maxOutstandingRequests) return false;
      for (const piece of wire.peerAllowedFastSet) {
        if (wire.peerPieces.get(piece) && !self2.bitfield.get(piece)) {
          while (self2._request(wire, piece, false) && wire.requests.length < maxOutstandingRequests) {
          }
        }
        if (wire.requests.length < maxOutstandingRequests) continue;
        return true;
      }
      return false;
    }
    function genPieceFilterFunc(start, end, tried, rank) {
      return (i) => i >= start && i <= end && !(i in tried) && wire.peerPieces.get(i) && (!rank || rank(i));
    }
    function validateWire() {
      if (wire.requests.length) return;
      let i = self2._selections.length;
      while (i--) {
        const next = self2._selections.get(i);
        let piece;
        if (self2.strategy === "rarest") {
          const start = next.from + next.offset;
          const end = next.to;
          const len = end - start + 1;
          const tried = {};
          let tries = 0;
          const filter = genPieceFilterFunc(start, end, tried);
          while (tries < len) {
            piece = self2._rarityMap.getRarestPiece(filter);
            if (piece < 0) break;
            if (self2._request(wire, piece, false)) return;
            tried[piece] = true;
            tries += 1;
          }
        } else {
          for (piece = next.to; piece >= next.from + next.offset; --piece) {
            if (!wire.peerPieces.get(piece)) continue;
            if (self2._request(wire, piece, false)) return;
          }
        }
      }
    }
    function speedRanker() {
      const speed = wire.downloadSpeed() || 1;
      if (speed > SPEED_THRESHOLD) return () => true;
      const secs = Math.max(1, wire.requests.length) * Piece.BLOCK_LENGTH / speed;
      let tries = 10;
      let ptr = 0;
      return (index) => {
        if (!tries || self2.bitfield.get(index)) return true;
        let missing = self2.pieces[index].missing;
        for (; ptr < self2.wires.length; ptr++) {
          const otherWire = self2.wires[ptr];
          const otherSpeed = otherWire.downloadSpeed();
          if (otherSpeed < SPEED_THRESHOLD) continue;
          if (otherSpeed <= speed) continue;
          if (!otherWire.peerPieces.get(index)) continue;
          if ((missing -= otherSpeed * secs) > 0) continue;
          tries--;
          return false;
        }
        return true;
      };
    }
    function shufflePriority(i) {
      let last = i;
      for (let j = i; j < self2._selections.length && self2._selections.get(j).priority; j++) {
        last = j;
      }
      self2._selections.swap(i, last);
    }
    function trySelectWire(hotswap) {
      if (wire.requests.length >= maxOutstandingRequests) return true;
      const rank = speedRanker();
      for (let i = 0; i < self2._selections.length; i++) {
        const next = self2._selections.get(i);
        let piece;
        if (self2.strategy === "rarest") {
          const start = next.from + next.offset;
          const end = next.to;
          const len = end - start + 1;
          const tried = {};
          let tries = 0;
          const filter = genPieceFilterFunc(start, end, tried, rank);
          while (tries < len) {
            piece = self2._rarityMap.getRarestPiece(filter);
            if (piece < 0) break;
            while (self2._request(wire, piece, self2._critical[piece] || hotswap) && wire.requests.length < maxOutstandingRequests) {
            }
            if (wire.requests.length < maxOutstandingRequests) {
              tried[piece] = true;
              tries++;
              continue;
            }
            if (next.priority) shufflePriority(i);
            return true;
          }
        } else {
          for (piece = next.from + next.offset; piece <= next.to; piece++) {
            if (!wire.peerPieces.get(piece) || !rank(piece)) continue;
            while (self2._request(wire, piece, self2._critical[piece] || hotswap) && wire.requests.length < maxOutstandingRequests) {
            }
            if (wire.requests.length < maxOutstandingRequests) continue;
            if (next.priority) shufflePriority(i);
            return true;
          }
        }
      }
      return false;
    }
  }
  /**
   * Called periodically to update the choked status of all peers, handling optimistic
   * unchoking as described in BEP3.
   */
  _rechoke() {
    if (!this.ready) return;
    const wireStack = this.wires.map((wire) => ({ wire, random: Math.random() })).sort((objA, objB) => {
      const wireA = objA.wire;
      const wireB = objB.wire;
      if (wireA.downloadSpeed() !== wireB.downloadSpeed()) {
        return wireA.downloadSpeed() - wireB.downloadSpeed();
      }
      if (wireA.uploadSpeed() !== wireB.uploadSpeed()) {
        return wireA.uploadSpeed() - wireB.uploadSpeed();
      }
      if (wireA.amChoking !== wireB.amChoking) {
        return wireA.amChoking ? -1 : 1;
      }
      return objA.random - objB.random;
    }).map((obj) => obj.wire);
    if (this._rechokeOptimisticTime <= 0) {
      this._rechokeOptimisticWire = null;
    } else {
      this._rechokeOptimisticTime -= 1;
    }
    let numInterestedUnchoked = 0;
    while (wireStack.length > 0 && numInterestedUnchoked < this._rechokeNumSlots - 1) {
      const wire = wireStack.pop();
      if (wire.isSeeder || wire === this._rechokeOptimisticWire) {
        continue;
      }
      wire.unchoke();
      if (wire.peerInterested) {
        numInterestedUnchoked++;
      }
    }
    if (this._rechokeOptimisticWire === null && this._rechokeNumSlots > 0) {
      const remaining = wireStack.filter((wire) => wire.peerInterested);
      if (remaining.length > 0) {
        const newOptimisticPeer = remaining[randomInt(remaining.length)];
        newOptimisticPeer.unchoke();
        this._rechokeOptimisticWire = newOptimisticPeer;
        this._rechokeOptimisticTime = RECHOKE_OPTIMISTIC_DURATION;
      }
    }
    wireStack.filter((wire) => wire !== this._rechokeOptimisticWire).forEach((wire) => wire.choke());
  }
  /**
   * Attempts to cancel a slow block request from another wire such that the
   * given wire may effectively swap out the request for one of its own.
   */
  _hotswap(wire, index) {
    const speed = wire.downloadSpeed();
    if (speed < Piece.BLOCK_LENGTH) return false;
    if (!this._reservations[index]) return false;
    const r = this._reservations[index];
    if (!r) {
      return false;
    }
    let minSpeed = Infinity;
    let minWire;
    let i;
    for (i = 0; i < r.length; i++) {
      const otherWire = r[i];
      if (!otherWire || otherWire === wire) continue;
      const otherSpeed = otherWire.downloadSpeed();
      if (otherSpeed >= SPEED_THRESHOLD) continue;
      if (2 * otherSpeed > speed || otherSpeed > minSpeed) continue;
      minWire = otherWire;
      minSpeed = otherSpeed;
    }
    if (!minWire) return false;
    for (i = 0; i < r.length; i++) {
      if (r[i] === minWire) r[i] = null;
    }
    for (i = 0; i < minWire.requests.length; i++) {
      const req = minWire.requests[i];
      if (req.piece !== index) continue;
      this.pieces[index].cancel(req.offset / Piece.BLOCK_LENGTH | 0);
    }
    this.emit("hotswap", minWire, wire, index);
    return true;
  }
  /**
   * Attempts to request a block from the given wire.
   */
  _request(wire, index, hotswap) {
    const self2 = this;
    const numRequests = wire.requests.length;
    const isWebSeed = wire.type === "webSeed";
    if (self2.bitfield.get(index)) return false;
    const maxOutstandingRequests = isWebSeed ? Math.min(
      getPiecePipelineLength(wire, PIPELINE_MAX_DURATION, self2.pieceLength),
      self2.maxWebConns
    ) : getBlockPipelineLength(wire, PIPELINE_MAX_DURATION);
    if (numRequests >= maxOutstandingRequests) return false;
    const piece = self2.pieces[index];
    let reservation = isWebSeed ? piece.reserveRemaining() : piece.reserve();
    if (reservation === -1 && hotswap && self2._hotswap(wire, index)) {
      reservation = isWebSeed ? piece.reserveRemaining() : piece.reserve();
    }
    if (reservation === -1) return false;
    let r = self2._reservations[index];
    if (!r) r = self2._reservations[index] = [];
    let i = r.indexOf(null);
    if (i === -1) i = r.length;
    r[i] = wire;
    const chunkOffset = piece.chunkOffset(reservation);
    const chunkLength = isWebSeed ? piece.chunkLengthRemaining(reservation) : piece.chunkLength(reservation);
    wire.request(index, chunkOffset, chunkLength, async function onChunk(err2, chunk) {
      if (self2.destroyed) return;
      if (!self2.ready) return self2.once("ready", () => {
        onChunk(err2, chunk);
      });
      if (r[i] === wire) r[i] = null;
      if (piece !== self2.pieces[index]) return onUpdateTick();
      if (err2) {
        self2._debug(
          "error getting piece %s (offset: %s length: %s) from %s: %s",
          index,
          chunkOffset,
          chunkLength,
          `${wire.remoteAddress}:${wire.remotePort}`,
          err2.message
        );
        isWebSeed ? piece.cancelRemaining(reservation) : piece.cancel(reservation);
        onUpdateTick();
        return;
      }
      self2._debug(
        "got piece %s (offset: %s length: %s) from %s",
        index,
        chunkOffset,
        chunkLength,
        `${wire.remoteAddress}:${wire.remotePort}`
      );
      if (!piece.set(reservation, chunk, wire)) return onUpdateTick();
      const buf = piece.flush();
      const hex = await hash(buf, "hex");
      if (self2.destroyed) return;
      if (hex === self2._hashes[index]) {
        self2._debug("piece verified %s", index);
        self2.store.put(index, buf, (err3) => {
          if (err3) {
            self2._destroy(err3);
            return;
          } else {
            self2.pieces[index] = null;
            self2._markVerified(index);
            self2.wires.forEach((wire2) => {
              wire2.have(index);
            });
          }
          if (self2._checkDone() && !self2.destroyed) self2.discovery.complete();
          onUpdateTick();
        });
      } else {
        self2.pieces[index] = new Piece(piece.length);
        self2.emit("warning", new Error(`Piece ${index} failed verification`));
        onUpdateTick();
      }
    });
    function onUpdateTick() {
      (0, import_queue_microtask5.default)(() => {
        self2._update();
      });
    }
    return true;
  }
  _checkDone() {
    if (this.destroyed) return;
    this.files.forEach((file) => {
      if (file.done) return;
      for (let i = file._startPiece; i <= file._endPiece; ++i) {
        if (!this.bitfield.get(i)) return;
      }
      file.done = true;
      file.emit("done");
      this._debug(`file done: ${file.name}`);
    });
    let done = true;
    for (const selection of this._selections) {
      for (let piece = selection.from; piece <= selection.to; piece++) {
        if (!this.bitfield.get(piece)) {
          done = false;
          break;
        }
      }
      if (!done) break;
    }
    if (!this.done && done) {
      this.done = true;
      this._debug(`torrent done: ${this.infoHash}`);
      this.emit("done");
    } else {
      this.done = false;
    }
    this._gcSelections();
    return done;
  }
  async load(streams, cb) {
    if (this.destroyed) throw new Error("torrent is destroyed");
    if (!this.ready) return this.once("ready", () => {
      this.load(streams, cb);
    });
    if (!Array.isArray(streams)) streams = [streams];
    if (!cb) cb = noop4;
    try {
      await chunkStoreWrite(this.store, (0, import_join_async_iterator2.default)(streams), { chunkLength: this.pieceLength });
      this._markAllVerified();
      this._checkDone();
      cb(null);
    } catch (err2) {
      cb(err2);
      return err2;
    }
  }
  pause() {
    if (this.destroyed) return;
    this._debug("pause");
    this.paused = true;
  }
  resume() {
    if (this.destroyed) return;
    this._debug("resume");
    this.paused = false;
    this._drain();
  }
  _debug() {
    const args = [].slice.call(arguments);
    args[0] = `[${this.client ? this.client._debugId : "No Client"}] [${this._debugId}] ${args[0]}`;
    debug11(...args);
  }
  /**
   * Pop a peer off the FIFO queue and connect to it. When _drain() gets called,
   * the queue will usually have only one peer in it, except when there are too
   * many peers (over `this.maxConns`) in which case they will just sit in the
   * queue until another connection closes.
   */
  _drain() {
    this._debug("_drain numConns %s maxConns %s", this._numConns, this.client.maxConns);
    if (typeof import_net.default.connect !== "function" || this.destroyed || this.paused || this._numConns >= this.client.maxConns) {
      return;
    }
    this._debug("drain (%s queued, %s/%s peers)", this._numQueued, this.numPeers, this.client.maxConns);
    const peer = this._queue.shift();
    if (!peer) return;
    this._debug("%s connect attempt to %s", peer.type, peer.addr);
    const parts = addrToIPPort(peer.addr);
    const opts = {
      host: parts[0],
      port: parts[1]
    };
    if (this.client.utp && peer.type === Peer.TYPE_UTP_OUTGOING) {
      peer.conn = import_utp.default.connect(opts.port, opts.host);
    } else {
      peer.conn = import_net.default.connect(opts);
    }
    const conn = peer.conn;
    conn.once("connect", () => {
      if (!this.destroyed) peer.onConnect();
    });
    conn.once("error", (err2) => {
      peer.destroy(err2);
    });
    peer.startConnectTimeout();
    conn.on("close", () => {
      if (this.destroyed) return;
      if (peer.retries >= RECONNECT_WAIT.length) {
        if (this.client.utp) {
          const newPeer = this._addPeer(peer.addr, "tcp", peer.source);
          if (newPeer) newPeer.retries = 0;
        } else {
          this._debug(
            "conn %s closed: will not re-add (max %s attempts)",
            peer.addr,
            RECONNECT_WAIT.length
          );
        }
        return;
      }
      const ms = RECONNECT_WAIT[peer.retries];
      this._debug(
        "conn %s closed: will re-add to queue in %sms (attempt %s)",
        peer.addr,
        ms,
        peer.retries + 1
      );
      const reconnectTimeout = setTimeout(() => {
        if (this.destroyed) return;
        const host = addrToIPPort(peer.addr)[0];
        const type = this.client.utp && this._isIPv4(host) ? "utp" : "tcp";
        const newPeer = this._addPeer(peer.addr, type, peer.source);
        if (newPeer) newPeer.retries = peer.retries + 1;
      }, ms);
      if (reconnectTimeout.unref) reconnectTimeout.unref();
    });
  }
  /**
   * Returns `true` if string is valid IPv4/6 address.
   * @param {string} addr
   * @return {boolean}
   */
  _validAddr(addr) {
    let parts;
    try {
      parts = addrToIPPort(addr);
    } catch (e) {
      return false;
    }
    const host = parts[0];
    const port = parts[1];
    return port > 0 && port < 65535 && !(host === "127.0.0.1" && port === this.client.torrentPort);
  }
  /**
   * Return `true` if string is a valid IPv4 address.
   * @param {string} addr
   * @return {boolean}
   */
  _isIPv4(addr) {
    const IPv4Pattern = /^((?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])[.]){3}(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$/;
    return IPv4Pattern.test(addr);
  }
};
function getBlockPipelineLength(wire, duration) {
  let length = 2 + Math.ceil(duration * wire.downloadSpeed() / Piece.BLOCK_LENGTH);
  if (wire.peerExtendedHandshake) {
    const reqq = wire.peerExtendedHandshake.reqq;
    if (typeof reqq === "number" && reqq > 0) {
      length = Math.min(length, reqq);
    }
  }
  return length;
}
function getPiecePipelineLength(wire, duration, pieceLength) {
  return 1 + Math.ceil(duration * wire.downloadSpeed() / pieceLength);
}
function randomInt(high) {
  return Math.random() * high | 0;
}
function noop4() {
}

// node_modules/webtorrent/lib/server.js
var import_http = __toESM(require_http(), 1);
var import_escape_html = __toESM(require_escape_html(), 1);
var import_pump = __toESM(require_pump(), 1);
var import_range_parser = __toESM(require_range_parser(), 1);
var import_queue_microtask6 = __toESM(require_queue_microtask(), 1);
var import_streamx4 = __toESM(require_streamx(), 1);
var keepAliveTime = 2e4;
var ServerBase = class _ServerBase {
  constructor(client, opts = {}) {
    this.client = client;
    if (!opts.origin) opts.origin = "*";
    this.opts = opts;
    this.pendingReady = /* @__PURE__ */ new Set();
  }
  static serveIndexPage(res, torrents, pathname) {
    const listHtml = torrents.map((torrent) => `<li>
        <a href="${(0, import_escape_html.default)(pathname)}/${torrent.infoHash}">
          ${(0, import_escape_html.default)(torrent.name)}
        </a>
        (${(0, import_escape_html.default)(torrent.length)} bytes)
      </li>`).join("<br>");
    res.status = 200;
    res.headers["Content-Type"] = "text/html";
    res.body = getPageHTML(
      "WebTorrent",
      `<h1>WebTorrent</h1>
       <ol>${listHtml}</ol>`
    );
    return res;
  }
  isOriginAllowed(req) {
    if (this.opts.origin === false) return false;
    if (this.opts.origin === "*") return true;
    return req.headers.origin === this.opts.origin;
  }
  static serveMethodNotAllowed(res) {
    res.status = 405;
    res.headers["Content-Type"] = "text/html";
    res.body = getPageHTML(
      "405 - Method Not Allowed",
      "<h1>405 - Method Not Allowed</h1>"
    );
    return res;
  }
  static serve404Page(res) {
    res.status = 404;
    res.headers["Content-Type"] = "text/html";
    res.body = getPageHTML(
      "404 - Not Found",
      "<h1>404 - Not Found</h1>"
    );
    return res;
  }
  static serveTorrentPage(torrent, res, pathname) {
    const listHtml = torrent.files.map((file) => `<li>
        <a href="${(0, import_escape_html.default)(pathname)}/${torrent.infoHash}/${(0, import_escape_html.default)(file.path)}">
          ${(0, import_escape_html.default)(file.path)}
        </a>
        (${(0, import_escape_html.default)(file.length)} bytes)
      </li>`).join("<br>");
    res.status = 200;
    res.headers["Content-Type"] = "text/html";
    res.body = getPageHTML(
      `${(0, import_escape_html.default)(torrent.name)} - WebTorrent`,
      `<h1>${(0, import_escape_html.default)(torrent.name)}</h1>
      <ol>${listHtml}</ol>`
    );
    return res;
  }
  static serveOptionsRequest(req, res) {
    res.status = 204;
    res.headers["Access-Control-Max-Age"] = "600";
    res.headers["Access-Control-Allow-Methods"] = "GET,HEAD";
    if (req.headers["access-control-request-headers"]) {
      res.headers["Access-Control-Allow-Headers"] = req.headers["access-control-request-headers"];
    }
    return res;
  }
  static serveFile(file, req, res) {
    res.status = 200;
    res.headers.Expires = "0";
    res.headers["Cache-Control"] = "no-cache, no-store, must-revalidate, max-age=0";
    res.headers["Accept-Ranges"] = "bytes";
    res.headers["Content-Type"] = file.type;
    res.headers["transferMode.dlna.org"] = "Streaming";
    res.headers["contentFeatures.dlna.org"] = "DLNA.ORG_OP=01;DLNA.ORG_CI=0;DLNA.ORG_FLAGS=01700000000000000000000000000000";
    if (req.destination === "document") {
      res.headers["Content-Type"] = "application/octet-stream";
      res.headers["Content-Disposition"] = `attachment; filename*=UTF-8''${encodeRFC5987(file.name)}`;
      res.body = "DOWNLOAD";
    } else {
      res.headers["Content-Disposition"] = `inline; filename*=UTF-8''${encodeRFC5987(file.name)}`;
    }
    let range = (0, import_range_parser.default)(file.length, req.headers.range || "");
    if (Array.isArray(range)) {
      res.status = 206;
      range = range[0];
      res.headers["Content-Range"] = `bytes ${range.start}-${range.end}/${file.length}`;
      res.headers["Content-Length"] = range.end - range.start + 1;
    } else {
      res.statusCode = 200;
      range = null;
      res.headers["Content-Length"] = file.length;
    }
    if (req.method === "GET") {
      const iterator = file[Symbol.asyncIterator](range);
      let transform = null;
      file.emit("iterator", { iterator, req, file }, (target) => {
        transform = target;
      });
      const stream = import_streamx4.Readable.from(transform || iterator);
      let pipe = null;
      file.emit("stream", { stream, req, file }, (target) => {
        pipe = (0, import_pump.default)(stream, target);
      });
      res.body = pipe || stream;
    } else {
      res.body = false;
    }
    return res;
  }
  async onRequest(req, cb) {
    let pathname = new URL(req.url, "http://example.com").pathname;
    pathname = pathname.slice(pathname.indexOf(this.pathname) + this.pathname.length + 1);
    const res = {
      headers: {
        // Prevent browser mime-type sniffing
        "X-Content-Type-Options": "nosniff",
        // Defense-in-depth: Set a strict Content Security Policy to mitigate XSS
        "Content-Security-Policy": "base-uri 'none'; frame-ancestors 'none'; form-action 'none';"
      }
    };
    if (this.isOriginAllowed(req)) {
      res.headers["Access-Control-Allow-Origin"] = this.opts.origin === "*" ? "*" : req.headers.origin;
    }
    if (pathname === "favicon.ico") {
      return cb(_ServerBase.serve404Page(res));
    }
    if (req.method === "OPTIONS") {
      if (this.isOriginAllowed(req)) return cb(_ServerBase.serveOptionsRequest(req, res));
      else return cb(_ServerBase.serveMethodNotAllowed(res));
    }
    const onReady = async () => {
      this.pendingReady.delete(onReady);
      const res2 = await handleRequest();
      cb(res2);
    };
    const handleRequest = async () => {
      if (pathname === "") {
        return _ServerBase.serveIndexPage(res, this.client.torrents, this.pathname);
      }
      let [infoHash, ...filePath] = pathname.split("/");
      filePath = decodeURI(filePath.join("/"));
      const torrent = await this.client.get(infoHash);
      if (!infoHash || !torrent) {
        return _ServerBase.serve404Page(res);
      }
      if (!filePath) {
        return _ServerBase.serveTorrentPage(torrent, res, this.pathname);
      }
      const file = torrent.files.find((file2) => file2.path.replace(/\\/g, "/") === filePath);
      if (!file) {
        return _ServerBase.serve404Page(res);
      }
      return _ServerBase.serveFile(file, req, res);
    };
    if (req.method === "GET" || req.method === "HEAD") {
      if (this.client.ready) {
        const res2 = await handleRequest();
        return cb(res2);
      } else {
        this.pendingReady.add(onReady);
        this.client.once("ready", onReady);
        return;
      }
    }
    return cb(_ServerBase.serveMethodNotAllowed(res));
  }
  close(cb = () => {
  }) {
    this.closed = true;
    this.pendingReady.forEach((onReady) => {
      this.client.removeListener("ready", onReady);
    });
    this.pendingReady.clear();
    (0, import_queue_microtask6.default)(cb);
  }
  destroy(cb = () => {
  }) {
    if (this.closed) (0, import_queue_microtask6.default)(cb);
    else this.close(cb);
    this.client = null;
  }
};
var NodeServer = class extends ServerBase {
  constructor(client, opts) {
    super(client, opts);
    this.server = import_http.default.createServer();
    this._listen = this.server.listen;
    this.server.listen = this.listen.bind(this);
    this._close = this.server.close;
    this.server.close = this.close.bind(this);
    this.sockets = /* @__PURE__ */ new Set();
    this.closed = false;
    this.pathname = (opts == null ? void 0 : opts.pathname) || "/webtorrent";
  }
  wrapRequest(req, res) {
    if (this.opts.hostname && req.headers.host !== `${this.opts.hostname}:${this.server.address().port}`) {
      return req.destroy();
    }
    if (!new URL(req.url, "http://example.com").pathname.startsWith(this.pathname)) {
      return req.destroy();
    }
    this.onRequest(req, ({ status, headers, body }) => {
      res.writeHead(status, headers);
      if (!!body._readableState || !!body._writableState) {
        (0, import_pump.default)(body, res);
      } else {
        res.end(body);
      }
    });
  }
  onConnection(socket) {
    socket.setTimeout(36e6);
    this.sockets.add(socket);
    socket.once("close", () => {
      this.sockets.delete(socket);
    });
  }
  address() {
    return this.server.address();
  }
  listen(...args) {
    this.closed = false;
    this.server.on("connection", this.onConnection.bind(this));
    this.server.on("request", this.wrapRequest.bind(this));
    return this._listen.apply(this.server, args);
  }
  close(cb = () => {
  }) {
    this.server.removeAllListeners("connection");
    this.server.removeAllListeners("request");
    this.server.removeAllListeners("listening");
    super.close();
    this._close.call(this.server, cb);
  }
  destroy(cb) {
    this.sockets.forEach((socket) => {
      socket.destroy();
    });
    super.destroy(cb);
  }
};
var BrowserServer = class extends ServerBase {
  constructor(client, opts) {
    super(client, opts);
    this.registration = opts.controller;
    this.workerKeepAliveInterval = null;
    this.workerPortCount = 0;
    const scope2 = new URL(opts.controller.scope);
    this.pathname = scope2.pathname + "webtorrent";
    this._address = {
      port: scope2.port,
      family: "IPv4",
      // might be a bad idea?
      address: scope2.hostname
    };
    this.boundHandler = this.wrapRequest.bind(this);
    navigator.serviceWorker.addEventListener("message", this.boundHandler);
    fetch(`${this.pathname}/cancel/`).then((res) => {
      res.body.cancel();
    });
  }
  wrapRequest(event) {
    const req = event.data;
    if (!(req == null ? void 0 : req.type) === "webtorrent" || !req.url) return null;
    const [port] = event.ports;
    this.onRequest(req, ({ status, headers, body }) => {
      var _a3;
      const asyncIterator = (_a3 = body[Symbol.asyncIterator]) == null ? void 0 : _a3.call(body);
      const cleanup = () => {
        port.onmessage = null;
        if (body == null ? void 0 : body.destroy) body.destroy();
        this.workerPortCount--;
        if (!this.workerPortCount) {
          clearInterval(this.workerKeepAliveInterval);
          this.workerKeepAliveInterval = null;
        }
      };
      port.onmessage = async (msg) => {
        if (msg.data) {
          let chunk;
          try {
            chunk = (await asyncIterator.next()).value;
          } catch (e) {
          }
          port.postMessage(chunk);
          if (!chunk) cleanup();
          if (!this.workerKeepAliveInterval) {
            this.workerKeepAliveInterval = setInterval(() => fetch(`${this.pathname}/keepalive/`), keepAliveTime);
          }
        } else {
          cleanup();
        }
      };
      this.workerPortCount++;
      port.postMessage({
        status,
        headers,
        body: asyncIterator ? "STREAM" : body
      });
    });
  }
  // for compatibility with node version
  listen(_, cb) {
    cb();
  }
  address() {
    return this._address;
  }
  close(cb) {
    navigator.serviceWorker.removeEventListener("message", this.boundHandler);
    super.close(cb);
  }
  destroy(cb) {
    super.destroy(cb);
  }
};
function getPageHTML(title, pageHtml) {
  return `
    <!DOCTYPE html>
    <html lang="en">
      <head>
        <meta charset="utf-8">
        <title>${title}</title>
      </head>
      <body>
        ${pageHtml}
      </body>
    </html>
  `;
}
function encodeRFC5987(str) {
  return encodeURIComponent(str).replace(/['()]/g, escape).replace(/\*/g, "%2A").replace(/%(?:7C|60|5E)/g, unescape);
}

// node_modules/webtorrent/index.js
var import_version3 = __toESM(require_version());
var debug12 = (0, import_debug12.default)("webtorrent");
var VERSION_STR = import_version3.default.replace(/\d*./g, (v) => `0${v % 100}`.slice(-2)).slice(0, 4);
var VERSION_PREFIX = `-WW${VERSION_STR}-`;
var WebTorrent = class _WebTorrent extends import_events10.default {
  constructor(opts = {}) {
    super();
    if (typeof opts.peerId === "string") {
      this.peerId = opts.peerId;
    } else if (ArrayBuffer.isView(opts.peerId)) {
      this.peerId = arr2hex(opts.peerId);
    } else {
      this.peerId = arr2hex(text2arr(VERSION_PREFIX + arr2base(randomBytes(9))));
    }
    this.peerIdBuffer = hex2arr(this.peerId);
    if (typeof opts.nodeId === "string") {
      this.nodeId = opts.nodeId;
    } else if (ArrayBuffer.isView(opts.nodeId)) {
      this.nodeId = arr2hex(opts.nodeId);
    } else {
      this.nodeId = arr2hex(randomBytes(20));
    }
    this.nodeIdBuffer = hex2arr(this.nodeId);
    this._debugId = this.peerId.substring(0, 7);
    this.destroyed = false;
    this.listening = false;
    this.torrentPort = opts.torrentPort || 0;
    this.dhtPort = opts.dhtPort || 0;
    this.tracker = opts.tracker !== void 0 ? opts.tracker : {};
    this.lsd = opts.lsd !== false;
    this.utPex = opts.utPex !== false;
    this.natUpnp = opts.natUpnp ?? true;
    this.natPmp = opts.natPmp ?? true;
    this.torrents = [];
    this.maxConns = Number(opts.maxConns) || 55;
    this.utp = _WebTorrent.UTP_SUPPORT && opts.utp !== false;
    this.seedOutgoingConnections = opts.seedOutgoingConnections ?? true;
    this._downloadLimit = Math.max(typeof opts.downloadLimit === "number" ? opts.downloadLimit : -1, -1);
    this._uploadLimit = Math.max(typeof opts.uploadLimit === "number" ? opts.uploadLimit : -1, -1);
    if ((this.natUpnp || this.natPmp) && typeof import_nat_api.default === "function") {
      this.natTraversal = new import_nat_api.default({
        enableUPNP: this.natUpnp,
        enablePMP: this.natPmp,
        upnpPermanentFallback: opts.natUpnp === "permanent"
      });
    }
    if (opts.secure === true) {
      import("./peer-RUN2Y7KR.js").then(({ enableSecure }) => enableSecure());
    }
    this._debug(
      "new webtorrent (peerId %s, nodeId %s, port %s)",
      this.peerId,
      this.nodeId,
      this.torrentPort
    );
    this.throttleGroups = {
      down: new import_speed_limiter.ThrottleGroup({ rate: Math.max(this._downloadLimit, 0), enabled: this._downloadLimit >= 0 }),
      up: new import_speed_limiter.ThrottleGroup({ rate: Math.max(this._uploadLimit, 0), enabled: this._uploadLimit >= 0 })
    };
    if (this.tracker) {
      if (typeof this.tracker !== "object") this.tracker = {};
      if (globalThis.WRTC && !this.tracker.wrtc) this.tracker.wrtc = globalThis.WRTC;
    }
    if (typeof import_conn_pool.default === "function") {
      this._connPool = new import_conn_pool.default(this);
    } else {
      (0, import_queue_microtask7.default)(() => {
        this._onListening();
      });
    }
    this._downloadSpeed = (0, import_throughput2.default)();
    this._uploadSpeed = (0, import_throughput2.default)();
    if (opts.dht !== false && typeof import_bittorrent_dht2.Client === "function") {
      this.dht = new import_bittorrent_dht2.Client(Object.assign({}, { nodeId: this.nodeId }, opts.dht));
      this.dht.once("error", (err2) => {
        this._destroy(err2);
      });
      this.dht.once("listening", () => {
        const address = this.dht.address();
        if (address) {
          this.dhtPort = address.port;
          if (this.natTraversal) {
            this.natTraversal.map({
              publicPort: this.dhtPort,
              privatePort: this.dhtPort,
              protocol: "udp",
              description: "WebTorrent DHT"
            }).catch((err2) => {
              debug12("error mapping DHT port via UPnP/PMP: %o", err2);
            });
          }
        }
      });
      this.dht.setMaxListeners(0);
      this.dht.listen(this.dhtPort);
    } else {
      this.dht = false;
    }
    this.enableWebSeeds = opts.webSeeds !== false;
    const ready = () => {
      if (this.destroyed) return;
      this.ready = true;
      this.emit("ready");
    };
    if (typeof import_load_ip_set.default === "function" && opts.blocklist != null) {
      (0, import_load_ip_set.default)(opts.blocklist, {
        headers: {
          "user-agent": `WebTorrent/${import_version3.default} (https://webtorrent.io)`
        }
      }, (err2, ipSet) => {
        if (err2) return console.error(`Failed to load blocklist: ${err2.message}`);
        this.blocked = ipSet;
        ready();
      });
    } else {
      (0, import_queue_microtask7.default)(ready);
    }
  }
  /**
   * Creates an http server to serve the contents of this torrent,
   * dynamically fetching the needed torrent pieces to satisfy http requests.
   * Range requests are supported.
   *
   * @param {Object} options
   * @param {String} force
   * @return {BrowserServer||NodeServer}
   */
  createServer(options, force) {
    if (this.destroyed) throw new Error("torrent is destroyed");
    if (this._server) throw new Error("server already created");
    if ((typeof window === "undefined" || force === "node") && force !== "browser") {
      this._server = new NodeServer(this, options);
      return this._server;
    } else {
      if (!((options == null ? void 0 : options.controller) instanceof ServiceWorkerRegistration)) throw new Error("Invalid worker registration");
      if (options.controller.active.state !== "activated") throw new Error("Worker isn't activated");
      this._server = new BrowserServer(this, options);
      return this._server;
    }
  }
  get downloadSpeed() {
    return this._downloadSpeed();
  }
  get uploadSpeed() {
    return this._uploadSpeed();
  }
  get progress() {
    const torrents = this.torrents.filter((torrent) => torrent.progress !== 1);
    const downloaded = torrents.reduce((total, torrent) => total + torrent.downloaded, 0);
    const length = torrents.reduce((total, torrent) => total + (torrent.length || 0), 0) || 1;
    return downloaded / length;
  }
  get ratio() {
    const uploaded = this.torrents.reduce((total, torrent) => total + torrent.uploaded, 0);
    const received = this.torrents.reduce((total, torrent) => total + torrent.received, 0) || 1;
    return uploaded / received;
  }
  /**
   * Returns the torrent with the given `torrentId`. Convenience method. Easier than
   * searching through the `client.torrents` array. Returns `null` if no matching torrent
   * found.
   *
   * @param  {string|Buffer|Object|Torrent} torrentId
   * @return {Promise<Torrent|null>}
   */
  async get(torrentId) {
    if (torrentId instanceof Torrent) {
      if (this.torrents.includes(torrentId)) return torrentId;
    } else {
      const torrents = this.torrents;
      let parsed;
      try {
        parsed = await parse_torrent_default(torrentId);
      } catch (err2) {
      }
      if (!parsed) return null;
      if (!parsed.infoHash) throw new Error("Invalid torrent identifier");
      for (const torrent of torrents) {
        if (torrent.infoHash === parsed.infoHash) return torrent;
      }
    }
    return null;
  }
  /**
   * Start downloading a new torrent. Aliased as `client.download`.
   * @param {string|Buffer|Object} torrentId
   * @param {Object} opts torrent-specific options
   * @param {function=} ontorrent called when the torrent is ready (has metadata)
   */
  add(torrentId, opts = {}, ontorrent = () => {
  }) {
    if (this.destroyed) throw new Error("client is destroyed");
    if (typeof opts === "function") [opts, ontorrent] = [{}, opts];
    const onInfoHash = () => {
      if (this.destroyed) return;
      for (const t of this.torrents) {
        if (t.infoHash === torrent.infoHash && t !== torrent) {
          torrent._destroy(new Error(`Cannot add duplicate torrent ${torrent.infoHash}`));
          ontorrent(t);
          return;
        }
      }
    };
    const onReady = () => {
      if (this.destroyed) return;
      ontorrent(torrent);
      this.emit("torrent", torrent);
    };
    function onClose() {
      torrent.removeListener("_infoHash", onInfoHash);
      torrent.removeListener("ready", onReady);
      torrent.removeListener("close", onClose);
    }
    this._debug("add");
    opts = opts ? Object.assign({}, opts) : {};
    const torrent = new Torrent(torrentId, this, opts);
    this.torrents.push(torrent);
    torrent.once("_infoHash", onInfoHash);
    torrent.once("ready", onReady);
    torrent.once("close", onClose);
    this.emit("add", torrent);
    return torrent;
  }
  /**
   * Start seeding a new file/folder.
   * @param  {string|File|FileList|Buffer|Array.<string|File|Buffer>} input
   * @param  {Object=} opts
   * @param  {function=} onseed called when torrent is seeding
   */
  seed(input, opts, onseed) {
    if (this.destroyed) throw new Error("client is destroyed");
    if (typeof opts === "function") [opts, onseed] = [{}, opts];
    this._debug("seed");
    opts = opts ? Object.assign({}, opts) : {};
    opts.skipVerify = true;
    const isFilePath = typeof input === "string";
    if (isFilePath) opts.path = import_path4.default.dirname(input);
    if (!opts.createdBy) opts.createdBy = `WebTorrent/${VERSION_STR}`;
    const onTorrent = (torrent2) => {
      const tasks = [
        (cb) => {
          if (isFilePath || opts.preloadedStore) return cb();
          torrent2.load(streams, cb);
        }
      ];
      if (this.dht) {
        tasks.push((cb) => {
          torrent2.once("dhtAnnounce", cb);
        });
      }
      (0, import_run_parallel5.default)(tasks, (err2) => {
        if (this.destroyed) return;
        if (err2) return torrent2._destroy(err2);
        _onseed(torrent2);
      });
    };
    const _onseed = (torrent2) => {
      this._debug("on seed");
      if (typeof onseed === "function") onseed(torrent2);
      torrent2.emit("seed");
      this.emit("seed", torrent2);
    };
    const torrent = this.add(null, opts, onTorrent);
    let streams;
    if (isFileList2(input)) input = Array.from(input);
    else if (!Array.isArray(input)) input = [input];
    (0, import_run_parallel5.default)(input.map((item) => async (cb) => {
      if (!opts.preloadedStore && isReadable2(item)) {
        const chunks = [];
        try {
          for await (const chunk of item) {
            chunks.push(chunk);
          }
        } catch (err2) {
          return cb(err2);
        }
        const buf = concat(chunks);
        buf.name = item.name;
        cb(null, buf);
      } else {
        cb(null, item);
      }
    }), (err2, input2) => {
      if (this.destroyed) return;
      if (err2) return torrent._destroy(err2);
      parseInput(input2, opts, (err3, files) => {
        if (this.destroyed) return;
        if (err3) return torrent._destroy(err3);
        streams = files.map((file) => file.getStream);
        create_torrent_default(input2, opts, async (err4, torrentBuf) => {
          if (this.destroyed) return;
          if (err4) return torrent._destroy(err4);
          const existingTorrent = await this.get(torrentBuf);
          if (existingTorrent) {
            console.warn("A torrent with the same id is already being seeded");
            torrent._destroy();
            if (typeof onseed === "function") onseed(existingTorrent);
          } else {
            torrent._onTorrentId(torrentBuf);
          }
        });
      });
    });
    return torrent;
  }
  /**
   * Remove a torrent from the client.
   * @param  {string|Buffer|Torrent}   torrentId
   * @param  {function} cb
   */
  async remove(torrentId, opts, cb) {
    if (typeof opts === "function") return this.remove(torrentId, null, opts);
    this._debug("remove");
    const torrent = await this.get(torrentId);
    if (!torrent) throw new Error(`No torrent with id ${torrentId}`);
    this._remove(torrent, opts, cb);
  }
  _remove(torrent, opts, cb) {
    if (!torrent) return;
    if (typeof opts === "function") return this._remove(torrent, null, opts);
    const index = this.torrents.indexOf(torrent);
    if (index === -1) return;
    this.torrents.splice(index, 1);
    torrent.destroy(opts, cb);
    if (this.dht) {
      this.dht._tables.remove(torrent.infoHash);
    }
    this.emit("remove", torrent);
  }
  address() {
    if (!this.listening) return null;
    return this._connPool ? this._connPool.tcpServer.address() : { address: "0.0.0.0", family: "IPv4", port: 0 };
  }
  /**
   * Set global download throttle rate.
   * @param  {Number} rate (must be bigger or equal than zero, or -1 to disable throttling)
   */
  throttleDownload(rate) {
    rate = Number(rate);
    if (isNaN(rate) || !isFinite(rate) || rate < -1) return false;
    this._downloadLimit = rate;
    if (this._downloadLimit < 0) return this.throttleGroups.down.setEnabled(false);
    this.throttleGroups.down.setEnabled(true);
    this.throttleGroups.down.setRate(this._downloadLimit);
  }
  /**
   * Set global upload throttle rate
   * @param  {Number} rate (must be bigger or equal than zero, or -1 to disable throttling)
   */
  throttleUpload(rate) {
    rate = Number(rate);
    if (isNaN(rate) || !isFinite(rate) || rate < -1) return false;
    this._uploadLimit = rate;
    if (this._uploadLimit < 0) return this.throttleGroups.up.setEnabled(false);
    this.throttleGroups.up.setEnabled(true);
    this.throttleGroups.up.setRate(this._uploadLimit);
  }
  /**
   * Destroy the client, including all torrents and connections to peers.
   * @param  {function} cb
   */
  destroy(cb) {
    if (this.destroyed) throw new Error("client already destroyed");
    this._destroy(null, cb);
  }
  _destroy(err2, cb) {
    this._debug("client destroy");
    this.destroyed = true;
    const tasks = this.torrents.map((torrent) => (cb2) => {
      torrent.destroy(cb2);
    });
    if (this._connPool) {
      tasks.push((cb2) => {
        this._connPool.destroy(cb2);
      });
    }
    if (this.dht) {
      tasks.push((cb2) => {
        this.dht.destroy(cb2);
      });
    }
    if (this._server) {
      tasks.push((cb2) => {
        this._server.destroy(cb2);
      });
    }
    if (this.natTraversal) {
      tasks.push((cb2) => {
        this.natTraversal.destroy().then(() => cb2());
      });
    }
    (0, import_run_parallel5.default)(tasks, cb);
    if (err2) this.emit("error", err2);
    this.torrents = [];
    this._connPool = null;
    this.dht = null;
    this.throttleGroups.down.destroy();
    this.throttleGroups.up.destroy();
  }
  _onListening() {
    this._debug("listening");
    this.listening = true;
    if (this._connPool) {
      const address = this._connPool.tcpServer.address();
      if (address) {
        this.torrentPort = address.port;
        if (this.natTraversal) {
          this.natTraversal.map({
            publicPort: this.torrentPort,
            privatePort: this.torrentPort,
            protocol: this.utp ? null : "tcp",
            description: "WebTorrent Torrent"
          }).catch((err2) => {
            debug12("error mapping WebTorrent port via UPnP/PMP: %o", err2);
          });
        }
      }
    }
    this.emit("listening");
  }
  _debug() {
    const args = [].slice.call(arguments);
    args[0] = `[${this._debugId}] ${args[0]}`;
    debug12(...args);
  }
  async _getByHash(infoHashHash) {
    for (const torrent of this.torrents) {
      if (!torrent.infoHashHash) {
        torrent.infoHashHash = await hash(hex2arr("72657132" + torrent.infoHash), "hex");
      }
      if (infoHashHash === torrent.infoHashHash) {
        return torrent;
      }
    }
    return null;
  }
};
WebTorrent.WEBRTC_SUPPORT = lite_default.WEBRTC_SUPPORT;
WebTorrent.UTP_SUPPORT = import_conn_pool.default.UTP_SUPPORT;
WebTorrent.VERSION = import_version3.default;
function isReadable2(obj) {
  return typeof obj === "object" && obj != null && typeof obj.pipe === "function";
}
function isFileList2(obj) {
  return typeof FileList !== "undefined" && obj instanceof FileList;
}
export {
  WebTorrent as default
};
/*! Bundled license information:

queue-microtask/index.js:
  (*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

run-parallel/index.js:
  (*! run-parallel. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

cache-chunk-store/index.js:
  (*! cache-chunk-store. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)

safe-buffer/index.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

immediate-chunk-store/index.js:
  (*! immediate-chunk-store. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

run-parallel-limit/index.js:
  (*! run-parallel-limit. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

escape-html/index.js:
  (*!
   * escape-html
   * Copyright(c) 2012-2013 TJ Holowaychuk
   * Copyright(c) 2015 Andreas Lubbe
   * Copyright(c) 2015 Tiancheng "Timothy" Gu
   * MIT Licensed
   *)

range-parser/index.js:
  (*!
   * range-parser
   * Copyright(c) 2012-2014 TJ Holowaychuk
   * Copyright(c) 2015-2016 Douglas Christopher Wilson
   * MIT Licensed
   *)

create-torrent/index.js:
  (*! create-torrent. MIT License. WebTorrent LLC <https://webtorrent.io/opensource> *)

magnet-uri/index.js:
  (*! magnet-uri. MIT License. WebTorrent LLC <https://webtorrent.io/opensource> *)

parse-torrent/index.js:
  (*! parse-torrent. MIT License. WebTorrent LLC <https://webtorrent.io/opensource> *)

@thaunknown/simple-peer/lite.js:
  (*! simple-peer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

bittorrent-dht/index.js:
  (*! bittorrent-dht. MIT License. WebTorrent LLC <https://webtorrent.io/opensource> *)

@thaunknown/simple-websocket/index.js:
  (*! simple-websocket. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

bittorrent-tracker/index.js:
  (*! bittorrent-tracker. MIT License. WebTorrent LLC <https://webtorrent.io/opensource> *)

torrent-discovery/index.js:
  (*! torrent-discovery. MIT License. WebTorrent LLC <https://webtorrent.io/opensource> *)

lt_donthave/index.js:
  (*! lt_donthave. MIT License. WebTorrent LLC <https://webtorrent.io/opensource> *)

torrent-piece/index.js:
  (*! torrent-piece. MIT License. WebTorrent LLC <https://webtorrent.io/opensource> *)

ut_metadata/index.js:
  (*! ut_metadata. MIT License. WebTorrent LLC <https://webtorrent.io/opensource> *)

webtorrent/index.js:
  (*! webtorrent. MIT License. WebTorrent LLC <https://webtorrent.io/opensource> *)
*/
//# sourceMappingURL=webtorrent.js.map
